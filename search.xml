<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《PHP基础教程（第4版）》</title>
      <link href="/2023/07/25/PHP%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/"/>
      <url>/2023/07/25/PHP%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/527efa359c7d12f012639a10b4d00cdd.png" alt="《PHP基础教程（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>由贾菡等编译的《PHP基础教程(第4版)》以通俗易懂的语言向初学者介绍了PHP语言的基本概念、使用方法和注意事项。全书通过丰富的示例，引领读者逐步掌握这门流行的Web开发语言，使读者能够上手编写适用于常用场景的PHP脚本。</p><p>《PHP基础教程(第4版)》适合有基本HTML经验的读者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Halligan 市场营销软件开发公司HubSpot创始人兼CEO，致力于帮助其他企业“被目标客户找到”。他也是一位眼光超前的风险投资家、经验丰富的销售及营销主管，常应邀去MIT以及哈佛商学院举办讲座。</p><p>Dharmesh Shah HubSpot公司创始人兼CTO，天使投资人，撰写的博客OnStartups.com拥有大量粉丝。他还屡次应邀就市场营销以及企业家精神这类主题发表演说。</p><p>侯德杰 北京邮电大学英语专业，后取得北京交通大学项目管理硕士学位。目前就职于北京全路通信信号研究设计院，全职翻译和审核文档，曾翻译出版《网络营销实训》，对网络营销有较深入的研究。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1 章 PHP 概述　　 1<br>1.1 HTML 语法基础　　 1<br>1.2 PHP 语法基础　　6<br>1.3 使用FTP 　 8<br>1.4 测试脚本　　 9<br>1.5 向浏览器发送文本　　 12<br>1.6 使用PHP 手册　　14<br>1.7 向浏览器发送HTML 　　16<br>1.8 为脚本添加注释　　19<br>1.9 调试的基本步骤　　21<br>1.10 回顾和实践　　 22<br>第2 章 变量　　 24<br>2.1 什么是变量　　 24<br>2.2 变量语法　　 27<br>2.3 变量类型　　 29<br>2.4 为变量赋值　　 32<br>2.5 理解引号　　 34<br>2.6 回顾和实践　　 37<br>第3 章 HTML 表单和PHP 　　 38<br>3.1 创建简单的表单　　 38<br>3.2 选择表单的method　　 42<br>3.3 使用PHP 接收表单数据　　 44<br>3.4 显示错误　　 48<br>3.5 错误报告　　 51<br>3.6 向页面手动发送数据　　 53<br>3.7 回顾和实践　　 58<br>第4 章 使用数值　　 60<br>4.1 创建表单　　 60<br>4.2 算术运算　　 63<br>4.3 格式化数值　　 67<br>4.4 理解优先级　　 70<br>4.5 数值的自增和自减　　 72<br>4.6 创建随机数　　 75<br>4.7 回顾和实践　　 77<br>第5 章 使用字符串　　 78<br>5.1 创建HTML 表单　　 78<br>5.2 连接字符串　　 81<br>5.3 处理换行符　　 84<br>5.4 HTML 和PHP　　 85<br>5.5 字符串的编码和解码　　89<br>5.6 查找子字符串　　 92<br>5.7 替换局部字符串　　 96<br>5.8 回顾和实践　　 99<br>第6 章 控制结构　　100<br>6.1 创建HTML 表单　　 100<br>6.2 if 条件语句　　 104<br>6.3 验证函数　　 106<br>6.4 使用else 　　110<br>6.5 更多运算符　　112<br>6.6 使用elseif　　 121<br>6.7 switch 条件语句　　 125<br>6.8 for 循环　　 130<br>6.9 回顾和实践　　135<br>第7 章 使用数组　　136<br>7.1 什么是数组　　136<br>7.2 创建数组　　138<br>7.3 向数组添加项　　 141<br>7.4 访问数组元素　　 144<br>7.5 创建多维数组　　 148<br>7.6 数组排序　　 152<br>7.7 字符串和数组之间的转换　　156<br>7.8 在表单中创建数组　　160<br>7.9 回顾和实践　　165<br>第8 章 创建Web 应用程序　　166<br>8.1 创建模板　　 166<br>8.2 使用外部文件　　 175<br>8.3 使用常量　　180<br>8.4 使用日期和时间　　 184<br>8.5 再谈使用PHP 处理HTML 表单　　 188<br>8.6 使表单更具粘性　　 194<br>8.7 发送Email　　 201<br>8.8 输出缓冲　　205<br>8.9 处理HTTP 头　　 209<br>8.10 回顾和实践　　 213<br>第9 章 cookie 和session 　　214<br>9.1 什么是cookie　　 214<br>9.2 创建cookie　　 217<br>9.3 读取cookie　　 223<br>9.4 向cookie 添加参数　　 227<br>9.5 删除cookie　　 230<br>9.6 什么是session　　 233<br>9.7 创建session　　234<br>9.8 访问session 变量　　 237<br>9.9 删除session　　239<br>9.10 回顾和实践　　241<br>第10 章 创建函数　　243<br>10.1 创建和使用简单函数　　243<br>10.2 创建和调用接受参数的函数　　248<br>10.3 设置参数默认值　　 253<br>10.4 创建和使用带有返回值的函数　　 255<br>10.5 理解变量作用域　　 259<br>10.6 回顾和实践　　 264<br>第11 章 文件和目录　　265<br>11.1 文件权限　　265<br>11.2 写入文件　　270<br>11.3 锁定文件　　276<br>11.4 读取文件　　278<br>11.5 处理文件上传　　 281<br>11.6 导航目录　　288<br>11.7 创建目录　　293<br>11.8 增量读取文件　　298<br>11.9 回顾和实践　　 303<br>第12 章 数据库介绍　　305<br>12.1 SQL 介绍　　 305<br>12.2 连接MySQL 　307<br>12.3 MySQL 错误处理　　311<br>12.4 创建和选择数据库　　313<br>12.5 创建表　　316<br>12.6 向数据库插入数据　　320<br>12.7 安全查询数据　　325<br>12.8 从数据库中检索数据　　 328<br>12.9 删除数据库中的数据　　 333<br>12.10 更新数据库中的数据　　 338<br>12.11 回顾和实践　　 343<br>第13 章 将所有的组合在一起　　344<br>13.1 准备开始　　 344<br>13.2 连接数据库　　 346<br>13.3 编写用户定义函数　　 347<br>13.4 创建模板　　349<br>13.5 登录　　 352<br>13.6 登出　　 355<br>13.7 添加名人名言　　 357<br>13.8 列示名人名言　　 361<br>13.9 编辑名人名言　　 364<br>13.10 删除名人名言　　 370<br>13.11 创建主页　　 374<br>13.12 回顾和实践　　378<br>附录A 安装和配置　　379<br>附录B 深入学习PHP 的资源　　397</p><h3 id="PHP基础教程（第4版）-PDF-下载"><a href="#PHP基础教程（第4版）-PDF-下载" class="headerlink" title="PHP基础教程（第4版） PDF 下载"></a>PHP基础教程（第4版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1wYnMhDS5kqsgHKb9lSNC3w?pwd=cxu2">https://pan.baidu.com/s/1wYnMhDS5kqsgHKb9lSNC3w?pwd=cxu2</a> </p><p>提取码：cxu2</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> PHP </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kubernetes in Action中文版》</title>
      <link href="/2023/05/24/Kubernetes%20in%20Action%E4%B8%AD%E6%96%87%E7%89%88/"/>
      <url>/2023/05/24/Kubernetes%20in%20Action%E4%B8%AD%E6%96%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/4311db6aa915c642bafafcf5873fd2d5.png" alt="《Kubernetes in Action中文版》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Kubernetes in Action中文版》主要讲解如何在 Kubernetes 中部署分布式容器应用。《Kubernetes in Action中文版》开始部分概要介绍了 Docker 和Kubernetes 的由来和发展，然后通过在 Kubernetes 中部署一个应用程序，一点点增加功能，逐步加深我们对于Kubernetes架构的理解和操作的实践。在本书的后面部分，也可以学习一些高阶的主题，比如监控、调试及伸缩。 Kubernetes是希腊文，意思是“舵手”，带领我们安全地到达未知水域。Kubernetes这样的容器编排系统，会帮助我们妥善地管理分布式应用的部署结构和线上流量，高效地组织容器和服务。Kubernetes 作为数据中心操作系统，在设计软件系统时，能够尽量降低在底层网络和硬件设施上的负担。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Marko Luksa是一位拥有20年以上专业开发经验的软件工程师，经手项目小到简单的Web应用，大到ERP系统、框架和中间件软件，应有尽有。在为Red Hat工作期间，他从Google App Engine API实现的开发起步, 这些API将基于Red Hat的JBoss中间件产品，之后他一直在为CDI&#x2F;Weld、Infinispan&#x2F;JBoss DataGrid等项目贡献力量。2014后, 他加入Red Hat的Cloud Enablement团队，负责 Kubernetes和相关技术开发的更新，保障公司的中间件软件能将Kubernetes与OpenShift特性的潜能用到极致。 译者简介 七牛容器云 （KIRK）团队，是负责七牛云基于自身公有云业务在容器方面的多年实践经验，针对企业应用快速部署、便捷运维打造的容器云计算平台。提供持续集成、弹性伸缩、应用市场等功能特性，使企业专注于业务逻辑开发，缩短业务上线周期，优化资源利用率，提高服务响应效率的一支技术团队。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>1Kubernetes介绍1<br>1.1Kubernetes系统的需求2<br>1.1.1从单体应用到微服务2<br>1.1.2为应用程序提供一个一致的环境5<br>1.1.3迈向持续交付：DevOps和无运维6<br>1.2介绍容器技术7<br>1.2.1什么是容器7<br>1.2.2Docker容器平台介绍11<br>1.2.3rkt——一个Docker的替代方案14<br>1.3Kubernetes介绍15<br>1.3.1初衷15<br>1.3.2深入浅出地了解Kubernetes15<br>1.3.3Kubernetes集群架构17<br>1.3.4在Kubernetes中运行应用18<br>1.3.5使用Kubernetes的好处20<br>1.4本章小结22<br>2开始使用Kubernetes和Docker23<br>2.1创建、运行及共享容器镜像23<br>2.1.1安装Docker并运行HelloWorld容器24<br>2.1.2创建一个简单的Node.js应用26<br>2.1.3为镜像创建Dockerfile27<br>2.1.4构建容器镜像27<br>2.1.5运行容器镜像30<br>2.1.6探索运行容器的内部31<br>2.1.7停止和删除容器32<br>2.1.8向镜像仓库推送镜像33<br>2.2配置Kubernetes集群34<br>2.2.1用Minikube运行一个本地单节点Kubernetes集群34<br>2.2.2使用GoogleKubernetesEngine托管Kubernetes集群36<br>2.2.3为kubectl配置别名和命令行补齐39<br>2.3在Kubernetes上运行第一个应用40<br>2.3.1部署Node.js应用40<br>2.3.2访问Web应用43<br>2.3.3系统的逻辑部分45<br>2.3.4水平伸缩应用46<br>2.3.5查看应用运行在哪个节点上49<br>2.3.6介绍Kubernetesdashboard50<br>2.4本章小结51<br>3pod：运行于Kubernetes中的容器53<br>3.1介绍pod53<br>3.1.1为何需要pod54<br>3.1.2了解pod55<br>3.1.3通过pod合理管理容器56<br>3.2以YAML或JSON描述文件创建pod58<br>3.2.1检查现有pod的YAML描述文件59<br>3.2.2为pod创建一个简单的YAML描述文件61<br>3.2.3使用kubectlcreate来创建pod63<br>3.2.4查看应用程序日志64<br>3.2.5向pod发送请求65<br>3.3使用标签组织pod66<br>3.3.1介绍标签66<br>3.3.2创建pod时指定标签67<br>3.3.3修改现有pod的标签68<br>3.4通过标签选择器列出pod子集69<br>3.4.1使用标签选择器列出pod69<br>3.4.2在标签选择器中使用多个条件71<br>3.5使用标签和选择器来约束pod调度71<br>3.5.1使用标签分类工作节点72<br>3.5.2将pod调度到特定节点72<br>3.5.3调度到一个特定节点73<br>3.6注解pod73<br>3.6.1查找对象的注解74<br>3.6.2添加和修改注解74<br>3.7使用命名空间对资源进行分组75<br>3.7.1了解对命名空间的需求75<br>3.7.2发现其他命名空间及其pod75<br>3.7.3创建一个命名空间76<br>3.7.4管理其他命名空间中的对象77<br>3.7.5命名空间提供的隔离78<br>3.8停止和移除pod78<br>3.8.1按名称删除pod78<br>3.8.2使用标签选择器删除pod79<br>3.8.3通过删除整个命名空间来删除pod80<br>3.8.4删除命名空间中的所有pod，但保留命名空间80<br>3.8.5删除命名空间中的（几乎）所有资源80<br>3.9本章小结81<br>4副本机制和其他控制器：部署托管的pod83<br>4.1保持pod健康84<br>4.1.1介绍存活探针84<br>4.1.2创建基于HTTP的存活探针85<br>4.1.3使用存活探针86<br>4.1.4配置存活探针的附加属性87<br>4.1.5创建有效的存活探针88<br>4.2了解ReplicationController89<br>4.2.1ReplicationController的操作90<br>4.2.2创建一个ReplicationController92<br>4.2.3使用ReplicationController94<br>4.2.4将pod移入或移出ReplicationController的作用域97<br>4.2.5修改pod模板100<br>4.2.6水平缩放pod101<br>4.2.7删除一个ReplicationController103<br>4.3使用ReplicaSet而不是ReplicationController104<br>4.3.1比较ReplicaSet和ReplicationController104<br>4.3.2定义ReplicaSet105<br>4.3.3创建和检查ReplicaSet106<br>4.3.4使用ReplicaSet的更富表达力的标签选择器106<br>4.3.5ReplicaSet小结107<br>4.4使用DaemonSet在每个节点上运行一个pod107<br>4.4.1使用DaemonSet在每个节点上运行一个pod108<br>4.4.2使用DaemonSet只在特定的节点上运行pod109<br>4.5运行执行单个任务的pod112<br>4.5.1介绍Job资源112<br>4.5.2定义Job资源113<br>4.5.3看Job运行一个pod114<br>4.5.4在Job中运行多个pod实例114<br>4.5.5限制Jobpod完成任务的时间116<br>4.6安排Job定期运行或在将来运行一次116<br>4.6.1创建一个CronJob116<br>4.6.2了解计划任务的运行方式118<br>4.7本章小结118<br>5服务：让客户端发现pod并与之通信121<br>5.1介绍服务122<br>5.1.1创建服务123<br>5.1.2服务发现129<br>5.2连接集群外部的服务132<br>5.2.1介绍服务endpoint133<br>5.2.2手动配置服务的endpoint133<br>5.2.3为外部服务创建别名135<br>5.3将服务暴露给外部客户端136<br>5.3.1使用NodePort类型的服务137<br>5.3.2通过负载均衡器将服务暴露出来140<br>5.3.3了解外部连接的特性142<br>5.4通过Ingress暴露服务143<br>5.4.1创建Ingress资源145<br>5.4.2通过Ingress访问服务146<br>5.4.3通过相同的Ingress暴露多个服务147<br>5.4.4配置Ingress处理TLS传输149<br>5.5pod就绪后发出信号150<br>5.5.1介绍就绪探针151<br>5.5.2向pod添加就绪探针152<br>5.5.3了解就绪探针的实际作用154<br>5.6使用headless服务来发现独立的pod155<br>5.6.1创建headless服务156<br>5.6.2通过DNS发现pod156<br>5.6.3发现所有的pod——包括未就绪的pod157<br>5.7排除服务故障158<br>5.8本章小结159<br>6卷：将磁盘挂载到容器161<br>6.1介绍卷162<br>6.1.1卷的应用示例162<br>6.1.2介绍可用的卷类型164<br>6.2通过卷在容器之间共享数据165<br>6.2.1使用emptyDir卷165<br>6.2.2使用Git仓库作为存储卷168<br>6.3访问工作节点文件系统上的文件171<br>6.3.1介绍hostPath卷171<br>6.3.2检查使用hostPath卷的系统pod172<br>6.4使用持久化存储173<br>6.4.1使用GCE持久磁盘作为pod存储卷174<br>6.4.2通过底层持久化存储使用其他类型的卷177<br>6.5从底层存储技术解耦pod179<br>6.5.1介绍持久卷和持久卷声明179<br>6.5.2创建持久卷180<br>6.5.3通过创建持久卷声明来获取持久卷182<br>6.5.4在pod中使用持久卷声明184<br>6.5.5了解使用持久卷和持久卷声明的好处185<br>6.5.6回收持久卷186<br>6.6持久卷的动态卷配置187<br>6.6.1通过StorageClass资源定义可用存储类型188<br>6.6.2请求持久卷声明中的存储类188<br>6.6.3不指定存储类的动态配置190<br>6.7本章小结193<br>7ConfigMap和Secret：配置应用程序195<br>7.1配置容器化应用程序195<br>7.2向容器传递命令行参数196<br>7.2.1在Docker中定义命令与参数196<br>7.2.2在Kubernetes中覆盖命令和参数199<br>7.3为容器设置环境变量200<br>7.3.1在容器定义中指定环境变量201<br>7.3.2在环境变量值中引用其他环境变量201<br>7.3.3了解硬编码环境变量的不足之处202<br>7.4利用ConfigMap解耦配置202<br>7.4.1ConfigMap介绍202<br>7.4.2创建ConfigMap203<br>7.4.3给容器传递ConfigMap条目作为环境变量206<br>7.4.4一次性传递ConfigMap的所有条目作为环境变量208<br>7.4.5传递ConfigMap条目作为命令行参数209<br>7.4.6使用configMap卷将条目暴露为文件210<br>7.4.7更新应用配置且不重启应用程序216<br>7.5使用Secret给容器传递敏感数据218<br>7.5.1介绍Secret218<br>7.5.2默认令牌Secret介绍218<br>7.5.3创建Secret220<br>7.5.4对比ConfigMap与Secret221<br>7.5.5在pod中使用Secret222<br>7.6本章小结228<br>8从应用访问pod元数据以及其他资源229<br>8.1通过DownwardAPI传递元数据229<br>8.1.1了解可用的元数据230<br>8.1.2通过环境变量暴露元数据231<br>8.1.3通过downwardAPI卷来传递元数据234<br>8.2与KubernetesAPI服务器交互237<br>8.2.1探究KubernetesRESTAPI238<br>8.2.2从pod内部与API服务器进行交互242<br>8.2.3通过ambassador容器简化与API服务器的交互248<br>8.2.4使用客户端库与API服务器交互251<br>8.3本章小结253<br>9Deployment:声明式地升级应用255<br>9.1更新运行在pod内的应用程序256<br>9.1.1删除旧版本pod，使用新版本pod替换257<br>9.1.2先创建新pod再删除旧版本pod257<br>9.2使用ReplicationController实现自动的滚动升级259<br>9.2.1运行第一个版本的应用259<br>9.2.2使用kubectl来执行滚动式升级261<br>9.2.3为什么kubectlrolling-update已经过时265<br>9.3使用Deployment声明式地升级应用266<br>9.3.1创建一个Deployment267<br>9.3.2升级Deployment269<br>9.3.3回滚Deployment273<br>9.3.4控制滚动升级速率276<br>9.3.5暂停滚动升级278<br>9.3.6阻止出错版本的滚动升级279<br>9.4本章小结284<br>10StatefulSet：部署有状态的多副本应用285<br>10.1复制有状态pod285<br>10.1.1运行每个实例都有单独存储的多副本286<br>10.1.2每个pod都提供稳定的标识287<br>10.2了解Statefulset289<br>10.2.1对比Statefulset和ReplicaSet289<br>10.2.2提供稳定的网络标识290<br>10.2.3为每个有状态实例提供稳定的专属存储292<br>10.2.4Statefulset的保障294<br>10.3使用Statefulset295<br>10.3.1创建应用和容器镜像295<br>10.3.2通过Statefulset部署应用296<br>10.3.3使用你的pod301<br>10.4在Statefulset中发现伙伴节点305<br>10.4.1通过DNS实现伙伴间彼此发现306<br>10.4.2更新Statefulset308<br>10.4.3尝试集群数据存储309<br>10.5了解Statefulset如何处理节点失效310<br>10.5.1模拟一个节点的网络断开310<br>10.5.2手动删除pod312<br>10.6本章小结313<br>11了解Kubernetes机理315<br>11.1了解架构315<br>11.1.1Kubernetes组件的分布式特性316<br>11.1.2Kubernetes如何使用etcd318<br>11.1.3API服务器做了什么322<br>11.1.4API服务器如何通知客户端资源变更324<br>11.1.5了解调度器325<br>11.1.6介绍控制器管理器中运行的控制器327<br>11.1.7Kubelet做了什么331<br>11.1.8KubernetesServiceProxy的作用332<br>11.1.9介绍Kubernetes插件333<br>11.1.10总结概览335<br>11.2控制器如何协作335<br>11.2.1了解涉及哪些组件335<br>11.2.2事件链336<br>11.2.3观察集群事件337<br>11.3了解运行中的pod是什么339<br>11.4跨pod网络340<br>11.4.1网络应该是什么样的340<br>11.4.2深入了解网络工作原理341<br>11.4.3引入容器网络接口343<br>11.5服务是如何实现的344<br>11.5.1引入kube-proxy344<br>11.5.2kube-proxy如何使用iptables344<br>11.6运行高可用集群346<br>11.6.1让你的应用变得高可用346<br>11.6.2让Kubernetes控制平面变得高可用347<br>11.7本章小结350<br>12KubernetesAPI服务器的安全防护351<br>12.1了解认证机制351<br>12.1.1用户和组352<br>12.1.2ServiceAccount介绍353<br>12.1.3创建ServiceAccount354<br>12.1.4将ServiceAccount分配给pod356<br>12.2通过基于角色的权限控制加强集群安全358<br>12.2.1介绍RBAC授权插件359<br>12.2.2介绍RBAC资源360<br>12.2.3使用Role和RoleBinding363<br>12.2.4使用ClusterRole和ClusterRoleBinding367<br>12.2.5了解默认的ClusterRole和ClusterRoleBinding376<br>12.2.6理性地授予授权权限379<br>12.3本章小结379<br>13保障集群内节点和网络安全381<br>13.1在pod中使用宿主节点的Linux命名空间381<br>13.1.1在pod中使用宿主节点的网络命名空间382<br>13.1.2绑定宿主节点上的端口而不使用宿主节点的网络命名空间383<br>13.1.3使用宿主节点的PID与IPC命名空间385<br>13.2配置节点的安全上下文386<br>13.2.1使用指定用户运行容器387<br>13.2.2阻止容器以root用户运行388<br>13.2.3使用特权模式运行pod389<br>13.2.4为容器单独添加内核功能390<br>13.2.5在容器中禁用内核功能391<br>13.2.6阻止对容器根文件系统的写入392<br>13.2.7容器使用不同用户运行时共享存储卷394<br>13.3限制pod使用安全相关的特性396<br>13.3.1PodSecurityPolicy资源介绍396<br>13.3.2了解runAsUser、fsGroup和supplementalGroup策略398<br>13.3.3配置允许、默认添加、禁止使用的内核功能400<br>13.3.4限制pod可以使用的存储卷类型402<br>13.3.5对不同的用户与组分配不同的PodSecurityPolicy402<br>13.4隔离pod的网络406<br>13.4.1在一个命名空间中启用网络隔离406<br>13.4.2允许同一命名空间中的部分pod访问一个服务端pod407<br>13.4.3在不同Kubernetes命名空间之间进行网络隔离408<br>13.4.4使用CIDR隔离网络409<br>13.4.5限制pod的对外访问流量409<br>13.5本章小结410<br>14计算资源管理411<br>14.1为pod中的容器申请资源411<br>14.1.1创建包含资源requests的pod412<br>14.1.2资源requests如何影响调度413<br>14.1.3CPUrequests如何影响CPU时间分配418<br>14.1.4定义和申请自定义资源418<br>14.2限制容器的可用资源419<br>14.2.1设置容器可使用资源量的硬限制419<br>14.2.2超过limits421<br>14.2.3容器中的应用如何看待limits422<br>14.3了解podQoS等级423<br>14.3.1定义pod的QoS等级424<br>14.3.2内存不足时哪个进程会被杀死426<br>14.4为命名空间中的pod设置默认的requests和limits427<br>14.4.1LimitRange资源简介428<br>14.4.2LimitRange对象的创建428<br>14.4.3强制进行限制430<br>14.4.4应用资源requests和limits的默认值430<br>14.5限制命名空间中的可用资源总量431<br>14.5.1ResourceQuota资源介绍431<br>14.5.2为持久化存储指定配额434<br>14.5.3限制可创建对象的个数434<br>14.5.4为特定的pod状态或者QoS等级指定配额435<br>14.6监控pod的资源使用量436<br>14.6.1收集、获取实际资源使用情况437<br>14.6.2保存并分析历史资源的使用统计信息439<br>14.7本章小结442<br>15自动横向伸缩pod与集群节点443<br>15.1pod的横向自动伸缩444<br>15.1.1了解自动伸缩过程444<br>15.1.2基于CPU使用率进行自动伸缩447<br>15.1.3基于内存使用进行自动伸缩453<br>15.1.4基于其他自定义度量进行自动伸缩453<br>15.1.5确定哪些度量适合用于自动伸缩456<br>15.1.6缩容到0个副本456<br>15.2pod的纵向自动伸缩456<br>15.2.1自动配置资源请求457<br>15.2.2修改运行中pod的资源请求457<br>15.3集群节点的横向伸缩457<br>15.3.1ClusterAutoscaler介绍457<br>15.3.2启用ClusterAutoscaler459<br>15.3.3限制集群缩容时的服务干扰460<br>15.4本章小结461<br>16高级调度463<br>16.1使用污点和容忍度阻止节点调度到特定节点463<br>16.1.1介绍污点和容忍度464<br>16.1.2在节点上添加自定义污点466<br>16.1.3在pod上添加污点容忍度467<br>16.1.4了解污点和污点容忍度的使用场景467<br>16.2使用节点亲缘性将pod调度到特定节点上469<br>16.2.1指定强制性节点亲缘性规则470<br>16.2.2调度pod时优先考虑某些节点472<br>16.3使用pod亲缘性与非亲缘性对pod进行协同部署475<br>16.3.1使用pod间亲缘性将多个pod部署在同一个节点上475<br>16.3.2将pod部署在同一机柜、可用性区域或者地理地域478<br>16.3.3表达pod亲缘性优先级取代强制性要求479<br>16.3.4利用pod的非亲缘性分开调度pod481<br>16.4本章小结483<br>17开发应用的最佳实践485<br>17.1集中一切资源486<br>17.2了解pod的生命周期487<br>17.2.1应用必须预料到会被杀死或者重新调度487<br>17.2.2重新调度死亡的或者部分死亡的pod490<br>17.2.3以固定顺序启动pod491<br>17.2.4增加生命周期钩子493<br>17.2.5了解pod的关闭497<br>17.3确保所有的客户端请求都得到了妥善处理500<br>17.3.1在pod启动时避免客户端连接断开500<br>17.3.2在pod关闭时避免客户端连接断开501<br>17.4让应用在Kubernetes中方便运行和管理505<br>17.4.1构建可管理的容器镜像505<br>17.4.2合理地给镜像打标签，正确地使用ImagePullPolicy506<br>17.4.3使用多维度而不是单维度的标签506<br>17.4.4通过注解描述每个资源506<br>17.4.5给进程终止提供更多的信息507<br>17.4.6处理应用日志508<br>17.5开发和测试的最佳实践510<br>17.5.1开发过程中在Kubernetes之外运行应用510<br>17.5.2在开发过程中使用Minikube512<br>17.5.3发布版本和自动部署资源清单513<br>17.5.4使用Ksonnet作为编写YAML&#x2F;JSONmanifest文件的额外选择513<br>17.5.5利用持续集成和持续交付514<br>17.6本章小结515<br>18Kubernetes应用扩展517<br>18.1定义自定义API对象517<br>18.1.1CustomResourceDefinitions介绍518<br>18.1.2使用自定义控制器自动定制资源522<br>18.1.3验证自定义对象526<br>18.1.4为自定义对象提供自定义API服务器527<br>18.2使用Kubernetes服务目录扩展Kubernetes528<br>18.2.1服务目录介绍529<br>18.2.2服务目录API服务器与控制器管理器介绍530<br>18.2.3Service代理和OpenServiceBrokerAPI530<br>18.2.4提供服务与使用服务533<br>18.2.5解除绑定与取消配置535<br>18.2.6服务目录给我们带来了什么535<br>18.3基于Kubernetes搭建的平台536<br>18.3.1红帽OpenShift容器平台536<br>18.3.2DeisWorkflow与Helm539<br>18.4本章小结541<br>A在多个集群中使用kubectl543<br>B使用kubeadm配置多节点集群549<br>C使用其他容器运行时563<br>DClusterFederation567</p><h3 id="Kubernetes-in-Action中文版-PDF-下载地址"><a href="#Kubernetes-in-Action中文版-PDF-下载地址" class="headerlink" title="Kubernetes in Action中文版 PDF 下载地址:"></a>Kubernetes in Action中文版 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1WeU06FLqA0dFtOSO6Kj49Q?pwd=42h4">https://pan.baidu.com/s/1WeU06FLqA0dFtOSO6Kj49Q?pwd=42h4</a> </p><p>提取码：42h4</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Lua程序设计》</title>
      <link href="/2023/05/24/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/24/Lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/cf9e4f3d7bd23092d0bd78cf82db10d1.png" alt="《Lua程序设计》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Lua程序设计（第4版）》由Lua 语言作者亲自撰写，针对Lua 语言本身由浅入深地从各个方面进行了完整和细致的讲解。作为第4 版，《Lua程序设计（第4版）》主要针对的是Lua 5.3，这是《Lua程序设计（第4版）》撰写时Lua 语言的最新版本。作者从语言使用者的角度出发，讲解了语言基础、编程实操、高级特性及C 语言API 等四个方面的内容，既有Lua 语言基本数据类型、输入输出、控制结构等基础知识，也有对模块、闭包、元表、协程、延续、反射、环境、垃圾回收、函数式编程、面向对象编程、C 语言API 等高级特性的系统讲解，还有对Lua 5.3 中引入的整型、位运算、瞬表、延续等新功能的细致说明。 所有与Lua 语言打交道的人均能从《Lua程序设计（第4版）》受益，包括游戏、嵌入式、物联网、软件安全、逆向工程、移动互联网、C 语言核心系统开发等诸多领域中对Lua 语言有一般使用需要的从业人员，以及需要从编译原理或语言设计哲学和实现角度深入学习Lua 语言脚本引擎的高级开发者或研究人员。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>无</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第 1 部分 语言基础 1<br>1 Lua 语言入门 2<br>1.1 程序段 3<br>1.2 一些词法规范 5<br>1.3 全局变量 7<br>1.4 类型和值 7<br>1.4.1 nil 8<br>1.4.2 Boolean 8<br>1.5 独立解释器 10<br>1.6 练习 12<br>2 小插曲：八皇后问题 13<br>2.1 练习 15<br>3 数值 17<br>3.1 数值常量 17<br>3.2 算术运算 19<br>3.3 关系运算 21<br>3.4 数学库 21<br>3.4.1 随机数发生器 22<br>3.4.2 取整函数 22<br>3.5 表示范围 24<br>3.6 惯例 25<br>3.7 运算符优先级 26<br>3.8 兼容性 27<br>3.9 练习 28<br>4 字符串 30<br>4.1 字符串常量 31<br>4.2 长字符串&#x2F;多行字符串 33<br>4.3 强制类型转换 34<br>4.4 字符串标准库 36<br>4.5 Unicode 编码 39<br>4.6 练习 41<br>5 表 43<br>5.1 表索引 44<br>5.2 表构造器 46<br>5.3 数组、列表和序列 48<br>5.4 遍历表 50<br>5.5 安全访问 52<br>5.6 表标准库 53<br>5.7 练习 54<br>6 函数 56<br>6.1 多返回值 58<br>6.2 可变长参数函数 61<br>6.3 函数 table.unpack 64<br>6.4 正确的尾调用 65<br>6.5 练习 66<br>7 输入输出 68<br>7.1 简单 I&#x2F;O 模型 68<br>7.2 完整 I&#x2F;O 模型 72<br>7.3 其他文件操作 74<br>7.4 其他系统调用 75<br>7.4.1 运行系统命令 75<br>7.5 练习 77<br>8 补充知识 78<br>8.1 局部变量和代码块 78<br>8.2 控制结构 80<br>8.2.1 if then else 81<br>8.2.2 while 81<br>8.2.3 repeat 82<br>8.2.4 数值型 for 82<br>8.2.5 泛型 for 83<br>8.3 break、return 和 goto 84<br>8.4 练习 88<br>第 2 部分 编程实操 90<br>9 闭包 91<br>9.1 函数是第一类值 92<br>9.2 非全局函数 94<br>9.3 词法定界 96<br>9.4 小试函数式编程 100<br>9.5 练习 103<br>10 模式匹配 105<br>10.1 模式匹配的相关函数 105<br>10.1.1 函数 string.find 105<br>10.1.2 函数 string.match 106<br>10.1.3 函数 string.gsub 107<br>10.1.4 函数 string.gmatch 107<br>10.2 模式 108<br>10.3 捕获 112<br>10.4 替换 114<br>10.4.1 URL 编码 116<br>10.4.2 制表符展开 118<br>10.5 诀窍 119<br>10.6 练习 123<br>11 小插曲：出现频率最高的单词 124<br>11.1 练习 126<br>12 日期和时间 128<br>12.1 函数 os.time 129<br>12.2 函数 os.date 130<br>12.3 日期和时间处理 132<br>12.4 练习 134<br>13 位和字节 135<br>13.1 位运算 135<br>13.2 无符号整型数 136<br>13.3 打包和解包二进制数据 139<br>13.4 二进制文件 142<br>13.5 练习 144<br>14 数据结构 145<br>14.1 数组 146<br>14.2 矩阵及多维数组 146<br>14.3 链表 149<br>14.4 队列及双端队列 150<br>14.5 反向表 151<br>14.6 集合与包 152<br>14.7 字符串缓冲区 154<br>14.8 图形 156<br>14.9 练习 158<br>15 数据文件和序列化 159<br>15.1 数据文件 160<br>15.2 序列化 162<br>15.2.1 保存不带循环的表 165<br>15.2.2 保存带有循环的表 167<br>15.3 练习 169<br>16 编译、执行和错误 171<br>16.1 编译 171<br>16.2 预编译的代码 175<br>16.3 错误 177<br>16.4 错误处理和异常 179<br>16.5 错误信息和栈回溯 180<br>16.6 练习 182<br>17 模块和包 184<br>17.1 函数 require 185<br>17.1.1 模块重命名 187<br>17.1.2 搜索路径 188<br>17.1.3 搜索器 190<br>17.2 Lua 语言中编写模块的基本方法 190<br>17.3 子模块和包 193<br>17.4 练习 194<br>第 3 部分 语言特性 196<br>18 迭代器和泛型 for 197<br>18.1 迭代器和闭包 197<br>18.2 泛型 for 的语法 200<br>18.3 无状态迭代器 201<br>18.4 按顺序遍历表 203<br>18.5 迭代器的真实含义 205<br>18.6 练习 206<br>19 小插曲：马尔可夫链算法 208<br>19.1 练习 211<br>20 元表和元方法 212<br>20.1 算术运算相关的元方法 213<br>20.2 关系运算相关的元方法 216<br>20.3 库定义相关的元方法 217<br>20.4 表相关的元方法 219<br>20.4.1 __index 元方法 219<br>20.4.2 __newindex 元方法 220<br>20.4.3 具有默认值的表 221<br>20.4.4 跟踪对表的访问 222<br>20.4.5 只读的表 224<br>20.5 练习 225<br>21 面向对象（Object-Oriented）编程 226<br>21.1 类（Class） 228<br>21.2 继承（Inheritance） 230<br>21.3 多重继承（Multiple Inheritance） 232<br>21.4 私有性（Privacy） 235<br>21.5 单方法对象（Single-method Object） 237<br>21.6 对偶表示（Dual Representation） 238<br>21.7 练习 240<br>22 环境（Environment） 241<br>22.1 具有动态名称的全局变量 242<br>22.2 全局变量的声明 243<br>22.3 非全局环境 246<br>22.4 使用 _ENV 248<br>22.5 环境和模块 251<br>22.6 _ENV 和 load 252<br>22.7 练习 254<br>23 垃圾收集 255<br>23.1 弱引用表 255<br>23.2 记忆函数（Memorize Function） 257<br>23.3 对象属性（Object Attribute） 259<br>23.4 回顾具有默认值的表 260<br>23.5 瞬表（Ephemeron Table） 261<br>23.6 析构器（Finalizer） 262<br>23.7 垃圾收集器 266<br>23.8 控制垃圾收集的步长（Pace） 267<br>23.9 练习 268<br>24 协程（Coroutine） 270<br>24.1 协程基础 270<br>24.2 哪个协程占据主循环 273<br>24.3 将协程用作迭代器 276<br>24.4 事件驱动式编程 279<br>24.5 练习 284<br>25 反射（Reflection） 285<br>25.1 自省机制（Introspective Facility） 286<br>25.1.1 访问局部变量 288<br>25.1.2 访问非局部变量 289<br>25.1.3 访问其他协程 291<br>25.2 钩子（Hook） 292<br>25.3 调优（Profile） 293<br>25.4 沙盒（Sandbox） 296<br>25.5 练习 300<br>26 小插曲：使用协程实现多线程 301<br>26.1 练习 306<br>第 4 部分 C 语言 API 307<br>27 C 语言 API 总览 308<br>27.1 第一个示例 309<br>27.2 栈 312<br>27.2.1 压入元素 313<br>27.2.2 查询元素 314<br>27.2.3 其他栈操作 317<br>27.3 使用 C API 进行错误处理 320<br>27.3.1 处理应用代码中的错误 320<br>27.3.2 处理库代码中的错误 321<br>27.4 内存分配 322<br>27.5 练习 324<br>28 扩展应用 325<br>28.1 基础知识 325<br>28.2 操作表 327<br>28.2.1 一些简便方法 331<br>28.3 调用 Lua 函数 333<br>28.4 一个通用的调用函数 334<br>28.5 练习 338<br>29 在 Lua 中调用 C 语言 339<br>29.1 C 函数 339<br>29.2 延续（Continuation） 342<br>29.3 C 模块 345<br>29.4 练习 347<br>30 编写 C 函数的技巧 349<br>30.1 数组操作 349<br>30.2 字符串操作 351<br>30.3 在 C 函数中保存状态 355<br>30.3.1 注册表 355<br>30.3.2 上值 358<br>30.3.3 共享的上值（Shared upvalue） 361<br>30.4 练习 362<br>31 C 语言中的用户自定义类型 363<br>31.1 用户数据（Userdata） 364<br>31.2 元表（Metatable） 367<br>31.3 面向对象访问 370<br>31.4 数组访问 372<br>31.5 轻量级用户数据 373<br>31.6 练习 375<br>32 管理资源 376<br>32.1 目录迭代器 376<br>32.2 XML 解析器 380<br>32.3 练习 390<br>33 线程和状态 392<br>33.1 多线程 392<br>33.2 Lua 状态 397<br>33.3 练习 406</p><h3 id="Lua程序设计-PDF-下载地址"><a href="#Lua程序设计-PDF-下载地址" class="headerlink" title="Lua程序设计 PDF 下载地址:"></a>Lua程序设计 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1uZCy84RbQIQ6NpLMc__MtQ?pwd=0g09">https://pan.baidu.com/s/1uZCy84RbQIQ6NpLMc__MtQ?pwd=0g09</a> </p><p>提取码：0g09</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Lua语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kafka权威指南》</title>
      <link href="/2023/05/24/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/24/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1cf24ea01ffd8c6e8d27b099935eedd4.png" alt="《Kafka权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>每个应用程序都会产生数据，包括日志消息、度量指标、用户活动记录、响应消息等。如何移动数据，几乎变得与数据本身一样重要。如果你是架构师、开发者或者产品工程师，同时也是Apache Kafka新手，那么这本实践指南将会帮助你成为流式平台上处理实时数据的专家。 本书由出身于LinkedIn的Kafka核心作者和一线技术人员共同执笔，详细介绍了如何部署Kafka集群、开发可靠的基于事件驱动的微服务，以及基于Kafka平台构建可伸缩的流式应用程序。通过详尽示例，你将会了解到Kafka的设计原则、可靠性保证、关键API，以及复制协议、控制器和存储层等架构细节。 ● 了解发布和订阅消息模型以及该模型如何被应用在大数据生态系统中 ● 学习使用Kafka生产者和消费者来生成消息和读取消息 ● 了解Kafka保证可靠性数据传递的模式和场景需求 ● 使用Kafka构建数据管道和应用程序的最佳实践 ● 在生产环境中管理Kafka，包括监控、调优和维护 ● 了解Kafka的关键度量指标 ● 探索Kafka如何成为流式处理利器</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Neha Narkhede， Confluent联合创始人、CTO，曾在LinkedIn主导基于Kafka和Apache Samza构建流式基础设施，是Kafka作者之一。 Gwen Shapira， Confluent系统架构师，帮助客户构建基于Kafka的系统，在可伸缩数据架构方面拥有十余年经验；曾任Cloudera公司解决方案架构师。另著有《Hadoop应用架构》。 Todd Palino， LinkedIn主任级SRE，负责部署管理大型的Kafka、Zookeeper和Samza集群。 【译者简介】 薛命灯，毕业于厦门大学软件学院，十余年软件开发和架构经验，InfoQ高级社区编辑。译有《硅谷革命》《生产微服务》等书。微信公众号CodeDeep。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>序xiii<br>前言xv<br>第1章　初识Kafka1<br>1.1　发布与订阅消息系统1<br>1.1.1　如何开始2<br>1.1.2　独立的队列系统3<br>1.2　Kafka登场4<br>1.2.1　消息和批次4<br>1.2.2　模式4<br>1.2.3　主题和分区5<br>1.2.4　生产者和消费者5<br>1.2.5　broker和集群6<br>1.2.6　多集群7<br>1.3　为什么选择Kafka8<br>1.3.1　多个生产者8<br>1.3.2　多个消费者8<br>1.3.3　基于磁盘的数据存储9<br>1.3.4　伸缩性9<br>1.3.5　高性能9<br>1.4　数据生态系统9<br>1.5　起源故事11<br>1.5.1　LinkedIn的问题11<br>1.5.2　Kafka的诞生12<br>1.5.3　走向开源12<br>1.5.4　命名13<br>1.6　开始Kafka之旅13<br>第2章　安装Kafka14<br>2.1　要事先行14<br>2.1.1　选择操作系统14<br>2.1.2　安装Java14<br>2.1.3　安装Zookeeper15<br>2.2　安装KafkaBroker17<br>2.3　broker配置18<br>2.3.1　常规配置18<br>2.3.2　主题的默认配置19<br>2.4　硬件的选择23<br>2.4.1　磁盘吞吐量23<br>2.4.2　磁盘容量23<br>2.4.3　内存23<br>2.4.4　网络24<br>2.4.5　CPU24<br>2.5　云端的Kafka24<br>2.6　Kafka集群24<br>2.6.1　需要多少个broker25<br>2.6.2　broker配置25<br>2.6.3　操作系统调优26<br>2.7　生产环境的注意事项28<br>2.7.1　垃圾回收器选项28<br>2.7.2　数据中心布局29<br>2.7.3　共享Zookeeper29<br>2.8　总结30<br>第3章　Kafka生产者——向Kafka写入数据31<br>3.1　生产者概览32<br>3.2　创建Kafka生产者33<br>3.3　发送消息到Kafka34<br>3.3.1　同步发送消息35<br>3.3.2　异步发送消息35<br>3.4　生产者的配置36<br>3.5　序列化器39<br>3.5.1　自定义序列化器39<br>3.5.2　使用Avro序列化41<br>3.5.3　在Kafka里使用Avro42<br>3.6　分区45<br>3.7　旧版的生产者API46<br>3.8　总结47<br>第4章　Kafka消费者——从Kafka读取数据48<br>4.1　KafkaConsumer概念48<br>4.1.1　消费者和消费者群组48<br>4.1.2　消费者群组和分区再均衡51<br>4.2　创建Kafka消费者52<br>4.3　订阅主题53<br>4.4　轮询53<br>4.5　消费者的配置55<br>4.6　提交和偏移量57<br>4.6.1　自动提交58<br>4.6.2　提交当前偏移量59<br>4.6.3　异步提交59<br>4.6.4　同步和异步组合提交61<br>4.6.5　提交特定的偏移量61<br>4.7　再均衡监听器62<br>4.8　从特定偏移量处开始处理记录64<br>4.9　如何退出66<br>4.10　反序列化器67<br>4.11　独立消费者——为什么以及怎样使用没有群组的消费者71<br>4.12　旧版的消费者API71<br>4.13　总结72<br>第5章　深入Kafka73<br>5.1　集群成员关系73<br>5.2　控制器74<br>5.3　复制74<br>5.4　处理请求76<br>5.4.1　生产请求78<br>5.4.2　获取请求78<br>5.4.3　其他请求80<br>5.5　物理存储81<br>5.5.1　分区分配81<br>5.5.2　文件管理82<br>5.5.3　文件格式83<br>5.5.4　索引84<br>5.5.5　清理84<br>5.5.6　清理的工作原理84<br>5.5.7　被删除的事件86<br>5.5.8　何时会清理主题86<br>5.9　总结86<br>第6章　可靠的数据传递87<br>6.1　可靠性保证87<br>6.2　复制88<br>6.3　broker配置89<br>6.3.1　复制系数89<br>6.3.2　不完全的首领选举90<br>6.3.3　最少同步副本91<br>6.4　在可靠的系统里使用生产者92<br>6.4.1　发送确认92<br>6.4.2　配置生产者的重试参数93<br>6.4.3　额外的错误处理94<br>6.5　在可靠的系统里使用消费者94<br>6.5.1　消费者的可靠性配置95<br>6.5.2　显式提交偏移量95<br>6.6　验证系统可靠性97<br>6.6.1　配置验证98<br>6.6.2　应用程序验证98<br>6.6.3　在生产环境监控可靠性99<br>6.7　总结100<br>第7章　构建数据管道101<br>7.1　构建数据管道时需要考虑的问题102<br>7.1.1　及时性102<br>7.1.2　可靠性102<br>7.1.3　高吞吐量和动态吞吐量103<br>7.1.4　数据格式103<br>7.1.5　转换104<br>7.1.6　安全性104<br>7.1.7　故障处理能力104<br>7.1.8　耦合性和灵活性105<br>7.2　如何在ConnectAPI和客户端API之间作出选择105<br>7.3　KafkaConnect106<br>7.3.1　运行Connect106<br>7.3.2　连接器示例——文件数据源和文件数据池107<br>7.3.3　连接器示例——从MySQL到ElasticSearch109<br>7.3.4　深入理解Connect114<br>7.4　Connect之外的选择116<br>7.4.1　用于其他数据存储的摄入框架116<br>7.4.2　基于图形界面的ETL工具117<br>7.4.3　流式处理框架117<br>7.5　总结117<br>第8章　跨集群数据镜像118<br>8.1　跨集群镜像的使用场景118<br>8.2　多集群架构119<br>8.2.1　跨数据中心通信的一些现实情况119<br>8.2.2　Hub和Spoke架构120<br>8.2.3　双活架构121<br>8.2.4　主备架构123<br>8.2.5　延展集群127<br>8.3　Kafka的MirrorMaker128<br>8.3.1　如何配置129<br>8.3.2　在生产环境部署MirrorMaker130<br>8.3.3　MirrorMaker调优132<br>8.4　其他跨集群镜像方案134<br>8.4.1　优步的uReplicator134<br>8.4.2　Confluent的Replicator135<br>8.5　总结135<br>第9章　管理Kafka136<br>9.1　主题操作136<br>9.1.1　创建主题137<br>9.1.2　增加分区138<br>9.1.3　删除主题138<br>9.1.4　列出集群里的所有主题139<br>9.1.5　列出主题详细信息139<br>9.2　消费者群组140<br>9.2.1　列出并描述群组140<br>9.2.2　删除群组142<br>9.2.3　偏移量管理142<br>9.3　动态配置变更143<br>9.3.1　覆盖主题的默认配置143<br>9.3.2　覆盖客户端的默认配置145<br>9.3.3　列出被覆盖的配置145<br>9.3.4　移除被覆盖的配置146<br>9.4　分区管理146<br>9.4.1　首选的首领选举146<br>9.4.2　修改分区副本147<br>9.4.3　修改复制系数150<br>9.4.4　转储日志片段151<br>9.4.5　副本验证152<br>9.5　消费和生产153<br>9.5.1　控制台消费者153<br>9.5.2　控制台生产者155<br>9.6　客户端ACL157<br>9.7　不安全的操作157<br>9.7.1　移动集群控制器157<br>9.7.2　取消分区重分配157<br>9.7.3　移除待删除的主题158<br>9.7.4　手动删除主题158<br>9.8　总结159<br>第10章　监控Kafka160<br>10.1　度量指标基础160<br>10.1.1　度量指标在哪里160<br>10.1.2　内部或外部度量161<br>10.1.3　应用程序健康检测161<br>10.1.4　度量指标的覆盖面161<br>10.2　broker的度量指标162<br>10.2.1　非同步分区162<br>10.2.2　broker度量指标166<br>10.2.3　主题和分区的度量指标173<br>10.2.4　Java虚拟机监控174<br>10.2.5　操作系统监控175<br>10.2.6　日志176<br>10.3　客户端监控177<br>10.3.1　生产者度量指标177<br>10.3.2　消费者度量指标179<br>10.3.3　配额181<br>10.4　延时监控182<br>10.5　端到端监控183<br>10.6　总结183<br>第11章　流式处理184<br>11.1　什么是流式处理185<br>11.2　流式处理的一些概念186<br>11.2.1　时间187<br>11.2.2　状态188<br>11.2.3　流和表的二元性188<br>11.2.4　时间窗口189<br>11.3　流式处理的设计模式190<br>11.3.1　单个事件处理191<br>11.3.2　使用本地状态191<br>11.3.3　多阶段处理和重分区193<br>11.3.4　使用外部查找——流和表的连接193<br>11.3.5　流与流的连接195<br>11.3.6　乱序的事件195<br>11.3.7　重新处理196<br>11.4　Streams示例197<br>11.4.1　字数统计197<br>11.4.2　股票市场统计199<br>11.4.3　填充点击事件流201<br>11.5　KafkaStreams的架构概览202<br>11.5.1　构建拓扑202<br>11.5.2　对拓扑进行伸缩203<br>11.5.3　从故障中存活下来205<br>11.6　流式处理使用场景205<br>11.7　如何选择流式处理框架206<br>11.8　总结208<br>附录A　在其他操作系统上安装Kafka209<br>作者介绍214<br>封面介绍214</p><h3 id="Kafka权威指南-PDF-下载地址"><a href="#Kafka权威指南-PDF-下载地址" class="headerlink" title="Kafka权威指南 PDF 下载地址:"></a>Kafka权威指南 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1NbS95FK6jjwdsT3CVVpBdA?pwd=g4l1">https://pan.baidu.com/s/1NbS95FK6jjwdsT3CVVpBdA?pwd=g4l1</a> </p><p>提取码：g4l1</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《每天5分钟玩转Docker容器技术》</title>
      <link href="/2023/05/24/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/24/%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACDocker%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/711ccdbbc82b13f2ef0dd8ef5cb677c5.png" alt="《每天5分钟玩转Docker容器技术》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>Docker和容器技术是当下热门的IT技术，无论是互联网还是传统企业都在研究和实践如何用容器构建自己的 IT 基础设施。学习本书能够让读者少走弯路，系统地学习、掌握和实践 Docker 和容器技术。 本书共分为三部分。靠前部分介绍容器技术生态环境。第二部分是容器核心知识，包括架构、镜像、容器、网络和存储。第三部分是容器进阶知识，包括多主机管理、跨主机网络方案、监控、日志管理和数据管理。读者在学习的过程中，可以跟着教程进行操作，在实践中掌握 Docker 容器技术的核心技能。在之后的工作中，可以将本教程作为参考书，按需查找相关知识点。 本书主要面向微服务软件开发人员，以及 IT 实施和运维工程师等相关人员，也适合高等院校和培训学校相关专业的师生教学参考。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>CloudMan，十多年 IT 从业经验，就职于国际知名 IT 企业，从事 IT 基础设施实施服务，项目涉及服务器、存储、网络、虚拟化、云技术等各个方面。CloudMan 对新技术长期保持浓厚的兴趣和学习热情，十几年来一直专注 IT 技术领域的钻研与实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1篇启程<br>第1章鸟瞰容器生态系统3<br>1.1容器生态系统3<br>1.2本教程覆盖的知识范围10<br>1.3准备实验环境10<br>1.3.1环境选择10<br>1.3.2安装Docker10<br>1.4运行第1个容器11<br>1.5小结12<br>第二篇容器技术<br>第2章容器核心知识概述15<br>2.1What——什么是容器15<br>2.2Why——为什么需要容器16<br>2.2.1容器解决的问题16<br>2.2.2Docker的特性20<br>2.2.3容器的优势20<br>2.3How——容器是如何工作的21<br>2.4小结24<br>第3章Docker镜像26<br>3.1镜像的内部结构26<br>3.1.1hello-world——最小的镜像26<br>3.1.2base镜像27<br>3.1.3镜像的分层结构30<br>3.2构建镜像32<br>3.2.1dockercommit32<br>3.2.2Dockerfile34<br>3.3RUNvsCMDvsENTRYPOINT42<br>3.3.1Shell和Exec格式42<br>3.3.2RUN44<br>3.3.3CMD44<br>3.3.4ENTRYPOINT45<br>3.3.5最佳实践46<br>3.4分发镜像46<br>3.4.1为镜像命名46<br>3.4.2使用公共Registry49<br>3.4.3搭建本地Registry51<br>3.5小结52<br>第4章Docker容器55<br>4.1运行容器55<br>4.1.1让容器长期运行56<br>4.1.2两种进入容器的方法57<br>4.1.3运行容器的最佳实践59<br>4.1.4容器运行小结59<br>4.2stop&#x2F;start&#x2F;restart容器60<br>4.3pause&#x2F;unpause容器61<br>4.4删除容器61<br>4.5StateMachine62<br>4.6资源限制65<br>4.6.1内存限额65<br>4.6.2CPU限额66<br>4.6.3BlockIO带宽限额68<br>4.7实现容器的底层技术69<br>4.7.1cgroup70<br>4.7.2namespace70<br>4.8小结72<br>第5章Docker网络74<br>5.1none网络74<br>5.2host网络75<br>5.3bridge网络76<br>5.4user-defined网络78<br>5.5容器间通信84<br>5.5.1IP通信84<br>5.5.2DockerDNSServer85<br>5.5.3joined容器85<br>5.6将容器与外部世界连接87<br>5.6.1容器访问外部世界87<br>5.6.2外部世界访问容器90<br>5.7小结91<br>第6章Docker存储92<br>6.1storagedriver92<br>6.2DataVolume94<br>6.2.1bindmount94<br>6.2.2dockermanagedvolume96<br>6.3数据共享99<br>6.3.1容器与host共享数据99<br>6.3.2容器之间共享数据99<br>6.4volumecontainer100<br>6.5data-packedvolumecontainer102<br>6.6DataVolume生命周期管理103<br>6.6.1备份104<br>6.6.2恢复104<br>6.6.3迁移104<br>6.6.4销毁104<br>6.7小结105<br>第三篇容器进阶知识<br>第7章多主机管理109<br>7.1实验环境描述110<br>7.2安装DockerMachine111<br>7.3创建Machine112<br>7.4管理Machine114<br>第8章容器网络117<br>8.1libnetwork&amp;CNM117<br>8.2overlay119<br>8.2.1实验环境描述120<br>8.2.2创建overlay网络121<br>8.2.3在overlay中运行容器122<br>8.2.4overlay网络连通性124<br>8.2.5overlay网络隔离126<br>8.2.6overlayIPAM127<br>8.3macvlan127<br>8.3.1准备实验环境127<br>8.3.2创建macvlan网络128<br>8.3.3macvlan网络结构分析130<br>8.3.4用sub-interface实现多macvlan网络131<br>8.3.5macvlan网络间的隔离和连通132<br>8.4flannel136<br>8.4.1实验环境描述137<br>8.4.2安装配置etcd137<br>8.4.3buildflannel138<br>8.4.4将flannel网络的配置信息保存到etcd139<br>8.4.5启动flannel139<br>8.4.6配置Docker连接flannel141<br>8.4.7将容器连接到flannel网络143<br>8.4.8flannel网络连通性144<br>8.4.9flannel网络隔离146<br>8.4.10flannel与外网连通性146<br>8.4.11host-gwbackend146<br>8.5weave148<br>8.5.1实验环境描述148<br>8.5.2安装部署weave149<br>8.5.3在host1中启动weave149<br>8.5.4在host1中启动容器150<br>8.5.5在host2中启动weave并运行容器153<br>8.5.6weave网络连通性154<br>8.5.7weave网络隔离155<br>8.5.8weave与外网的连通性156<br>8.5.9IPAM158<br>8.6calico158<br>8.6.1实验环境描述159<br>8.6.2启动etcd159<br>8.6.3部署calico160<br>8.6.4创建calico网络161<br>8.6.5在calico中运行容器161<br>8.6.6calico默认连通性164<br>8.6.7calicopolicy167<br>8.6.8calicoIPAM169<br>8.7比较各种网络方案170<br>8.7.1网络模型171<br>8.7.2DistributedStore171<br>8.7.3IPAM171<br>8.7.4连通与隔离172<br>8.7.5性能172<br>第9章容器监控173<br>9.1Docker自带的监控子命令173<br>9.1.1ps173<br>9.1.2…74<br>9.1.3stats175<br>9.2sysdig175<br>9.3WeaveScope179<br>9.3.1安装179<br>9.3.2容器监控181<br>9.3.3监控host184<br>9.3.4多主机监控186<br>9.4cAdvisor189<br>9.4.1监控DockerHost189<br>9.4.2监控容器191<br>9.5Prometheus194<br>9.5.1架构194<br>9.5.2多维数据模型195<br>9.5.3实践196<br>9.6比较不同的监控工具204<br>9.7几点建议205<br>第10章日志管理207<br>10.1Dockerlogs207<br>10.2Dockerloggingdriver209<br>10.3ELK211<br>10.3.1日志处理流程211<br>10.3.2安装ELK套件212<br>10.3.3Filebeat214<br>10.3.4管理日志216<br>10.4Fluentd220<br>10.4.1安装Fluentd221<br>10.4.2重新配置Filebeat221<br>10.4.3监控容器日志221<br>10.5Graylog222<br>10.5.1Graylog架构222<br>10.5.2部署Graylog223<br>10.5.3配置Graylog225<br>10.5.4监控容器日志227<br>10.6小结229<br>第11章数据管理230<br>11.1从一个例子开始230<br>11.2实践Rex-Raydriver232<br>11.2.1安装Rex-Ray232<br>11.2.2配置VirtualBox234<br>11.2.3创建Rex-Rayvolume236<br>11.2.4使用Rex-Rayvolume237<br>写在最后243</p><h3 id="每天5分钟玩转Docker容器技术-PDF-下载地址"><a href="#每天5分钟玩转Docker容器技术-PDF-下载地址" class="headerlink" title="每天5分钟玩转Docker容器技术 PDF 下载地址:"></a>每天5分钟玩转Docker容器技术 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1erOEpzOOWo5djAMRMIlPHA?pwd=avvw">https://pan.baidu.com/s/1erOEpzOOWo5djAMRMIlPHA?pwd=avvw</a> </p><p>提取码：avvw</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Nginx（第2版）》</title>
      <link href="/2023/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/586618a77d10293862d1149eba4e03c3.png" alt="《深入理解Nginx（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书致力于说明开发Nginx模块的必备知识，第1版发行以后，深受广大读者的喜爱．然而由于Ng,nx功能繁多且性能强大，以致必须了解的基本技能也很庞杂，而第1版成书匆忙，缺失了几个进阶的技巧描述，因此第2版在此基础上进行了完善。</p><p>书中首先通过介绍官方Nginx的基本用法和配置规则，帮助读者了解一般Nginx模块的用法，然后重点介绍了女口何开发HTTP模块(含HTTP过滤模块)来得到定制化的Nginx，其中包括开发—个功能复杂的模块所需要了解的各种知识，并对内存池的实现细节及TCP协议进行了详细介绍；接着，综合Nginx框架代码分析了Nginx架构的设计理念和技巧，此外，还新增了如何在模块中支持HTTP变量，以及与slab共享内存等相关的内容，相信通过完善，可进一步帮助读者更好地开发出功能丰富、性能—流的Nginx模块。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>陶辉，毕业于西安交通大学计算机科学与技术专业，曾就职于华为中央软件部、腾讯QQ空间、思科中国CRDC等公司，目前在阿里巴巴云计算公司的飞天团队工作，研究方向为介于Iaas和Paas间的弹性计算，多年以来专注于Nginx的定制化应用，对Nginx的设计与特性有深刻认识，实战经验丰富，编写过许多优秀的Nginx模块并应用于企业级产品中，同时撰写了大量关于Nginx的技术文章。擅长Linux下高性能服务器的开发，以及分布式环境下海量数据存储的设计开发。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　Nginx能帮我们做什么<br>第1章　研究Nginx前的准备工作2<br>1.1　Nginx是什么2<br>1.2　为什么选择Nginx5<br>1.3　准备工作7<br>1.3.1　Linux操作系统7<br>1.3.2　使用Nginx的必备软件7<br>1.3.3　磁盘目录8<br>1.3.4　Linux内核参数的优化9<br>1.3.5　获取Nginx源码10<br>1.4　编译安装Nginx11<br>1.5　configure详解11<br>1.5.1　configure的命令参数11<br>1.5.2　configure执行流程18<br>1.5.3　configure生成的文件21<br>1.6　Nginx的命令行控制23<br>1.7　小结27<br>第2章　Nginx的配置28<br>2.1　运行中的Nginx进程间的关系28<br>2.2　Nginx配置的通用语法31<br>2.2.1　块配置项31<br>2.2.2　配置项的语法格式32<br>2.2.3　配置项的注释33<br>2.2.4　配置项的单位33<br>2.2.5　在配置中使用变量33<br>2.3　Nginx服务的基本配置34<br>2.3.1　用于调试进程和定位问题的配置项34<br>2.3.2　正常运行的配置项36<br>2.3.3　优化性能的配置项37<br>2.3.4　事件类配置项39<br>2.4　用HTTP核心模块配置一个静态Web服务器40<br>2.4.1　虚拟主机与请求的分发41<br>2.4.2　文件路径的定义45<br>2.4.3　内存及磁盘资源的分配47<br>2.4.4　网络连接的设置49<br>2.4.5　MIME类型的设置52<br>2.4.6　对客户端请求的限制53<br>2.4.7　文件操作的优化54<br>2.4.8　对客户端请求的特殊处理56<br>2.4.9　ngx_http_core_module模块提供的变量57<br>2.5　用HTTPproxymodule配置一个反向代理服务器59<br>2.5.1　负载均衡的基本配置61<br>2.5.2　反向代理的基本配置63<br>2.6　小结66<br>第二部分　如何编写HTTP模块<br>第3章　开发一个简单的HTTP模块68<br>3.1　如何调用HTTP模块68<br>3.2　准备工作70<br>3.2.1　整型的封装71<br>3.2.2　ngx_str_t数据结构71<br>3.2.3　ngx_list_t数据结构71<br>3.2.4　ngx_table_elt_t数据结构75<br>3.2.5　ngx_buf_t数据结构75<br>3.2.6　ngx_chain_t数据结构77<br>3.3　如何将自己的HTTP模块编译进Nginx77<br>3.3.1　config文件的写法77<br>3.3.2　利用configure脚本将定制的模块加入到Nginx中78<br>3.3.3　直接修改Makefile文件81<br>3.4　HTTP模块的数据结构82<br>3.5　定义自己的HTTP模块86<br>3.6　处理用户请求89<br>3.6.1　处理方法的返回值89<br>3.6.2　获取URI和参数92<br>3.6.3　获取HTTP头部94<br>3.6.4　获取HTTP包体97<br>3.7　发送响应99<br>3.7.1　发送HTTP头部99<br>3.7.2　将内存中的字符串作为包体发送101<br>3.7.3　经典的“HelloWorld”示例102<br>3.8　将磁盘文件作为包体发送103<br>3.8.1　如何发送磁盘中的文件104<br>3.8.2　清理文件句柄106<br>3.8.3　支持用户多线程下载和断点续传107<br>3.9　用C++语言编写HTTP模块108<br>3.9.1　编译方式的修改108<br>3.9.2　程序中的符号转换109<br>3.10　小结110<br>第4章　配置、error日志和请求上下文111<br>4.1　http配置项的使用场景111<br>4.2　怎样使用http配置113<br>4.2.1　分配用于保存配置参数的数据结构113<br>4.2.2　设定配置项的解析方式115<br>4.2.3　使用14种预设方法解析配置项121<br>4.2.4　自定义配置项处理方法131<br>4.2.5　合并配置项133<br>4.3　HTTP配置模型135<br>4.3.1　解析HTTP配置的流程136<br>4.3.2　HTTP配置模型的内存布局139<br>4.3.3　如何合并配置项142<br>4.3.4　预设配置项处理方法的工作原理144<br>4.4　error日志的用法145<br>4.5　请求的上下文149<br>4.5.1　上下文与全异步Web服务器的关系149<br>4.5.2　如何使用HTTP上下文151<br>4.5.3　HTTP框架如何维护上下文结构152<br>4.6　小结153<br>第5章　访问第三方服务154<br>5.1　upstream的使用方式155<br>5.1.1　ngx_http_upstream_t结构体158<br>5.1.2　设置upstream的限制性参数159<br>5.1.3　设置需要访问的第三方服务器地址160<br>5.1.4　设置回调方法161<br>5.1.5　如何启动upstream机制161<br>5.2　回调方法的执行场景162<br>5.2.1　create_request回调方法162<br>5.2.2　reinit_request回调方法164<br>5.2.3　finalize_request回调方法165<br>5.2.4　process_header回调方法165<br>5.2.5　rewrite_redirect回调方法167<br>5.2.6　input_filter_init与input_filter回调方法167<br>5.3　使用upstream的示例168<br>5.3.1　upstream的各种配置参数168<br>5.3.2　请求上下文170<br>5.3.3　在create_request方法中构造请求170<br>5.3.4　在process_header方法中解析包头171<br>5.3.5　在finalize_request方法中释放资源175<br>5.3.6　在ngx_http_mytest_handler方法中启动upstream175<br>5.4　subrequest的使用方式177<br>5.4.1　配置子请求的处理方式177<br>5.4.2　实现子请求处理完毕时的回调方法178<br>5.4.3　处理父请求被重新激活后的回调方法179<br>5.4.4　启动subrequest子请求179<br>5.5　subrequest执行过程中的主要场景180<br>5.5.1　如何启动subrequest180<br>5.5.2　如何转发多个子请求的响应包体182<br>5.5.3　子请求如何激活父请求185<br>5.6　subrequest使用的例子187<br>5.6.1　配置文件中子请求的设置187<br>5.6.2　请求上下文188<br>5.6.3　子请求结束时的处理方法188<br>5.6.4　父请求的回调方法189<br>5.6.5　启动subrequest190<br>5.7　小结191<br>第6章　开发一个简单的HTTP过滤模块192<br>6.1　过滤模块的意义192<br>6.2　过滤模块的调用顺序193<br>6.2.1　过滤链表是如何构成的194<br>6.2.2　过滤链表的顺序196<br>6.2.3　官方默认HTTP过滤模块的功能简介197<br>6.3　HTTP过滤模块的开发步骤198<br>6.4　HTTP过滤模块的简单例子200<br>6.4.1　如何编写config文件201<br>6.4.2　配置项和上下文201<br>6.4.3　定义HTTP过滤模块203<br>6.4.4　初始化HTTP过滤模块204<br>6.4.5　处理请求中的HTTP头部204<br>6.4.6　处理请求中的HTTP包体206<br>6.5　小结206<br>第7章　Nginx提供的高级数据结构207<br>7.1　Nginx提供的高级数据结构概述207<br>7.2　ngx_queue_t双向链表209<br>7.2.1　为什么设计ngx_queue_t双向链表209<br>7.2.2　双向链表的使用方法209<br>7.2.3　使用双向链表排序的例子212<br>7.2.4　双向链表是如何实现的213<br>7.3　ngx_array_t动态数组215<br>7.3.1　为什么设计ngx_array_t动态数组215<br>7.3.2　动态数组的使用方法215<br>7.3.3　使用动态数组的例子217<br>7.3.4　动态数组的扩容方式218<br>7.4　ngx_list_t单向链表219<br>7.5　ngx_rbtree_t红黑树219<br>7.5.1　为什么设计ngx_rbtree_t红黑树219<br>7.5.2　红黑树的特性220<br>7.5.3　红黑树的使用方法222<br>7.5.4　使用红黑树的简单例子225<br>7.5.5　如何自定义添加成员方法226<br>7.6　ngx_radix_tree_t基数树228<br>7.6.1　ngx_radix_tree_t基数树的原理228<br>7.6.2　基数树的使用方法230<br>7.6.3　使用基数树的例子231<br>7.7　支持通配符的散列表232<br>7.7.1　ngx_hash_t基本散列表232<br>7.7.2　支持通配符的散列表235<br>7.7.3　带通配符散列表的使用例子241<br>7.8　小结245<br>第三部分　深入Nginx<br>第8章　Nginx基础架构248<br>8.1　Web服务器设计中的关键约束249<br>8.2　Nginx的架构设计251<br>8.2.1　优秀的模块化设计251<br>8.2.2　事件驱动架构254<br>8.2.3　请求的多阶段异步处理256<br>8.2.4　管理进程、多工作进程设计259<br>8.2.5　平台无关的代码实现259<br>8.2.6　内存池的设计259<br>8.2.7　使用统一管道过滤器模式的HTTP过滤模块260<br>8.2.8　其他一些用户模块260<br>8.3　Nginx框架中的核心结构体ngx_cycle_t260<br>8.3.1　ngx_listening_t结构体261<br>8.3.2　ngx_cycle_t结构体262<br>8.3.3　ngx_cycle_t支持的方法264<br>8.4　Nginx启动时框架的处理流程266<br>8.5　worker进程是如何工作的269<br>8.6　master进程是如何工作的271<br>8.7　ngx_pool_t内存池276<br>8.8　小结284<br>第9章　事件模块285<br>9.1　事件处理框架概述286<br>9.2　Nginx事件的定义288<br>9.3　Nginx连接的定义291<br>9.3.1　被动连接292<br>9.3.2　主动连接295<br>9.3.3　ngx_connection_t连接池296<br>9.4　ngx_events_module核心模块297<br>9.4.1　如何管理所有事件模块的配置项299<br>9.4.2　管理事件模块300<br>9.5　ngx_event_core_module事件模块302<br>9.6　epoll事件驱动模块308<br>9.6.1　epoll的原理和用法308<br>9.6.2　如何使用epoll310<br>9.6.3　ngx_epoll_module模块的实现312<br>9.7　定时器事件320<br>9.7.1　缓存时间的管理320<br>9.7.2　缓存时间的精度323<br>9.7.3　定时器的实现323<br>9.8　事件驱动框架的处理流程324<br>9.8.1　如何建立新连接325<br>9.8.2　如何解决“惊群”问题327<br>9.8.3　如何实现负载均衡329<br>9.8.4　post事件队列330<br>9.8.5　ngx_process_events_and_timers流程331<br>9.9　文件的异步I&#x2F;O334<br>9.9.1　Linux内核提供的文件异步I&#x2F;O335<br>9.9.2　ngx_epoll_module模块中实现的针对文件的异步I&#x2F;O337<br>9.10　TCP协议与Nginx342<br>9.11　小结347<br>第10章　HTTP框架的初始化348<br>10.1　HTTP框架概述349<br>10.2　管理HTTP模块的配置项352<br>10.2.1　管理main级别下的配置项353<br>10.2.2　管理server级别下的配置项355<br>10.2.3　管理location级别下的配置项358<br>10.2.4　不同级别配置项的合并364<br>10.3　监听端口的管理367<br>10.4　server的快速检索370<br>10.5　location的快速检索370<br>10.6　HTTP请求的11个处理阶段372<br>10.6.1　HTTP处理阶段的普适规则374<br>10.6.2　NGX_HTTP_POST_READ_PHASE阶段375<br>10.6.3　NGX_HTTP_SERVER_REWRITE_PHASE阶段378<br>10.6.4　NGX_HTTP_FIND_CONFIG_PHASE阶段378<br>10.6.5　NGX_HTTP_REWRITE_PHASE阶段378<br>10.6.6　NGX_HTTP_POST_REWRITE_PHASE阶段379<br>10.6.7　NGX_HTTP_PREACCESS_PHASE阶段379<br>10.6.8　NGX_HTTP_ACCESS_PHASE阶段379<br>10.6.9　NGX_HTTP_POST_ACCESS_PHASE阶段380<br>10.6.10　NGX_HTTP_TRY_FILES_PHASE阶段380<br>10.6.11　NGX_HTTP_CONTENT_PHASE阶段380<br>10.6.12　NGX_HTTP_LOG_PHASE阶段382<br>10.7　HTTP框架的初始化流程382<br>10.8　小结384<br>第11章　HTTP框架的执行流程385<br>11.1　HTTP框架执行流程概述386<br>11.2　新连接建立时的行为387<br>11.3　第一次可读事件的处理388<br>11.4　接收HTTP请求行394<br>11.5　接收HTTP头部398<br>11.6　处理HTTP请求400<br>11.6.1　ngx_http_core_generic_phase406<br>11.6.2　ngx_http_core_rewrite_phase408<br>11.6.3　ngx_http_core_access_phase409<br>11.6.4　ngx_http_core_content_phase412<br>11.7　subrequest与post请求415<br>11.8　处理HTTP包体417<br>11.8.1　接收包体419<br>11.8.2　放弃接收包体425<br>11.9　发送HTTP响应429<br>11.9.1　ngx_http_send_header430<br>11.9.2　ngx_http_output_filter432<br>11.9.3　ngx_http_writer435<br>11.10　结束HTTP请求437<br>11.10.1　ngx_http_close_connection438<br>11.10.2　ngx_http_free_request439<br>11.10.3　ngx_http_close_request440<br>11.10.4　ngx_http_finalize_connection441<br>11.10.5　ngx_http_terminate_request443<br>11.10.6　ngx_http_finalize_request443<br>11.11　小结446<br>第12章　upstream机制的设计与实现447<br>12.1　upstream机制概述448<br>12.1.1　设计目的448<br>12.1.2　ngx_http_upstream_t数据结构的意义450<br>12.1.3　ngx_http_upstream_conf_t配置结构体453<br>12.2　启动upstream455<br>12.3　与上游服务器建立连接457<br>12.4　发送请求到上游服务器460<br>12.5　接收上游服务器的响应头部463<br>12.5.1　应用层协议的两段划分方式463<br>12.5.2　处理包体的3种方式464<br>12.5.3　接收响应头部的流程465<br>12.6　不转发响应时的处理流程469<br>12.6.1　input_filter方法的设计469<br>12.6.2　默认的input_filter方法470<br>12.6.3　接收包体的流程472<br>12.7　以下游网速优先来转发响应473<br>12.7.1　转发响应的包头474<br>12.7.2　转发响应的包体477<br>12.8　以上游网速优先来转发响应481<br>12.8.1　ngx_event_pipe_t结构体的意义481<br>12.8.2　转发响应的包头485<br>12.8.3　转发响应的包体487<br>12.8.4　ngx_event_pipe_read_upstream方法489<br>12.8.5　ngx_event_pipe_write_to_downstream方法494<br>12.9　结束upstream请求496<br>12.10　小结499<br>第13章　邮件代理模块500<br>13.1　邮件代理服务器的功能500<br>13.2　邮件模块的处理框架503<br>13.2.1　一个请求的8个独立处理阶段503<br>13.2.2　邮件类模块的定义504<br>13.2.3　邮件框架的初始化506<br>13.3　初始化请求506<br>13.3.1　描述邮件请求的ngx_mail_session_t结构体506<br>13.3.2　初始化邮件请求的流程509<br>13.4　接收并解析客户端请求509<br>13.5　邮件认证510<br>13.5.1　ngx_mail_auth_http_ctx_t结构体510<br>13.5.2　与认证服务器建立连接511<br>13.5.3　发送请求到认证服务器513<br>13.5.4　接收并解析响应514<br>13.6　与上游邮件服务器间的认证交互514<br>13.6.1　ngx_mail_proxy_ctx_t结构体516<br>13.6.2　向上游邮件服务器发起连接516<br>13.6.3　与邮件服务器认证交互的过程518<br>13.7　透传上游邮件服务器与客户端间的流520<br>13.8　小结524<br>第14章　进程间的通信机制525<br>14.1　概述525<br>14.2　共享内存526<br>14.3　原子操作530<br>14.3.1　不支持原子库下的原子操作530<br>14.3.2　x86架构下的原子操作531<br>14.3.3　自旋锁533<br>14.4　Nginx频道535<br>14.5　信号538<br>14.6　信号量540<br>14.7　文件锁541<br>14.8　互斥锁544<br>14.8.1　文件锁实现的ngx_shmtx_t锁546<br>14.8.2　原子变量实现的ngx_shmtx_t锁548<br>14.9　小结553<br>第15章　变量554<br>15.1　使用内部变量开发模块555<br>15.1.1　定义模块556<br>15.1.2　定义http模块加载方式557<br>15.1.3　解析配置中的变量558<br>15.1.4　处理请求560<br>15.2　内部变量工作原理561<br>15.2.1　何时定义变量561<br>15.2.2　相关数据结构详述564<br>15.2.3　定义变量的方法572<br>15.2.4　使用变量的方法572<br>15.2.5　如何解析变量573<br>15.3　定义内部变量576<br>15.4　外部变量与脚本引擎577<br>15.4.1　相关数据结构578<br>15.4.2　编译“set”脚本581<br>15.4.3　脚本执行流程586<br>15.5　小结589<br>第16章　slab共享内存590<br>16.1　操作slab共享内存的方法590<br>16.2　使用slab共享内存池的例子592<br>16.2.1　共享内存中的数据结构593<br>16.2.2　操作共享内存中的红黑树与链表595<br>16.2.3　解析配置文件600<br>16.2.4　定义模块603<br>16.3　slab内存管理的实现原理605<br>16.3.1　内存结构布局607<br>16.3.2　分配内存流程613<br>16.3.3　释放内存流程617<br>16.3.4　如何使用位操作619<br>16.3.5　slab内存池间的管理624<br>16.4　小结624</p><h3 id="深入理解Nginx（第2版）-PDF-下载地址"><a href="#深入理解Nginx（第2版）-PDF-下载地址" class="headerlink" title="深入理解Nginx（第2版） PDF 下载地址:"></a>深入理解Nginx（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/159c8gslfQfbKwUM0wFB53A?pwd=v3ae">https://pan.baidu.com/s/159c8gslfQfbKwUM0wFB53A?pwd=v3ae</a> </p><p>提取码：v3ae</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go专家编程》</title>
      <link href="/2023/05/24/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/24/Go%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/f5a7e4251c9b195aa57acd6e4af9332c.png" alt="《Go专家编程》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。</p><p>本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C&#x2F;C++、Python、Swift等语言均有深入的研究与实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　常见数据结构的实现原理<br>1.1　管道<br>1.1.1　热身测验<br>1.1.2　特性速览<br>1.1.3　实现原理<br>1.2　slice<br>1.2.1　热身测验<br>1.2.2　特性速览<br>1.2.3　实现原理<br>1.2.4　切片表达式<br>1.3　map<br>1.3.1　热身测验<br>1.3.2　特性速览<br>1.3.3　实现原理<br>1.4　struct<br>1.4.1　热身测验<br>1.4.2　内嵌字段<br>1.4.3　方法受体<br>1.4.4　字段标签<br>1.5　iota<br>1.5.1　热身测验<br>1.5.2　特性速览<br>1.5.3　实现原理<br>1.6　string<br>1.6.1　热身测验<br>1.6.2　特性速览<br>1.6.3　实现原理<br>第2章　控制结构<br>2.1　select<br>2.1.1　热身测验<br>2.1.2　特性速览<br>2.1.3　实现原理<br>2.2　for-range<br>2.2.1　热身测验<br>2.2.2　特性速览<br>2.2.3　实现原理<br>第3章　协程<br>3.1　协程的概念<br>3.2　调度模型<br>3.3　调度策略<br>第4章　内存管理<br>4.1　内存分配<br>4.2　垃圾回收<br>4.3　逃逸分析<br>第5章　并发控制<br>5.1　channel<br>5.2　WaitGroup<br>5.3　context<br>5.4　Mutex<br>5.5　RWMutex<br>5.5.1　读写锁的数据结构<br>5.5.2　场景分析<br>第6章　反射<br>6.1　热身测验<br>6.2　接口<br>6.3　反射定律<br>第7章　测试<br>7.1　快速开始<br>7.1.1　单元测试<br>7.1.2　基准测试<br>7.1.3　示例测试<br>7.2　进阶测试<br>7.2.1　子测试<br>7.2.2　Main测试<br>7.3　实现原理<br>7.3.1　testing.common<br>7.3.2　testing.TB接口<br>7.3.3　单元测试的实现原理<br>7.3.4　性能测试的实现原理<br>7.3.5　示例测试的实现原理<br>7.3.6　Main测试的实现原理<br>7.3.7　gotest的工作机制<br>7.4　扩展阅读<br>7.4.1　测试参数<br>7.4.2　benchstat<br>第8章　异常处理<br>8.1　error<br>8.1.1　热身测验<br>8.1.2　基础error<br>8.1.3　链式error<br>8.1.4　工程迁移<br>8.2　defer<br>8.2.1　热身测验<br>8.2.2　约法三章<br>8.2.3　实现原理<br>8.2.4　性能优化<br>8.3　panic<br>8.3.1　热身测验<br>8.3.2　工作机制<br>8.3.3　源码剖析<br>8.4　recover<br>8.4.1　热身测验<br>8.4.2　工作机制<br>8.4.3　源码剖析<br>第9章　定时器<br>9.1　一次性定时器（Timer）<br>9.1.1　快速开始<br>9.1.2　实现原理<br>9.2　周期性定时器（Ticker）<br>9.2.1　快速开始<br>9.2.2　实现原理<br>9.3　runtimeTimer<br>9.3.1　实现原理<br>9.3.2　性能优化<br>9.4　案例分享<br>第10章　语法糖<br>10.1　简短变量声明符<br>10.1.1　热身测验<br>10.1.2　规则<br>10.2　可变参函数<br>第11章　版本管理<br>11.1　安装Go<br>11.2　删除Go<br>11.3　升级Go<br>11.4　Go版本管理器<br>11.4.1　快速开始<br>11.4.2　工作机制<br>11.4.3　小结<br>11.5　源码编译<br>11.5.1　源码下载<br>11.5.2　源码编译过程<br>第12章　Go语言依赖管理<br>12.1　GOPATH<br>12.1.1　GOROOT是什么<br>12.1.2　GOPATH是什么<br>12.1.3　依赖查找<br>12.1.4　GOPATH的缺点<br>12.2　vendor<br>12.2.1　vendor目录位置<br>12.2.2　搜索顺序<br>12.2.3　vendor的不足<br>12.3　GoModule<br>12.3.1　GoModule基础<br>12.3.2　快速实践<br>12.3.3　replace指令<br>12.3.4　exclude指令<br>12.3.5　indirect指令<br>12.3.6　版本选择机制<br>12.3.7　incompatible<br>12.3.8　伪版本<br>12.3.9　依赖包存储<br>12.3.10　go.sum<br>12.3.11　模块代理<br>12.3.12　GOSUMDB的工作机制<br>12.3.13　GOSUMDB的实现原理<br>12.3.14　第三方代理<br>12.3.15　私有模块<br>12.3.16　GoModule的演进<br>第13章　编程陷阱<br>13.1　切片扩容<br>13.2　空切片<br>13.3　append的本质<br>13.4　循环变量引用<br>13.5　协程引用循环变量<br>13.6　recover失效</p><h3 id="Go专家编程-PDF-下载地址"><a href="#Go专家编程-PDF-下载地址" class="headerlink" title="Go专家编程 PDF 下载地址:"></a>Go专家编程 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1lahji8e6Uu3wN-ncnQio9w?pwd=477g">https://pan.baidu.com/s/1lahji8e6Uu3wN-ncnQio9w?pwd=477g</a> </p><p>提取码: 477g </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Go语言编程 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go并发编程实战（第2版）》</title>
      <link href="/2023/05/24/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
      <url>/2023/05/24/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/fe6fe0ca4452413f25f54d4132c79620.png" alt="《Go并发编程实战（第2版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书首先介绍了Go语言的优秀特性、安装设置方法、工程结构、标准命令和工具、语法基础、数据类型以及流程控制方法，接着阐述了与多进程编程和多线程编程有关的知识，然后重点介绍了goroutine、channel以及Go提供的传统同步方法，最后通过一个完整实例——网络爬虫框架进一步阐述Go语言的哲学和理念，同时分享作者在多年编程生涯中的一些见解和感悟。</p><p>与上一版相比，本书不仅基于Go 1.8对上一版进行了全面更新，而且更深入地描绘了Go运行时系统的内部机理，并且大幅改进了示例代码。</p><p>本书适用于有一定计算机编程基础的从业者以及对Go语言编程感兴趣的爱好者，非常适合作为Go语言编程进阶教程。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝林 从业12年有余的软件工匠，国内知名的Go语言技术布道者，Go语言北京用户组和GoHackers社群的发起人和组织者，多套免费在线Go语言教程的作者，深信Go语言在人工智能时代和机器人时代也能大放异彩的科技信徒。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　初识Go语言　　1<br>1.1　语言特性　　1<br>1.2　安装和设置　　2<br>1.3　工程结构　　3<br>1.3.1　工作区　　3<br>1.3.2　GOPATH　　4<br>1.3.3　源码文件　　5<br>1.3.4　代码包　　8<br>1.4　标准命令简述　　11<br>1.5　问候程序　　13<br>1.6　小结　　14<br>第2章　语法概览　　15<br>2.1　基本构成要素　　15<br>2.1.1　标识符　　15<br>2.1.2　关键字　　16<br>2.1.3　字面量　　17<br>2.1.4　操作符　　17<br>2.1.5　表达式　　19<br>2.2　基本类型　　20<br>2.3　高级类型　　22<br>2.3.1　数组　　23<br>2.3.2　切片　　23<br>2.3.3　字典　　24<br>2.3.4　函数和方法　　25<br>2.3.5　接口　　28<br>2.3.6　结构体　　29<br>2.4　流程控制　　30<br>2.4.1　代码块和作用域　　30<br>2.4.2　if语句　　32<br>2.4.3　switch语句　　32<br>2.4.4　for语句　　34<br>2.4.5　defer语句　　36<br>2.4.6　panic和recover　　38<br>2.5　聊天机器人　　40<br>2.6　小结　　44<br>第3章　并发编程综述　　45<br>3.1　并发编程基础　　45<br>3.1.1　串行程序与并发程序　　46<br>3.1.2　并发程序与并行程序　　46<br>3.1.3　并发程序与并发系统　　47<br>3.1.4　并发程序的不确定性　　47<br>3.1.5　并发程序内部的交互　　47<br>3.2　多进程编程　　48<br>3.2.1　进程　　48<br>3.2.2　关于同步　　55<br>3.2.3　管道　　60<br>3.2.4　信号　　65<br>3.2.5　socket　　74<br>3.3　多线程编程　　97<br>3.3.1　线程　　98<br>3.3.2　线程的同步　　107<br>3.4　多线程与多进程　　125<br>3.5　多核时代的并发编程　　126<br>3.6　小结　　130<br>第4章　Go的并发机制　　131<br>4.1　原理探究　　131<br>4.1.1　线程实现模型　　132<br>4.1.2　调度器　　142<br>4.1.3　更多细节　　158<br>4.2　goroutine　　160<br>4.2.1　go语句与goroutine　　160<br>4.2.2　主goroutine的运作　　166<br>4.2.3　runtime包与goroutine　　166<br>4.3　channel　　169<br>4.3.1　channel的基本概念　　169<br>4.3.2　单向channel　　180<br>4.3.3　for语句与channel　　184<br>4.3.4　select语句　　185<br>4.3.5　非缓冲的channel　　190<br>4.3.6　time包与channel　　192<br>4.4　实战演练：载荷发生器　　198<br>4.4.1　参数和结果　　199<br>4.4.2　基本结构　　201<br>4.4.3　初始化　　206<br>4.4.4　启动和停止　　212<br>4.4.5　调用器和功能测试　　221<br>4.5　小结　　231<br>第5章　同　　步　　232<br>5.1　锁的使用　　232<br>5.1.1　互斥锁　　232<br>5.1.2　读写锁　　236<br>5.1.3　锁的完整示例　　238<br>5.2　条件变量　　244<br>5.3　原子操作　　247<br>5.3.1　增或减　　247<br>5.3.2　比较并交换　　249<br>5.3.3　载入　　250<br>5.3.4　存储　　251<br>5.3.5　交换　　251<br>5.3.6　原子值　　252<br>5.3.7　应用于实际　　256<br>5.4　只会执行一次　　257<br>5.5　WaitGroup　　258<br>5.6　临时对象池　　262<br>5.7　实战演练——ConcurrentMap　　265<br>5.8　小结　　280<br>第6章　网络爬虫框架设计和实现　　281<br>6.1　网络爬虫与框架　　281<br>6.2　功能需求和分析　　283<br>6.3　总体设计　　284<br>6.4　详细设计　　286<br>6.4.1　基本数据结构　　286<br>6.4.2　接口的设计　　293<br>6.5　工具的实现　　309<br>6.5.1　缓冲器　　309<br>6.5.2　缓冲池　　311<br>6.5.3　多重读取器　　317<br>6.6　组件的实现　　318<br>6.6.1　内部基础接口　　319<br>6.6.2　组件注册器　　321<br>6.6.3　下载器　　323<br>6.6.4　分析器　　325<br>6.6.5　条目处理管道　　328<br>6.7　调度器的实现　　329<br>6.7.1　基本结构　　329<br>6.7.2　初始化　　331<br>6.7.3　启动　　333<br>6.7.4　停止　　343<br>6.7.5　其他方法　　344<br>6.7.6　总结　　345<br>6.8　一个简单的图片爬虫　　346<br>6.8.1　概述　　346<br>6.8.2　命令参数　　346<br>6.8.3　初始化调度器　　348<br>6.8.4　监控调度器　　354<br>6.8.5　启动调度器　　364<br>6.9　扩展与思路　　365<br>6.10　本章小结　　368<br>附录A　Go语言的学习资源　　369</p><h3 id="Go并发编程实战（第2版）-PDF-下载地址"><a href="#Go并发编程实战（第2版）-PDF-下载地址" class="headerlink" title="Go并发编程实战（第2版） PDF 下载地址:"></a>Go并发编程实战（第2版） PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1FZjrtblTQGRnZDPxGo0WVg?pwd=7oo9">https://pan.baidu.com/s/1FZjrtblTQGRnZDPxGo0WVg?pwd=7oo9</a> </p><p>提取码：7oo9</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦    </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《DevOps实践指南》</title>
      <link href="/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/c9c87291194e8042c6dd80f9f4756516.png" alt="《DevOps实践指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书共分为6个部分：第一部分概述DevOps的历史和三个基本原则，即“三步工作法”；第二部分介绍开启DevOps转型的过程；第三到五部分深入探讨“三步工作法”的各个要素；第六部分关注如何将安全性和合规性正确集成到日常工作中。全书涵盖40余个DevOps案例，以谷歌、亚马逊、Facebook等全球知名企业和组织的实际调查结果为依据，展示如何通过现代化的运维管理提升管理效率，进而为企业赢得更大市场、创造更多利润。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Gene Kim</p><p>Tripwire创始人、前CTO，IT Revolution创始人，DevOps企业峰会主办人，畅销书《凤凰项目》合著者。</p><p>Jez Humble</p><p>DevOps Research and Assessment公司CTO，加州大学伯克利分校信息学院讲师；曾任ThoughtWorks首席顾问。《精益企业》和Jolt大奖图书《持续交付》的合著者。</p><p>Patrick Debois</p><p>DevOps之父，致力于通过在开发、项目管理和系统管理之中应用敏捷技术来填补项目和运维之间的鸿沟。</p><p>John Willis</p><p>Chain Bridge System创始人，曾任Docker公司布道师，现就职于SJ Technologies公司。</p><p>译者简介：</p><p>刘征</p><p>Nutanix路坦力资深架构师，EXIN首批国内DevOps Master和DevOps Professional认证讲师，持有红帽RHCA认证和AWS高级架构师认证，谙熟企业数据中心的IT服务管理。目前致力于推广DevOps相关的理念和实践，在DevOps社区中积极地参与培训和研讨会等活动，是DevOpsDays大会社区在中国的核心组织者和志愿工作者。</p><p>王磊</p><p>前ThoughtWorks咨询师，EXIN首批国内DevOps Master认证讲师。拥有10多年软件行业经验，以及服务化架构、持续交付和DevOps转型等方面的丰富实践经验。国内较早倡导和实践微服务的先行者，著有国内首本微服务架构相关图书《微服务架构与实践》，是西安DevOps Meetup活动的联合发起人。</p><p>马博文</p><p>前ThoughtWorks咨询师，AWS认证助理架构师、开发者。拥有多年Web开发和DevOps经验，熟悉持续交付、微服务。曾参与翻译《Scala编程实战》《DevOps实践》等书，是西安DevOps Meetup活动的发起人。</p><p>曾朝京</p><p>Micro Focus资深解决方案顾问，曾参加EXIN首批国内Devops Master讲师认证培训。长期从事IT运维管理领域咨询工作，曾为能源、金融、航空运输、政府行业中的多个大型企业提供IT运维管理规划。目前致力于探索DevOps理念在企业IT部门的实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　DevOps介绍<br>第1章　敏捷、持续交付和三步法　　4<br>1.1　制造业价值流　　4<br>1.2　技术价值流　　4<br>1.2.1　聚焦于部署前置时间　　5<br>1.2.2　关注返工指标——%C&#x2F;A　　7<br>1.3　三步工作法：DevOps的基础原则　　7<br>1.4　小结　　8<br>第2章　第一步：流动原则　　9<br>2.1　使工作可见　　9<br>2.2　限制在制品数　　10<br>2.3　减小批量大小　　11<br>2.4　减少交接次数　　13<br>2.5　持续识别和改善约束点　　14<br>2.6　消除价值流中的困境和浪费　　15<br>2.7　小结　　16<br>第3章　第二步：反馈原则　　17<br>3.1　在复杂系统中安全地工作　　17<br>3.2　及时发现问题　　18<br>3.3　群策群力，战胜问题获取新知　　19<br>3.4　在源头保障质量　　21<br>3.5　为下游工作中心而优化　　22<br>3.6　小结　　22<br>第4章　第三步：持续学习与实验原则　　23<br>4.1　建立学习型组织和安全文化　　23<br>4.2　将日常工作的改进制度化　　25<br>4.3　把局部发现转化为全局优化　　26<br>4.4　在日常工作中注入弹性模式　　27<br>4.5　领导层强化学习文化　　27<br>4.6　小结　　29<br>4.7　第一部分总结　　29<br>第二部分　从何处开始<br>第5章　选择合适的价值流作为切入点　　32<br>5.1　绿地项目与棕地项目　　34<br>5.2　兼顾记录型系统和交互型系统　　35<br>5.3　从最乐于创新的团队开始　　36<br>5.4　扩大DevOps的范围　　37<br>5.5　小结　　38<br>第6章　理解、可视化和运用价值流　　39<br>6.1　确定创造客户价值所需的团队　　40<br>6.2　针对团队工作绘制价值流图　　40<br>6.3　组建专门的转型团队　　42<br>6.3.1　拥有共同的目标　　43<br>6.3.2　保持小跨度的改进计划　　44<br>6.3.3　为非功能性需求预留20%的<br>开发时间，减少技术债务　　44<br>6.3.4　提高工作的可视化程度　　47<br>6.4　用工具强化预期行为　　47<br>6.5　小结　　48<br>第7章　参考康威定律设计组织结构　　49<br>7.1　组织原型　　51<br>7.2　过度职能导向的危害（“成本优化”）　　51<br>7.3　组建以市场为导向的团队（“速度优化”）　　52<br>7.4　使职能导向有效　　53<br>7.5　将测试、运维和信息安全融入日常工作　　54<br>7.6　使团队成员都成为通才　　54<br>7.7　投资于服务和产品，而非项目　　56<br>7.8　根据康威定律设定团队边界　　56<br>7.9　创建松耦合架构，提高生产力和安全性　　57<br>7.10　小结　　60<br>第8章　将运维融入日常开发工作　　61<br>8.1　创建共享服务，提高开发生产力　　62<br>8.2　将运维工程师融入服务团队　　63<br>8.3　为每个服务团队分派运维联络人　　64<br>8.4　邀请运维工程师参加开发团队的会议　　65<br>8.4.1　邀请运维工程师参加每日站会　　65<br>8.4.2　邀请运维工程师参加回顾会议　　66<br>8.4.3　使用看板图展示运维工作　　66<br>8.5　小结　　67<br>8.6　第二部分总结　　67<br>第三部分　第一步：流动的技术实践<br>第9章　为部署流水线奠定基础　　70<br>9.1　按需搭建开发环境、测试环境和生产环境　　71<br>9.2　应用统一的代码仓库　　72<br>9.3　使基础设施的重建更容易　　74<br>9.4　运行在类生产环境里才算“完成”　　75<br>9.5　小结　　76<br>第10章　实现快速可靠的自动化测试　　77<br>10.1　对代码和环境做持续构建、测试和集成　　79<br>10.2　构建快速可靠的自动化测试套件　　81<br>10.2.1　在自动化测试中尽早发现<br>错误　　83<br>10.2.2　尽可能并行地快速执行测试　　84<br>10.2.3　先编写自动化测试　　84<br>10.2.4　尽量将手动测试自动化　　85<br>10.2.5　在测试套件中集成性能测试　　86<br>10.2.6　在测试套件中集成非功能性需求测试　　86<br>10.3　在部署流水线失败时拉下安灯绳　　87<br>10.4　小结　　89<br>第11章　应用和实践持续集成　　90<br>11.1　小批量开发与大批量合并　　92<br>11.2　应用基于主干的开发实践　　93<br>11.3　小结　　95<br>第12章　自动化和低风险发布　　96<br>12.1　自动化部署流程　　97<br>12.1.1　应用自动化的自助式部署　　100<br>12.1.2　在部署流水线中集成代码部署　　101<br>12.2　将部署与发布解耦　　104<br>12.2.1　基于环境的发布模式　　105<br>12.2.2　基于应用的发布模式更安全　　109<br>12.3　持续交付和持续部署实践的调查　　112<br>12.4　小结　　113<br>第13章　降低发布风险的架构　　114<br>13.1　能提高生产力、可测试性和安全性的架构　　115<br>13.2　架构原型：单体架构与微服务　　116<br>13.3　安全地演进企业架构　　118<br>13.4　小结　　121<br>13.5　第三部分总结　　121<br>第四部分　第二步：反馈的技术实践<br>第14章　建立能发现并解决问题的遥测系统　　125<br>14.1　建设集中式监控架构　　127<br>14.2　建立生产环境的应用程序日志遥测　　129<br>14.3　使用遥测指导问题的解决　　131<br>14.4　将建立生产遥测融入日常工作　　132<br>14.5　建立自助访问的遥测和信息辐射器　　133<br>14.6　发现和填补遥测的盲区　　135<br>14.6.1　应用程序和业务度量指标　　136<br>14.6.2　基础架构度量指标　　137<br>14.6.3　显示叠加的指标组合　　138<br>14.7　小结　　139<br>第15章　分析遥测数据以更好地预测故障和实现目标　　140<br>15.1　用均值和标准差识别潜在问题　　141<br>15.2　异常状态的处理和告警　　142<br>15.3　非高斯分布遥测数据的问题　　143<br>15.4　应用异常检测技术　　146<br>15.5　小结　　149<br>第16章　应用反馈实现安全部署　　150<br>16.1　通过遥测使部署更安全　　151<br>16.2　开发和运维共同承担值班工作　　153<br>16.3　让开发人员跟踪工作对下游的影响　　153<br>16.4　让开发人员自行管理生产服务　　155<br>16.5　小结　　159<br>第17章　将假设驱动的开发和A&#x2F;B测试融入日常工作　　160<br>17.1　A&#x2F;B测试简史　　161<br>17.2　在功能测试中集成A&#x2F;B测试　　162<br>17.3　在发布中集成A&#x2F;B测试　　162<br>17.4　在功能规划中集成A&#x2F;B测试　　163<br>17.5　小结　　165<br>第18章　建立评审和协作流程以提升当前工作的质量　　166<br>18.1　变更审批流程的危险　　168<br>18.2 “过度控制变更”的潜在危险　　168<br>18.3　变更的协调和排程　　170<br>18.4　变更的同行评审　　170<br>18.5　人工测试和变更冻结的潜在危害　　173<br>18.6　利用结对编程改进代码变更　　173<br>18.7　消除官僚流程　　176<br>18.8　小结　　177<br>18.9　第四部分总结　　178<br>第五部分　第三步：持续学习与实验的技术实践<br>第19章　将学习融入日常工作　　180<br>19.1　建立公正和学习的文化　　181<br>19.2　举行不指责的事后分析会议　　182<br>19.3　尽可能广泛地公开事后分析会议结果　　184<br>19.4　降低事故容忍度，寻找更弱的故障信号　　185<br>19.5　重新定义失败，鼓励评估风险　　186<br>19.6　在生产环境注入故障来恢复和学习　　186<br>19.7　创建故障演练日　　187<br>19.8　小结　　189<br>第20章　将局部经验转化为全局改进　　190<br>20.1　使用聊天室和聊天机器人自动积累组织知识　　190<br>20.2　软件中便于重用的自动化、标准化流程　　192<br>20.3　创建全组织共享的单一源代码库　　192<br>20.4　运用自动化测试记录和交流实践来传播知识　　194<br>20.5　通过确定非功能性需求来设计运维　　194<br>20.6　把可重用的运维用户故事纳入开发　　195<br>20.7　确保技术选型有助于实现组织目标　　195<br>20.8　小结　　197<br>第21章　预留组织学习和改进的时间　　198<br>21.1　偿还技术债务的制度化惯例　　199<br>21.2　让所有人教学相长　　200<br>21.3　在DevOps会议中分享经验　　201<br>21.4　传播实践的内部顾问和教练　　203<br>21.5　小结　　204<br>21.6　第五部分总结　　204<br>第六部分　集成信息安全、变更管理和合规性的技术实践<br>第22章　将信息安全融入每个人的日常工作　　207<br>22.1　将安全集成到开发迭代的演示中　　207<br>22.2　将安全集成到缺陷跟踪和事后分析会议中　　208<br>22.3　将预防性安全控制集成到共享源代码库及共享服务中　　208<br>22.4　将安全集成到部署流水线中　　209<br>22.5　保证应用程序的安全性　　210<br>22.6　确保软件供应链的安全　　214<br>22.7　确保环境的安全　　215<br>22.8　将信息安全集成到生产环境遥测中　　216<br>22.9　在应用程序中建立安全遥测系统　　217<br>22.10　在环境中建立安全遥测系统　　217<br>22.11　保护部署流水线　　219<br>22.12　小结　　219<br>第23章　保护部署流水线　　220<br>23.1　将安全和合规性集成到变更批准流程中　　220<br>23.2　将大量低风险变更重新归类为标准变更　　221<br>23.3　如何处理常规变更　　222<br>23.4　减少对职责分离的依赖　　224<br>23.5　确保为审计人员和合规人员留存文档和证据　　226<br>23.6　小结　　228<br>23.7　第六部分总结　　228行动起来——本书总结　　229<br>附加材料<br>附　　录　　232<br>附录1　DevOps的大融合　　232<br>附录2　约束理论和核心的长期<br>冲突　　234<br>附录3　恶性循环列表　　235<br>附录4　交接和队列的危害　　235<br>附录5　工业安全神话　　236<br>附录6　丰田安灯绳　　237<br>附录7　软件包产品　　238<br>附录8　事后分析会议　　238<br>附录9　猿猴军团　　239<br>附录10　上线时间透明化　　240<br>参考资源　　241<br>致　　谢　　243<br>EXIN DevOps Professional认证备考<br>指南 &amp; 模拟题①　　245</p><h3 id="DevOps实践指南-PDF-下载"><a href="#DevOps实践指南-PDF-下载" class="headerlink" title="DevOps实践指南 PDF 下载"></a>DevOps实践指南 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1RthGEPUoyj5VcUMwZIKapg?pwd=dw2y">https://pan.baidu.com/s/1RthGEPUoyj5VcUMwZIKapg?pwd=dw2y</a> </p><p>提取码：dw2y</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript开发实战》</title>
      <link href="/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ece758c279279d142e46b17df4f21c5a.png" alt="《JavaScript开发实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript开发实战》是一本 JavaScript 开发入门指导书，主要介绍了变量、对象、函数、数组、构造函数、方括号运算符、作用域、条件语句、模块、模型、视图、控制器、构建网页、控件、模板、数据加载等内容。书中涉及的概念都附有简短示例。此外，还有一个贯穿全书的持续示例 — 冒险游戏 The Crypt。读者可以在一个交互式网站上直接运行书中的代码。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>作者约翰·拉尔森是一名有30多年经验的程序员，精通JavaScript，也是一位经验丰富的教师。因此他深知读者在学习新知识、新技能过程中的困难，知道如何调动读者的积极性，帮助他们克服困难，并且善于用简洁的语言解释计算机语言的难点。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 控制台上的核心概念<br>第 1 章 编程、JavaScript 和 JS Bin<br>1.1 编程<br>1.2 JavaScript<br>1.3 在实践和思考中学习<br>1.4 JS Bin<br>1.4.1 JS Bin 面板<br>1.4.2 在 JS Bin 上运行代码清单<br>1.4.3 输出到控制台<br>1.4.4 代码注释<br>1.4.5 Further Adventures——进阶练习<br>1.4.6 错误消息<br>1.4.7 行号<br>1.4.8 获取账户<br>1.5 游戏 The Crypt——本书的一个持续示例<br>1.5.1 运行 The Crypt<br>1.5.2 创建 The Crypt 的具体步骤<br>1.6 更多示例和练习<br>1.7 浏览器的兼容性<br>1.8 本章小结<br>第 2 章 变量：在程序中存储数据<br>2.1 什么是变量<br>2.2 变量的声明和赋值<br>2.2.1 变量声明<br>2.2.2 变量赋值<br>2.2.3 一步实现变量声明和赋值<br>2.2.4 先运算再赋值<br>2.3 选择合适的变量名<br>2.3.1 关键字和保留字<br>2.3.2 变量的命名规则<br>2.3.3 骆驼式命名法（camelCase）<br>2.3.4 使用描述性变量名<br>2.4 The Crypt——玩家变量<br>2.5 本章小结<br>第 3 章 对象：数据分组<br>3.1 变量需要分组<br>3.2 创建对象<br>3.2.1 创建一个空对象<br>3.2.2 属性“键?值对”<br>3.3 访问对象的属性<br>3.4 更新对象的属性<br>3.5 其他示例<br>3.5.1 撰写一条博客<br>3.5.2 创建一个日历<br>3.5.3 天气怎么样？<br>3.5.4 一个小测验<br>3.5.5 创建自己的程序<br>3.6 游戏 The Crypt——玩家对象<br>3.7 本章小结<br>第 4 章 函数：按需执行代码<br>4.1 重复问题<br>4.1.1 将对象的属性作为文本进行显示<br>4.1.2 加税算出总成本<br>4.2 定义函数和调用函数<br>4.2.1 定义新函数<br>4.2.2 函数表达式和函数声明<br>4.2.3 使用函数<br>4.2.4 使用函数的步骤<br>4.3 减少重复<br>4.3.1 函数可用于将对象的属性作为文本进行显示<br>4.3.2 加税并显示总成本的函数<br>4.4 使代码易于阅读和更新<br>4.4.1 更新 showMovieInfo 函数<br>4.5 游戏 The Crypt——显示玩家的信息<br>4.5.1 用函数显示玩家的信息<br>4.6 本章小结<br>第 5 章 参数：将数据传递给函数<br>5.1 函数重用<br>5.2 将信息传递给函数<br>5.2.1 将实参传递给函数<br>5.2.2 将多个实参传递给一个函数<br>5.3 The Crypt——显示玩家信息<br>5.3.1 显示玩家的姓名<br>5.3.2 显示玩家的健康值<br>5.3.3 显示玩家的位置<br>5.3.4 合并显示玩家的信息<br>5.4 本章小结<br>第 6 章 返回值：从函数获取数据<br>6.1 从函数返回数据<br>6.1.1 用返回值替代函数调用<br>6.1.2 关键字 return<br>6.1.3 使用参数来确定返回值<br>6.2 在控制台提示符下进行实验<br>6.2.1 调用函数<br>6.2.2 声明新的变量<br>6.3 The Crypt——构建玩家信息字符串<br>6.3.1 为玩家的姓名、健康值和位置构建字符串<br>6.3.2 用一个函数显示玩家的信息——把几个函数集合在一起<br>6.4 本章小结<br>第 7 章 对象参数：将对象传递给函数<br>7.1 使用对象作为参数<br>7.1.1 访问对象参数的属性<br>7.1.2 给对象参数添加属性<br>7.2 从函数返回对象<br>7.2.1 构建行星——对象创建函数<br>7.2.2 二维空间的点<br>7.3 方法——设置函数作为对象的属性<br>7.3.1 命名空间——将相关函数组织到一起<br>7.3.2 Math 方法<br>7.3.3 String 方法<br>7.3.4 spacer——将更多的方法收入命名空间<br>7.3.5 进一步探索命名空间<br>7.4 The Crypt——将玩家对象作为参数<br>7.5 本章小结<br>第 8 章 数组：将数据存入列表<br>8.1 创建数组并访问元素<br>8.1.1 创建数组<br>8.1.2 访问数组元素<br>8.2 数组方法<br>8.2.1 添加和删除元素<br>8.2.2 截取和拼接数组<br>8.2.3 使用 forEach 访问每一个元素<br>8.3 The Crypt——玩家的物品数组<br>8.4 本章小结<br>第 9 章 构造函数：构建带有函数的对象<br>9.1 使用函数构建对象<br>9.1.1 添加属性<br>9.1.2 添加方法<br>9.2 使用构造函数构建对象<br>9.2.1 构造函数<br>9.2.2 使用 Planet 构造函数创建一个新世界<br>9.2.3 使用 instanceof 运算符区分对象<br>9.3 建造大师——两个构造函数的示例<br>9.4 The Crypt——为玩家提供掠夺地<br>9.4.1 构建 Place 构造函数——名称标题和描述<br>9.4.2 构建 Place 构造函数——囤积物品<br>9.4.3 构建 Place 构造函数——探索出口<br>9.5 The Crypt——简化玩家创建代码<br>9.5.1 整理玩家属性<br>9.5.2 将函数转换为方法<br>9.5.3 为玩家分配位置<br>9.5.4 使用 null 作为对象的占位符<br>9.6 本章小结<br>第 10 章 方括号运算符：灵活的属性名称<br>10.1 用方括号运算符替代圆点运算符<br>10.1.1 使用方括号——人的姓名作为键<br>10.1.2 最大限度地利用方括号运算符——单词统计<br>10.2 The Crypt——使游戏出口更加刺激好玩<br>10.2.1 使用对象存放出口<br>10.2.2 创建一个添加并显示出口的函数<br>10.2.3 设置每个场所对象的出口集合<br>10.2.4 将 exits 对象添加到完整的 Place 构造函数<br>10.2.5 测试 Place 构造函数<br>10.3 The Crypt——开始游戏！<br>10.3.1 刷新显示——render<br>10.3.2 探索地图——go<br>10.3.3 收集物品——get<br>10.3.4 设计一个更大的冒险游戏——Jahver 的船<br>10.4 下一步目标<br>10.5 本章小结<br>第二部分 组 织 代 码<br>第 11 章 作用域：隐藏信息<br>11.1 全局变量的危险性<br>11.1.1 访问所有区域——偷窥和篡改<br>11.1.2 访问所有区域——借助于实现<br>11.1.3 命名冲突<br>11.1.4 难以查找的错误<br>11.2 局部变量的优势<br>11.3 接口——控制访问权限并提供可用功能<br>11.3.1 使用一个函数来隐藏变量<br>11.3.2 使用 getCount 创建多个独立计数器<br>11.3.3 用构造函数创建多个独立的计数器<br>11.4 创建一个简单的测验应用程序<br>11.4.1 将对象用作一个命名空间<br>11.4.2 隐藏问题数组<br>11.5 The Crypt——隐藏玩家信息<br>11.5.1 当前的 Player 构造函数——全部内容都公开<br>11.5.2 更新版的 Player 构造函数——某些变量被隐藏<br>11.6 The Crypt——隐藏地点信息<br>11.7 The Crypt——用户交互<br>11.7.1 接口——go 和 get<br>11.7.2 隐藏程序的实现<br>11.8 本章小结<br>第 12 章 条件：有选择地运行代码<br>12.1 有条件地执行代码<br>12.1.1 严格相等运算符<br>12.1.2 if 语句<br>12.1.3 else 子句<br>12.1.4 隐藏函数中的密码数字</p><h3 id="JavaScript开发实战-PDF-下载"><a href="#JavaScript开发实战-PDF-下载" class="headerlink" title="JavaScript开发实战 PDF 下载"></a>JavaScript开发实战 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1i_Cez12A3o5iZl7JfO6P_w?pwd=xisp">https://pan.baidu.com/s/1i_Cez12A3o5iZl7JfO6P_w?pwd=xisp</a> </p><p>提取码：xisp</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript高级程序设计（第4版）》</title>
      <link href="/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/"/>
      <url>/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/151a8998ee2c6caeba42f688e52f9f95.png" alt="《JavaScript高级程序设计（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。</p><p>本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Nicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是<a href="http://www.nczonline.net%EF%BC%8C%E4%BB%96%E7%9A%84Twitter%E5%88%AB%E5%90%8D%E6%98%AF@slicknet./">www.nczonline.net，他的Twitter别名是@slicknet。</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　JavaScript简介　　1<br>1.1　JavaScript简史　　1<br>1.2　JavaScript实现　　2<br>1.2.1　ECMAScript　　3<br>1.2.2　文档对象模型（DOM）　　5<br>1.2.3　浏览器对象模型（BOM）　　8<br>1.3　JavaScript版本　　8<br>1.4　小结　　9<br>第2章　在HTML中使用JavaScript　　10<br>2.1　&lt;\script&gt;元素　　10<br>2.1.1　标签的位置　　12<br>2.1.2　延迟脚本　　13<br>2.1.3　异步脚本　　13<br>2.1.4　在XHTML中的用法　　14<br>2.1.5　不推荐使用的语法　　16<br>2.2　嵌入代码与外部文件　　16<br>2.3　文档模式　　16<br>2.4　&lt;\noscript&gt;元素　　18<br>2.5　小结　　18<br>第3章　基本概念　　19<br>3.1　语法　　19<br>3.1.1　区分大小写　　19<br>3.1.2　标识符　　19<br>3.1.3　注释　　20<br>3.1.4　严格模式　　20<br>3.1.5　语句　　20<br>3.2　关键字和保留字　　21<br>3.3　变量　　22<br>3.4　数据类型　　23<br>3.4.1　typeof操作符　　23<br>3.4.2　Undefined类型　　24<br>3.4.3　Null类型　　25<br>3.4.4　Boolean类型　　26<br>3.4.5　Number类型　　27<br>3.4.6　String类型　　32<br>3.4.7　Object类型　　35<br>3.5　操作符　　36<br>3.5.1　一元操作符　　36<br>3.5.2　位操作符　　39<br>3.5.3　布尔操作符　　44<br>3.5.4　乘性操作符　　47<br>3.5.5　加性操作符　　48<br>3.5.6　关系操作符　　50<br>3.5.7　相等操作符　　51<br>3.5.8　条件操作符　　53<br>3.5.9　赋值操作符　　53<br>3.5.10　逗号操作符　　54<br>3.6　语句　　54<br>3.6.1　if语句　　54<br>3.6.2　do-while语句　　55<br>3.6.3　while语句　　55<br>3.6.4　for语句　　56<br>3.6.5　for-in语句　　57<br>3.6.6　label语句　　58<br>3.6.7　break和continue语句　　58<br>3.6.8　with语句　　60<br>3.6.9　switch语句　　60<br>3.7　函数　　62<br>3.7.1　理解参数　　64<br>3.7.2　没有重载　　66<br>3.8　小结　　67<br>第4章　变量、作用域和内存问题　　68<br>4.1　基本类型和引用类型的值　　68<br>4.1.1　动态的属性　　68<br>4.1.2　复制变量值　　69<br>4.1.3　传递参数　　70<br>4.1.4　检测类型　　72<br>4.2　执行环境及作用域　　73<br>4.2.1　延长作用域链　　75<br>4.2.2　没有块级作用域　　76<br>4.3　垃圾收集　　78<br>4.3.1　标记清除　　78<br>4.3.2　引用计数　　79<br>4.3.3　性能问题　　80<br>4.3.4　管理内存　　81<br>4.4　小结　　81<br>第5章　引用类型　　83<br>5.1　Object类型　　83<br>5.2　Array类型　　86<br>5.2.1　检测数组　　88<br>5.2.2　转换方法　　89<br>5.2.3　栈方法　　90<br>5.2.4　队列方法　　91<br>5.2.5　重排序方法　　92<br>5.2.6　操作方法　　94<br>5.2.7　位置方法　　95<br>5.2.8　迭代方法　　96<br>5.2.9　缩小方法　　97<br>5.3　Date类型　　98<br>5.3.1　继承的方法　　100<br>5.3.2　日期格式化方法　　101<br>5.3.3　日期&#x2F;时间组件方法　　102<br>5.4　RegExp类型　　103<br>5.4.1　RegExp实例属性　　105<br>5.4.2　RegExp实例方法　　106<br>5.4.3　RegExp构造函数属性　　107<br>5.4.4　模式的局限性　　109<br>5.5　Function类型　　110<br>5.5.1　没有重载（深入理解）　　111<br>5.5.2　函数声明与函数表达式　　111<br>5.5.3　作为值的函数　　112<br>5.5.4　函数内部属性　　113<br>5.5.5　函数属性和方法　　116<br>5.6　基本包装类型　　118<br>5.6.1　Boolean类型　　120<br>5.6.2　Number类型　　120<br>5.6.3　String类型　　122<br>5.7　单体内置对象　　130<br>5.7.1　Global对象　　131<br>5.7.2　Math对象　　134<br>5.8　小结　　137<br>第6章　面向对象的程序设计　　138<br>6.1　理解对象　　138<br>6.1.1　属性类型　　139<br>6.1.2　定义多个属性　　142<br>6.1.3　读取属性的特性　　143<br>6.2　创建对象　　144<br>6.2.1　工厂模式　　144<br>6.2.2　构造函数模式　　144<br>6.2.3　原型模式　　147<br>6.2.4　组合使用构造函数模式和原型模式　　159<br>6.2.5　动态原型模式　　159<br>6.2.6　寄生构造函数模式　　160<br>6.2.7　稳妥构造函数模式　　161<br>6.3　继承　　162<br>6.3.1　原型链　　162<br>6.3.2　借用构造函数　　167<br>6.3.3　组合继承　　168<br>6.3.4　原型式继承　　169<br>6.3.5　寄生式继承　　171<br>6.3.6　寄生组合式继承　　172<br>6.4　小结　　174<br>第7章　函数表达式　　175<br>7.1　递归　　177<br>7.2　闭包　　178<br>7.2.1　闭包与变量　　181<br>7.2.2　关于this对象　　182<br>7.2.3　内存泄漏　　183<br>7.3　模仿块级作用域　　184<br>7.4　私有变量　　186<br>7.4.1　静态私有变量　　188<br>7.4.2　模块模式　　189<br>7.4.3　增强的模块模式　　191<br>7.5　小结　　192<br>第8章　BOM　　193<br>8.1　window对象　　193<br>8.1.1　全局作用域　　193<br>8.1.2　窗口关系及框架　　194<br>8.1.3　窗口位置　　197<br>8.1.4　窗口大小　　198<br>8.1.5　导航和打开窗口　　199<br>8.1.6　间歇调用和超时调用　　203<br>8.1.7　系统对话框　　205<br>8.2　location对象　　207<br>8.2.1　查询字符串参数　　207<br>8.2.2　位置操作　　208<br>8.3　navigator对象　　210<br>8.3.1　检测插件　　211<br>8.3.2　注册处理程序　　213<br>8.4　screen对象　　214<br>8.5　history对象　　215<br>8.6　小结　　216<br>第9章　客户端检测　　217<br>9.1　能力检测　　217<br>9.1.1　更可靠的能力检测　　218<br>9.1.2　能力检测，不是浏览器检测　　220<br>9.2　怪癖检测　　220<br>9.3　用户代理检测　　221<br>9.3.1　用户代理字符串的历史　　222<br>9.3.2　用户代理字符串检测技术　　228<br>9.3.3　完整的代码　　242<br>9.3.4　使用方法　　245<br>9.4　小结　　246<br>第10章　DOM　　247<br>10.1　节点层次　　247<br>10.1.1　Node类型　　248<br>10.1.2　Document类型　　253<br>10.1.3　Element类型　　261<br>10.1.4　Text类型　　270<br>10.1.5　Comment类型　　273<br>10.1.6　CDATASection类型　　274<br>10.1.7　DocumentType类型　　274<br>10.1.8　DocumentFragment类型　　275<br>10.1.9　Attr类型　　276<br>10.2　DOM操作技术　　277<br>10.2.1　动态脚本　　277<br>10.2.2　动态样式　　279<br>10.2.3　操作表格　　281<br>10.2.4　使用NodeList　　283<br>10.3　小结　　284<br>第11章　DOM扩展　　286<br>11.1　选择符API　　286<br>11.1.1　querySelector()方法　　286<br>11.1.2　querySelectorAll()<br>方法　　287<br>11.1.3　matchesSelector()<br>方法　　288<br>11.2　元素遍历　　288<br>11.3　HTML5　　289<br>11.3.1　与类相关的扩充　　289<br>11.3.2　焦点管理　　291<br>11.3.3　HTMLDocument的变化　　292<br>11.3.4　字符集属性　　293<br>11.3.5　自定义数据属性　　293<br>11.3.6　插入标记　　294<br>11.3.7　scrollIntoView()方法　　298<br>11.4　专有扩展　　298<br>11.4.1　文档模式　　298<br>11.4.2　children属性　　299<br>11.4.3　contains()方法　　300<br>11.4.4　插入文本　　301<br>11.4.5　滚动　　303<br>11.5　小结　　304<br>第12章　DOM2和DOM3　　305<br>12.1　DOM变化　　305<br>12.1.1　针对XML命名空间的变化　　306<br>12.1.2　其他方面的变化　　309<br>12.2　样式　　312<br>12.2.1　访问元素的样式　　313<br>12.2.2　操作样式表　　317<br>12.2.3　元素大小　　320<br>12.3　遍历　　326<br>12.3.1　NodeIterator　　328<br>12.3.2　TreeWalker　　330<br>12.4　范围　　332<br>12.4.1　DOM中的范围　　332<br>12.4.2　IE8及更早版本中的范围　　340<br>12.5　小结　　343<br>第13章　事件　　345<br>13.1　事件流　　345<br>13.1.1　事件冒泡　　346<br>13.1.2　事件捕获　　346<br>13.1.3　DOM事件流　　347<br>13.2　事件处理程序　　348<br>13.2.1　HTML事件处理程序　　348<br>13.2.2　DOM0级事件处理程序　　350<br>13.2.3　DOM2级事件处理程序　　351<br>13.2.4　IE事件处理程序　　352<br>13.2.5　跨浏览器的事件处理程序　　353<br>13.3　事件对象　　355<br>13.3.1　DOM中的事件对象　　355<br>13.3.2　IE中的事件对象　　358<br>13.3.3　跨浏览器的事件对象　　360<br>13.4　事件类型　　362<br>13.4.1　UI事件　　362<br>13.4.2　焦点事件　　367<br>13.4.3　鼠标与滚轮事件　　368<br>13.4.4　键盘与文本事件　　379<br>13.4.5　复合事件　　384<br>13.4.6　变动事件　　385<br>13.4.7　HTML5事件　　388<br>13.4.8　设备事件　　395<br>13.4.9　触摸与手势事件　　399<br>13.5　内存和性能　　402<br>13.5.1　事件委托　　402<br>13.5.2　移除事件处理程序　　404<br>13.6　模拟事件　　405<br>13.6.1　DOM中的事件模拟　　405<br>13.6.2　IE中的事件模拟　　410<br>13.7　小结　　411<br>第14章　表单脚本　　412<br>14.1　表单的基础知识　　412<br>14.1.1　提交表单　　413<br>14.1.2　重置表单　　414<br>14.1.3　表单字段　　414<br>14.2　文本框脚本　　419<br>14.2.1　选择文本　　420<br>14.2.2　过滤输入　　423<br>14.2.3　自动切换焦点　　426<br>14.2.4　HTML5约束验证API　　427<br>14.3　选择框脚本　　431<br>14.3.1　选择选项　　432<br>14.3.2　添加选项　　434<br>14.3.3　移除选项　　435<br>14.3.4　移动和重排选项　　435<br>14.4　表单序列化　　436<br>14.5　富文本编辑　　438<br>14.5.1　使用contenteditable<br>属性　　438<br>14.5.2　操作富文本　　439<br>14.5.3　富文本选区　　441<br>14.5.4　表单与富文本　　443<br>14.6　小结　　443<br>第15章　使用Canvas绘图　　445<br>15.1　基本用法　　445<br>15.2　2D上下文　　446<br>15.2.1　填充和描边　　446<br>15.2.2　绘制矩形　　447<br>15.2.3　绘制路径　　449<br>15.2.4　绘制文本　　451<br>15.2.5　变换　　453<br>15.2.6　绘制图像　　456<br>15.2.7　阴影　　457<br>15.2.8　渐变　　458<br>15.2.9　模式　　460<br>15.2.10　使用图像数据　　460<br>15.2.11　合成　　462<br>15.3　WebGL　　463<br>15.3.1　类型化数组　　463<br>15.3.2　WebGL上下文　　468<br>15.3.3　支持　　478<br>15.4　小结　　478<br>第16章　HTML5脚本编程　　480<br>16.1　跨文档消息传递　　480<br>16.2　原生拖放　　481<br>16.2.1　拖放事件　　482<br>16.2.2　自定义放置目标　　482<br>16.2.3　dataTransfer对象　　483<br>16.2.4　dropEffect与effectAllowed　　484<br>16.2.5　可拖动　　485<br>16.2.6　其他成员　　485<br>16.3　媒体元素　　486<br>16.3.1　属性　　487<br>16.3.2　事件　　488<br>16.3.3　自定义媒体播放器　　488<br>16.3.4　检测编解码器的支持情况　　489<br>16.3.5　Audio类型　　490<br>16.4　历史状态管理　　491<br>16.5　小结　　492<br>第17章　错误处理与调试　　493<br>17.1　浏览器报告的错误　　493<br>17.1.1　IE　　493<br>17.1.2　Firefox　　494<br>17.1.3　Safari　　496<br>17.1.4　Opera　　497<br>17.1.5　Chrome　　498<br>17.2　错误处理　　499<br>17.2.1　try-catch语句　　500<br>17.2.2　抛出错误　　503<br>17.2.3　错误（error）事件　　505<br>17.2.4　处理错误的策略　　506<br>17.2.5　常见的错误类型　　507<br>17.2.6　区分致命错误和非致命<br>错误　　510<br>17.2.7　把错误记录到服务器　　511<br>17.3　调试技术　　512<br>17.3.1　将消息记录到控制台　　512<br>17.3.2　将消息记录到当前页面　　515<br>17.3.3　抛出错误　　515<br>17.4　常见的IE错误　　516<br>17.4.1　操作终止　　516<br>17.4.2　无效字符　　518<br>17.4.3　未找到成员　　518<br>17.4.4　未知运行时错误　　519<br>17.4.5　语法错误　　519<br>17.4.6　系统无法找到指定资源　　519<br>17.5　小结　　520<br>第18章　JavaScript与XML　　521<br>18.1　浏览器对XML DOM的支持　　521<br>18.1.1　DOM2级核心　　521<br>18.1.2　DOMParser类型　　522<br>18.1.3　XMLSerializer类型　　523<br>18.1.4　IE8及之前版本中的XML　　523<br>18.1.5　跨浏览器处理XML　　527<br>18.2　浏览器对XPath的支持　　529<br>18.2.1　DOM3级XPath　　529<br>18.2.2　IE中的XPath　　534<br>18.2.3　跨浏览器使用XPath　　535<br>18.3　浏览器对XSLT的支持　　537<br>18.3.1　IE中的XSLT　　537<br>18.3.2　XSLTProcessor类型　　541<br>18.3.3　跨浏览器使用XSLT　　543<br>18.4　小结　　544<br>第19章　E4X　　546<br>19.1　E4X的类型　　546<br>19.1.1　XML类型　　546<br>19.1.2　XMLList类型　　547<br>19.1.3　Namespace类型　　548<br>19.1.4　QName类型　　549<br>19.2　一般用法　　550<br>19.2.1　访问特性　　551<br>19.2.2　其他节点类型　　552<br>19.2.3　查询　　553<br>19.2.4　构建和操作XML　　555<br>19.2.5　解析和序列化　　557<br>19.2.6　命名空间　　558<br>19.3　其他变化　　559<br>19.4　全面启用E4X　　560<br>19.5　小结　　561<br>第20章　JSON　　562<br>20.1　语法　　562<br>20.1.1　简单值　　562<br>20.1.2　对象　　563<br>20.1.3　数组　　564<br>20.2　解析与序列化　　565<br>20.2.1　JSON对象　　565<br>20.2.2　序列化选项　　566<br>20.2.3　解析选项　　569<br>20.3　小结　　570<br>第21章　Ajax与Comet　　571<br>21.1　XMLHttpRequest对象　　571<br>21.1.1　XHR的用法　　573<br>21.1.2　HTTP头部信息　　575<br>21.1.3　GET请求　　576<br>21.1.4　POST请求　　577<br>21.2　XMLHttpRequest 2级　　578<br>21.2.1　FormData　　578<br>21.2.2　超时设定　　579<br>21.2.3　overrideMimeType()<br>方法　　580<br>21.3　进度事件　　580<br>21.3.1　load事件　　580<br>21.3.2　progress事件　　581<br>21.4　跨源资源共享　　582<br>21.4.1　IE对CORS的实现　　582<br>21.4.2　其他浏览器对CORS的<br>实现　　584<br>21.4.3　Preflighted Reqeusts　　584<br>21.4.4　带凭据的请求　　585<br>21.4.5　跨浏览器的CORS　　585<br>21.5　其他跨域技术　　586<br>21.5.1　图像Ping　　586<br>21.5.2　JSONP　　587<br>21.5.3　Comet　　588<br>21.5.4　服务器发送事件　　590<br>21.5.5　Web Sockets　　591<br>21.5.6　SSE与Web Sockets　　593<br>21.6　安全　　593<br>21.7　小结　　594<br>第22章　高级技巧　　596<br>22.1　高级函数　　596<br>22.1.1　安全的类型检测　　596<br>22.1.2　作用域安全的构造函数　　597<br>22.1.3　惰性载入函数　　600<br>22.1.4　函数绑定　　602<br>22.1.5　函数柯里化　　604<br>22.2　防篡改对象　　606<br>22.2.1　不可扩展对象　　606<br>22.2.2　密封的对象　　607<br>22.2.3　冻结的对象　　608<br>22.3　高级定时器　　609<br>22.3.1　重复的定时器　　610<br>22.3.2　Yielding Processes　　612<br>22.3.3　函数节流　　614<br>22.4　自定义事件　　616<br>22.5　拖放　　618<br>22.5.1　修缮拖动功能　　620<br>22.5.2　添加自定义事件　　622<br>22.6　小结　　624<br>第23章　离线应用与客户端存储　　626<br>23.1　离线检测　　626<br>23.2　应用缓存　　627<br>23.3　数据存储　　628<br>23.3.1　Cookie　　629<br>23.3.2　IE用户数据　　637<br>23.3.3　Web存储机制　　638<br>23.3.4　IndexedDB　　643<br>23.4　小结　　654<br>第24章　最佳实践　　656<br>24.1　可维护性　　656<br>24.1.1　什么是可维护的代码　　656<br>24.1.2　代码约定　　657<br>24.1.3　松散耦合　　659<br>24.1.4　编程实践　　662<br>24.2　性能　　666<br>24.2.1　注意作用域　　666<br>24.2.2　选择正确方法　　667<br>24.2.3　最小化语句数　　672<br>24.2.4　优化DOM交互　　673<br>24.3　部署　　676<br>24.3.1　构建过程　　676<br>24.3.2　验证　　677<br>24.3.3　压缩　　679<br>24.4　小结　　681<br>第25章　新兴的API　　682<br>25.1　requestAnimationFrame()　　682<br>25.1.1　早期动画循环　　682<br>25.1.2　循环间隔的问题　　683<br>25.1.3　mozRequestAnimation-Frame　　683<br>25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685<br>25.2　Page Visibility API　　686<br>25.3　Geolocation API　　687<br>25.4　File API　　689<br>25.4.1　FileReader类型　　690<br>25.4.2　读取部分内容　　692<br>25.4.3　对象URL　　693<br>25.4.4　读取拖放的文件　　694<br>25.4.5　使用XHR上传文件　　695<br>25.5　Web计时　　696<br>25.6　Web Workers　　697<br>25.6.1　使用Worker　　697<br>25.6.2　Worker全局作用域　　698<br>25.6.3　包含其他脚本　　699<br>25.6.4　Web Workers的未来　　700<br>25.7　小结　　700<br>附录A　ECMAScript Harmony　　701<br>附录B　严格模式　　717<br>附录C　JavaScript库　　723<br>附录D　JavaScript工具　　727</p><h3 id="JavaScript高级程序设计（第4版）-PDF-下载"><a href="#JavaScript高级程序设计（第4版）-PDF-下载" class="headerlink" title="JavaScript高级程序设计（第4版） PDF 下载"></a>JavaScript高级程序设计（第4版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Ejf6rmDtITQH0eBtAqjkCA?pwd=8j6a">https://pan.baidu.com/s/1Ejf6rmDtITQH0eBtAqjkCA?pwd=8j6a</a> </p><p>提取码：8j6a</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《持续交付2.0：业务引领的DevOps精要》</title>
      <link href="/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/"/>
      <url>/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1a3aea4bb6854e7de11011ef09cecc2b.png" alt="《持续交付2.0：业务引领的DevOps精要》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</p><p>本书分三个部分。第一部分作者根据自己近十年的工作及咨询经历，不断总结、提炼和反思，对原有的持续交付进行了修正，重新定义持续交付为实现组织战略目标的能力，并引入持续交付的能力模型；</p><p>第二部分阐述组织打造持续交付能力所需遵守的原则，包括基础原则、组织原则和架构原则；</p><p>第三部分通过多个互联网公司案例的解读，阐述如何根据组织的当前状况，应用原则，并对最佳实践进行取舍，快速达到组织能力目标。</p><p>本书适合大型互联网公司的技术VP、技术负责人，中小型互联网公司的CTO、技术VP、研发&#x2F;测试&#x2F;运维负责人、主管及骨干，以及组织变革者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>乔梁</p><p>敏思特咨询公司联合创始人，持续交付领域专家，著名敏捷与精益转型导师，腾讯外聘高级管理顾问。拥有多年IT从业经验，曾就职于百度、Nokia等国内外知名软件公司，并先后担任多个互联网公司的高级管理顾问，帮助多个产品线取得业务上的成功突破。曾为华为、上汽等非互联网软件企业提供敏捷转型咨询服务，指导解决组织转型与研发管理方面的相关问题。</p><p>乔梁是国内最早致力于通过敏捷开发与精益理论改善软件价值交付效率的实践者之一，精研各种软件工程方法论，2010年翻译《持续交付》一书，并将其融会贯通，成为持续交付和DevOps理念在国内的首批实践者和布道者，经过八年的管理实践，总结提炼，提出持续交付双环模型，并将工作心得整理成册，取名《持续交付2.0》，将关注点前移至业务价值的持续探索与快速验证方法。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　持续交付2.0 1<br>1.1　软件工程发展概述 1<br>1.1.1　瀑布软件开发方法 1<br>1.1.2　敏捷软件开发方法 2<br>1.1.3　DevOps运动 3<br>1.1.4　持续交付1.0 4<br>1.2　持续交付2.0 7<br>1.2.1　精益思想 8<br>1.2.2　双环模型 9<br>1.2.3　4个核心原则 11<br>1.2.4　持续交付七巧板 12<br>1.3　小结 13<br>第2章　价值探索环 14<br>2.1　探索环的意义 14<br>2.2　探索环的4个关键环节 15<br>2.2.1　提问 16<br>2.2.2　锚定 17<br>2.2.3　共创 19<br>2.2.4　精炼 22<br>2.3　工作原则 24<br>2.3.1　分解并快速试错 24<br>2.3.2　一次只验证一点 25<br>2.3.3　允许失败 26<br>2.4　共创与精炼的常用方法 27<br>2.4.1　装饰窗方法 27<br>2.4.2　最小可行特性法 29<br>2.4.3　特区法 30<br>2.4.4　定向探索法 30<br>2.4.5　稻草人法 31<br>2.4.6　最小可行产品法 32<br>2.5　实施注意事项 32<br>2.6　小结 35<br>第3章　快速验证环 36<br>3.1　验证环的目标 36<br>3.2　验证环的4个关键环节 37<br>3.2.1　构建 37<br>3.2.2　运行 38<br>3.2.3　监测 39<br>3.2.4　决策 39<br>3.3　工作原则 39<br>3.3.1　质量内建 39<br>3.3.2　消除等待 40<br>3.3.3　重复事务自动化 43<br>3.3.4　监测一切 43<br>3.4　小结 44<br>第4章　持续交付2.0的组织文化 45<br>4.1　安全、信任与持续改善 45<br>4.1.1　失败是安全的 45<br>4.1.2　相互信任 45<br>4.1.3　持续改善 46<br>4.2　文化塑造四步法 46<br>4.2.1　行为决定文化 46<br>4.2.2　谷歌的工程师质量文化 48<br>4.2.3　Etsy的持续试验文化 49<br>4.3　行动原则 50<br>4.3.1　价值导向 51<br>4.3.2　快速验证 51<br>4.3.3　持续学习 51<br>4.4　度量原则 55<br>4.4.1　度量指标的4类属性 56<br>4.4.2　度量的目标是改善 57<br>4.5　“改善套路”进行持续改进 57<br>4.6　小结 58<br>第5章　持续交付的软件系统架构 60<br>5.1　“大系统小做”原则 61<br>5.1.1　持续交付架构要求 61<br>5.1.2　系统拆分原则 61<br>5.2　常见架构模式 62<br>5.2.1　微核架构 62<br>5.2.2　微服务架构 63<br>5.2.3　巨石应用 64<br>5.3　架构改造实施模式 66<br>5.3.1　拆迁者模式 67<br>5.3.2　绞杀者模式 68<br>5.3.3　修缮者模式 68<br>5.3.4　数据库的拆分方法 70<br>5.4　小结 70<br>第6章　业务需求协作管理 72<br>6.1　产品版本周期概述 73<br>6.1.1　准备期 73<br>6.1.2　交付期 74<br>6.2　需求拆分的利与弊 75<br>6.2.1　需求拆分的收益 76<br>6.2.2　需求拆分的成本 78<br>6.3　需求拆分方法 79<br>6.3.1　需求的来源 80<br>6.3.2　技术债也是需求 80<br>6.3.3　参与需求拆分的角色 81<br>6.3.4　不平等的INVEST原则 82<br>6.3.5　五大拆分技法 82<br>6.3.6　七大组成部分 84<br>6.4　需求分析与管理工具集 85<br>6.4.1　用户故事地图 85<br>6.4.2　用户故事树 86<br>6.4.3　依赖关系图 87<br>6.4.4　需求管理数字化平台 87<br>6.5　团队协作管理工具 87<br>6.5.1　团队共享日历 88<br>6.5.2　团队回顾 89<br>6.5.3　可视化故事墙 90<br>6.5.4　明确“完成”的定义 90<br>6.5.5　持续集成 91<br>6.5.6　故事验证 91<br>6.6　小结 91<br>第7章　部署流水线原则与工具设计 92<br>7.1　简单的部署流水线 92<br>7.1.1　简单的产品研发流程 92<br>7.1.2　初始部署流水线 93<br>7.1.3　流水线执行状态解析 95<br>7.2　部署流水线的设计与使用 95<br>7.2.1　流水线的设计原则 95<br>7.2.2　团队的协作纪律 97<br>7.3　部署流水线平台的构成 97<br>7.3.1　工具链总体架构 97<br>7.3.2　平台应当具备的基本能力 99<br>7.3.3　工具链建设策略 100<br>7.4　基础支撑服务的云化 100<br>7.4.1　基础支撑服务的协作过程解析 101<br>7.4.2　编译构建管理服务 103<br>7.4.3　自动化测试管理服务 104<br>7.4.4　软件部署管理服务 105<br>7.4.5　基础环境管理服务 106<br>7.5　企业制品库的管理 107<br>7.5.1　制品库的分类 107<br>7.5.2　制品库的管理原则 108<br>7.6　多种多样的部署流水线 108<br>7.6.1　多组件的部署流水线 108<br>7.6.2　个人部署流水线 109<br>7.6.3　部署流水线的不断演进 110<br>7.7　为开发者构建自助式工具 111<br>7.8　小结 113<br>第8章　利于集成的分支策略 114<br>8.1　版本控制系统的使用目的 114<br>8.1.1　集中式版本控制系统 114<br>8.1.2　分布式版本控制系统 115<br>8.1.3　版本控制系统中的基本概念 117<br>8.2　常见分支开发模式 118<br>8.2.1　主干开发，主干发布 118<br>8.2.2　主干开发，分支发布 119<br>8.2.3　分支开发，主干发布 121<br>8.3　分支模式的演化 126<br>8.3.1　三驾马车分支模式 126<br>8.3.2　Gitflow分支模式 127<br>8.3.3　GitHubFlow分支模式 128<br>8.4　分支策略的选择 128<br>8.4.1　版本发布模式 128<br>8.4.2　分支策略与发布周期的关系 132<br>8.5　小结 133<br>第9章　持续集成 134<br>9.1　起源与定义 134<br>9.1.1　原始定义 135<br>9.1.2　一次集成过程 135<br>9.2　六步提交法 136<br>9.2.1　4个关键点 138<br>9.2.2　同步与异步模式 139<br>9.2.3　自查表 140<br>9.3　速度与质量的权衡 141<br>9.3.1　分级构建 142<br>9.3.2　多人同时提交的构建 142<br>9.3.3　云平台的威力 143<br>9.4　在团队中实施持续集成实践 145<br>9.4.1　快速建立团队的持续集成实践 146<br>9.4.2　分支策略与部署流水线 148<br>9.5　常见的实施问题 150<br>9.5.1　工程师的开发习惯 151<br>9.5.2　视而不见的扫描问题 151<br>9.5.3　自动化测试用例的缺乏 151<br>9.6　小结 152<br>第10章　自动化测试策略与方法 153<br>10.1　自动化测试的自身定位 153<br>10.1.1　自动化测试的优势 154<br>10.1.2　自动化测试所需的投入 155<br>10.2　突破传统自动化测试的困境 156<br>10.2.1　传统自动化测试的特点 157<br>10.2.2　自动化测试的分层 157<br>10.2.3　不同类型的测试金字塔 160<br>10.3　自动化测试的实施策略 163<br>10.3.1　增加自动化测试用例的着手点 163<br>10.3.2　提高自动化测试的执行次数 164<br>10.3.3　良好自动化测试的特征 165<br>10.3.4　共享自动化测试的维护职责 166<br>10.3.5　代码测试覆盖率 167<br>10.4　用户验收自动化测试要点 168<br>10.4.1　先搭建分层框架 168<br>10.4.2　测试用例数应保持低位 171<br>10.4.3　为自动化测试用例预留API 171<br>10.4.4　为调试做好准备 171<br>10.4.5　测试数据的准备 171<br>10.5　其他质量检查方法 173<br>10.5.1　差异批注测试方法 173<br>10.5.2　代码规范检查与代码动静态检测 174<br>10.5.3　AI在测试领域的应用 174<br>10.6　小结 175<br>第11章　软件配置管理 176<br>11.1　将一切纳入配置管理 176<br>11.1.1　配置管理目标 176<br>11.1.2　配置管理的范围 177<br>11.1.3　软件配置管理原则 177<br>11.2　软件包的版本管理 181<br>11.2.1　包管理的反模式 181<br>11.2.2　集中式包管理服务 182<br>11.2.3　软件包的元信息 183<br>11.3　包依赖管理 185<br>11.3.1　显式声明依赖 185<br>11.3.2　自动管理依赖 187<br>11.3.3　减少复杂依赖 188<br>11.4　环境基础设施管理 191<br>11.4.1　环境准备的4种状态 191<br>11.4.2　领域专属语言的应用 197<br>11.4.3　环境基础设施即代码 198<br>11.5　软件配置项的管理 199<br>11.5.1　二进制与配置项的分离 199<br>11.5.2　配置信息的版本管理 200<br>11.5.3　配置项的存储组织方式 201<br>11.5.4　配置漂移与治理 202<br>11.6　不可变基础设施与云应用 203<br>11.6.1　实现不可变基础设施 203<br>11.6.2　云原生应用 206<br>11.6.3　优势与挑战 206<br>11.7　数据的版本管理 208<br>11.7.1　数据库结构变更 208<br>11.7.2　数据文件 208<br>11.8　需求与源代码的版本关联 209<br>11.9　小结 209<br>第12章　低风险发布 211<br>12.1　高频发布是一种趋势 211<br>12.1.1　互联网企业的高频发布 212<br>12.1.2　收益与成本共存 214<br>12.2　降低发布风险的方法 215<br>12.2.1　蓝绿部署 215<br>12.2.2　滚动部署 216<br>12.2.3　金丝雀发布与灰度发布 217<br>12.2.4　暗部署 218<br>12.3　高频发布支撑技术 219<br>12.3.1　功能开关技术 220<br>12.3.2　数据迁移技术 222<br>12.3.3　抽象分支方法 225<br>12.3.4　升级替代回滚 226<br>12.4　影响发布频率的因素 227<br>12.5　小结 228<br>第13章　监测与决策 229<br>13.1　生产监测范围 230<br>13.1.1　后台服务的监测 230<br>13.1.2　分发软件的监测 230<br>13.2　数据监测体系 231<br>13.2.1　收集与处理 231<br>13.2.2　数据的标准化 232<br>13.2.3　监测数据体系及其能力衡量 233<br>13.3　问题处理体系 235<br>13.3.1　告警海洋与智能化管理 235<br>13.3.2　问题处理是一个学习过程 236<br>13.4　生产环境测试 237<br>13.4.1　测试活动扁平化趋势 237<br>13.4.2　生产环境中的测试 239<br>13.4.3　混沌工程 239<br>13.5　向东，还是向西 240<br>13.6　小结 241<br>第14章　大型互联网团队的FT化 242<br>14.1　简介 242<br>14.1.1　改进前状态 243<br>14.1.2　改进后状态 244<br>14.2　改进方法论 245<br>14.2.1　指导思想 245<br>14.2.2　改进步骤 245<br>14.3　改进的历程 246<br>14.3.1　架构解耦 246<br>14.3.2　组织解耦 248<br>14.3.3　研发流程再造 250<br>14.3.4　自动化一切 259<br>14.4　小结 260<br>第15章　小团队逆袭之旅 262<br>15.1　背景简介 262<br>15.1.1　改进前的“死亡行军”之旅 264<br>15.1.2　改进后的无缺陷交付 264<br>15.2　改进方法论 265<br>15.2.1　指导思想 265<br>15.2.2　试点团队的选择 265<br>15.3　第一阶段：研发准备期 266<br>15.3.1　功能简介与需求拆分 266<br>15.3.2　架构设计与需求依赖识别 267<br>15.3.3　工作量估算与排期 268<br>15.4　第二阶段：软件交付期 270<br>15.4.1　通过可视化看板改进工作流程 270<br>15.4.2　无缺陷交付 277<br>15.4.3　主干开发与持续集成 278<br>15.4.4　测试活动左移 279<br>15.4.5　代码评审 279<br>15.4.6　关注结果，更要关注过程 280<br>15.5　小结 281<br>第16章　研发推动的DevOps 283<br>16.1　改进的关键点 285<br>16.1.1　改进方法论 285<br>16.1.2　定义改进目标 285<br>16.2　第一阶段：敏捷101 287<br>16.2.1　做个靠谱的计划 287<br>16.2.2　开发阶段启航 291<br>16.2.3　对过程质量的约束 294<br>16.2.4　阶段性改进点 301<br>16.3　第二阶段：DevOps转型 302<br>16.3.1　与运维人员的“冲突” 303<br>16.3.2　高频部署发布中的具体障碍 304<br>16.3.3　整体解决方案的设计 304<br>16.3.4　DevOps阶段的团队改变 308<br>16.4　小结 308<br>附录A　软件工程的三次进化 310<br>附录B　排序法做相对估算 323</p><h3 id="持续交付2-0：业务引领的DevOps精要-PDF-下载"><a href="#持续交付2-0：业务引领的DevOps精要-PDF-下载" class="headerlink" title="持续交付2.0：业务引领的DevOps精要 PDF 下载"></a>持续交付2.0：业务引领的DevOps精要 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1U2alK_9N-AnB5pI-Kt9hZA?pwd=viff">https://pan.baidu.com/s/1U2alK_9N-AnB5pI-Kt9hZA?pwd=viff</a> </p><p>提取码：viff</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> 持续交付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机（第3版）》</title>
      <link href="/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/"/>
      <url>/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/e0e32b23ce83f43911565b8216a4c7e7.png" alt="《深入理解Java虚拟机（第3版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典，繁体版在台湾也颇受欢迎。</p><p>自2011年上市以来，前两个版本累计印刷36次，销量超过30万册，两家主要网络书店的评论近90000条，内容上近乎零差评，是原创计算机图书领域不可逾越的丰碑。</p><p>第3版在第2版的基础上做了重大修订，内容更丰富、实战性更强：根据新版JDK对内容进行了全方位的修订和升级，围绕新技术和生产实践新增逾10万字，包含近50%的全新内容，并对第2版中含糊、瑕疵和错误内容进行了修正。</p><p>全书一共13章，分为五大部分：</p><p>第一部分（第1章）走近Java</p><p>系统介绍了Java的技术体系、发展历程、虚拟机家族，以及动手编译JDK，了解这部分内容能对学习JVM提供良好的指引。</p><p>第二部分（第2~5章）自动内存管理</p><p>详细讲解了Java的内存区域与内存溢出、垃圾收集器与内存分配策略、虚拟机性能监控与故障排除等与自动内存管理相关的内容，以及10余个经典的性能优化案例和优化方法；</p><p>第三部分（第6~9章）虚拟机执行子系统</p><p>深入分析了虚拟机执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎，以及多个类加载及其执行子系统的实战案例；</p><p>第四部分（第10~11章）程序编译与代码优化</p><p>详细讲解了程序的前、后端编译与优化，包括前端的易用性优化措施，如泛型、主动装箱拆箱、条件编译等的内容的深入分析；以及后端的性能优化措施，如虚拟机的热点探测方法、HotSpot 的即时编译器、提前编译器，以及各种常见的编译期优化技术；</p><p>第五部分（第12~13章）高效并发</p><p>主要讲解了Java实现高并发的原理，包括Java的内存模型、线程与协程，以及线程安全和锁优化。</p><p>全书以实战为导向，通过大量与实际生产环境相结合的案例分析和展示了解决各种Java技术难题的方案和技巧。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>资深Java技术、机器学习和企业级开发技术专家，现任远光软件研究院院长，人工智能博士在读，著有知名畅销书《深入理解Java虚拟机：JVM高级特性与最佳实践》。</p><p>开源技术的积极倡导者和推动者，对计算机科学和相关的多个领域都有深刻的见解，尤其是人工智能、Java开发和敏捷开发等领域。曾受邀在InfoQ和IBM DeveloperWorks等网站撰写技术专栏。</p><p>著作颇丰，著有《深入理解Java虚拟机》《深入理解OSGi》，翻译了《Java虚拟机规范》等著作。其中《深入理解Java虚拟机》第1版出版于2011年，已经出至第2版，不仅销量好，而且口碑更好，累计印刷超过30次，仍长销不衰，是中文计算机图书领域公认的、难得一见的佳作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　走近Java<br>第1章　走近Java 2<br>1.1　概述 2<br>1.2　Java技术体系 3<br>1.3　Java发展史 4<br>1.4　Java虚拟机家族 12<br>1.4.1　虚拟机始祖：Sun Classic&#x2F;Exact VM 12<br>1.4.2　武林盟主：HotSpot VM 13<br>1.4.3　小家碧玉：Mobile&#x2F;Embedded VM 14<br>1.4.4　天下第二：BEA JRockit&#x2F;IBM J9 VM 15<br>1.4.5　软硬合璧：BEA Liquid VM&#x2F;Azul VM 16<br>1.4.6　挑战者：Apache Harmony&#x2F;Google Android Dalvik VM 17<br>1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18<br>1.4.8　百家争鸣 19<br>1.5　展望Java技术的未来 21<br>1.5.1　无语言倾向 21<br>1.5.2　新一代即时编译器 23<br>1.5.3　向Native迈进 24<br>1.5.4　灵活的胖子 26<br>1.5.5　语言语法持续增强 27<br>1.6　实战：自己编译JDK 29<br>1.6.1　获取源码 29<br>1.6.2　系统需求 31<br>1.6.3　构建编译环境 33<br>1.6.4　进行编译 34<br>1.6.5　在IDE工具中进行源码调试 36<br>1.7　本章小结 39<br>第二部分　自动内存管理<br>第2章　Java内存区域与内存溢出异常 42<br>2.1　概述 42<br>2.2　运行时数据区域 42<br>2.2.1　程序计数器 43<br>2.2.2　Java虚拟机栈 43<br>2.2.3　本地方法栈 44<br>2.2.4　Java堆 44<br>2.2.5　方法区 46<br>2.2.6　运行时常量池 47<br>2.2.7　直接内存 47<br>2.3　HotSpot虚拟机对象探秘 48<br>2.3.1　对象的创建 48<br>2.3.2　对象的内存布局 51<br>2.3.3　对象的访问定位 52<br>2.4　实战：OutOfMemoryError异常 53<br>2.4.1　Java堆溢出 54<br>2.4.2　虚拟机栈和本地方法栈溢出 56<br>2.4.3　方法区和运行时常量池溢出 61<br>2.4.4　本机直接内存溢出 65<br>2.5　本章小结 66<br>第3章　垃圾收集器与内存分配策略 67<br>3.1　概述 67<br>3.2　对象已死？ 68<br>3.2.1　引用计数算法 68<br>3.2.2　可达性分析算法 70<br>3.2.3　再谈引用 71<br>3.2.4　生存还是死亡？ 72<br>3.2.5　回收方法区 74<br>3.3　垃圾收集算法 75<br>3.3.1　分代收集理论 75<br>3.3.2　标记-清除算法 77<br>3.3.3　标记-复制算法 78<br>3.3.4　标记-整理算法 79<br>3.4　HotSpot的算法细节实现 81<br>3.4.1　根节点枚举 81<br>3.4.2　安全点 82<br>3.4.3　安全区域 83<br>3.4.4　记忆集与卡表 84<br>3.4.5　写屏障 85<br>3.4.6　并发的可达性分析 87<br>3.5　经典垃圾收集器 89<br>3.5.1　Serial收集器 90<br>3.5.2　ParNew收集器 92<br>3.5.3　Parallel Scavenge收集器 93<br>3.5.4　Serial Old收集器 94<br>3.5.5　Parallel Old收集器 95<br>3.5.6　CMS收集器 96<br>3.5.7　Garbage First收集器 98<br>3.6　低延迟垃圾收集器 104<br>3.6.1　Shenandoah收集器 105<br>3.6.2　ZGC收集器 112<br>3.7　选择合适的垃圾收集器 121<br>3.7.1　Epsilon收集器 121<br>3.7.2　收集器的权衡 121<br>3.7.3　虚拟机及垃圾收集器日志 122<br>3.7.4　垃圾收集器参数总结 127<br>3.8　实战：内存分配与回收策略 129<br>3.8.1　对象优先在Eden分配 130<br>3.8.2　大对象直接进入老年代 131<br>3.8.3　长期存活的对象将进入老年代 132<br>3.8.4　动态对象年龄判定 134<br>3.8.5　空间分配担保 135<br>3.9　本章小结 137<br>第4章　虚拟机性能监控、故障处理工具 138<br>4.1　概述 138<br>4.2　基础故障处理工具 138<br>4.2.1　jps：虚拟机进程状况工具 141<br>4.2.2　jstat：虚拟机统计信息监视工具 142<br>4.2.3　jinfo：Java配置信息工具 143<br>4.2.4　jmap：Java内存映像工具 144<br>4.2.5　jhat：虚拟机堆转储快照分析工具 145<br>4.2.6　jstack：Java堆栈跟踪工具 146<br>4.2.7　基础工具总结 148<br>4.3　可视化故障处理工具 151<br>4.3.1　JHSDB：基于服务性代理的调试工具 152<br>4.3.2　JConsole：Java监视与管理控制台 157<br>4.3.3　VisualVM：多合-故障处理工具 164<br>4.3.4　Java Mission Control：可持续在线的监控工具 171<br>4.4　HotSpot虚拟机插件及工具 175<br>4.5　本章小结 180<br>第5章　调优案例分析与实战 181<br>5.1　概述 181<br>5.2　案例分析 181<br>5.2.1　大内存硬件上的程序部署策略 182<br>5.2.2　集群间同步导致的内存溢出 184<br>5.2.3　堆外内存导致的溢出错误 185<br>5.2.4　外部命令导致系统缓慢 187<br>5.2.5　服务器虚拟机进程崩溃 187<br>5.2.6　不恰当数据结构导致内存占用过大 188<br>5.2.7　由Windows虚拟内存导致的长时间停顿 189<br>5.2.8　由安全点导致长时间停顿 190<br>5.3　实战：Eclipse运行速度调优 192<br>5.3.1　调优前的程序运行状态 193<br>5.3.2　升级JDK版本的性能变化及兼容问题 196<br>5.3.3　编译时间和类加载时间的优化 200<br>5.3.4　调整内存设置控制垃圾收集频率 203<br>5.3.5　选择收集器降低延迟 206<br>5.4　本章小结 209<br>第三部分　虚拟机执行子系统<br>第6章　类文件结构 212<br>6.1　概述 212<br>6.2　无关性的基石 212<br>6.3　Class类文件的结构 214<br>6.3.1　魔数与Class文件的版本 215<br>6.3.2　常量池 218<br>6.3.3　访问标志 224<br>6.3.4　类索引、父类索引与接口索引集合 225<br>6.3.5　字段表集合 226<br>6.3.6　方法表集合 229<br>6.3.7　属性表集合 230<br>6.4　字节码指令简介 251<br>6.4.1　字节码与数据类型 251<br>6.4.2　加载和存储指令 253<br>6.4.3　运算指令 254<br>6.4.4　类型转换指令 255<br>6.4.5　对象创建与访问指令 256<br>6.4.6　操作数栈管理指令 256<br>6.4.7　控制转移指令 257<br>6.4.8　方法调用和返回指令 257<br>6.4.9　异常处理指令 258<br>6.4.10　同步指令 258<br>6.5　公有设计，私有实现 259<br>6.6　Class文件结构的发展 260<br>6.7　本章小结 261<br>第7章　虚拟机类加载机制 262<br>7.1　概述 262<br>7.2　类加载的时机 263<br>7.3　类加载的过程 267<br>7.3.1　加载 267<br>7.3.2　验证 268<br>7.3.3　准备 271<br>7.3.4　解析 272<br>7.3.5　初始化 277<br>7.4　类加载器 279<br>7.4.1　类与类加载器 280<br>7.4.2　双亲委派模型 281<br>7.4.3　破坏双亲委派模型 285<br>7.5　Java模块化系统 287<br>7.5.1　模块的兼容性 288<br>7.5.2　模块化下的类加载器 290<br>7.6　本章小结 292<br>第8章　虚拟机字节码执行引擎 293<br>8.1　概述 293<br>8.2　运行时栈帧结构 294<br>8.2.1　局部变量表 294<br>8.2.2　操作数栈 299<br>8.2.3　动态连接 300<br>8.2.4　方法返回地址 300<br>8.2.5　附加信息 301<br>8.3　方法调用 301<br>8.3.1　解析 301<br>8.3.2　分派 303<br>8.4　动态类型语言支持 315<br>8.4.1　动态类型语言 316<br>8.4.2　Java与动态类型 317<br>8.4.3　java.lang.invoke包 318<br>8.4.4　invokedynamic指令 321<br>8.4.5　实战：掌控方法分派规则 324<br>8.5　基于栈的字节码解释执行引擎 326<br>8.5.1　解释执行 327<br>8.5.2　基于栈的指令集与基于寄存器的指令集 328<br>8.5.3　基于栈的解释器执行过程 329<br>8.6　本章小结 334<br>第9章　类加载及执行子系统的案例与实战 335<br>9.1　概述 335<br>9.2　案例分析 335<br>9.2.1　Tomcat：正统的类加载器架构 335<br>9.2.2　OSGi：灵活的类加载器架构 338<br>9.2.3　字节码生成技术与动态代理的实现 341<br>9.2.4　Backport工具：Java的时光机器 345<br>9.3　实战：自己动手实现远程执行功能 348<br>9.3.1　目标 348<br>9.3.2　思路 349<br>9.3.3　实现 350<br>9.3.4　验证 355<br>9.4　本章小结 356<br>第四部分　程序编译与代码优化<br>第10章　前端编译与优化 358<br>10.1　概述 358<br>10.2　Javac编译器 359<br>10.2.1　Javac的源码与调试 359<br>10.2.2　解析与填充符号表 362<br>10.2.3　注解处理器 363<br>10.2.4　语义分析与字节码生成 364<br>10.3　Java语法糖的味道 367<br>10.3.1　泛型 367<br>10.3.2　自动装箱、拆箱与遍历循环 375<br>10.3.3　条件编译 377<br>10.4　实战：插入式注解处理器 378<br>10.4.1　实战目标 379<br>10.4.2　代码实现 379<br>10.4.3　运行与测试 385<br>10.4.4　其他应用案例 386<br>10.5　本章小结 386<br>第11章　后端编译与优化 388<br>11.1　概述 388<br>11.2　即时编译器 389<br>11.2.1　解释器与编译器 389<br>11.2.2　编译对象与触发条件 392<br>11.2.3　编译过程 397<br>11.2.4　实战：查看及分析即时编译结果 398<br>11.3　提前编译器 404<br>11.3.1　提前编译的优劣得失 405<br>11.3.2　实战：Jaotc的提前编译 408<br>11.4　编译器优化技术 411<br>11.4.1　优化技术概览 411<br>11.4.2　方法内联 415<br>11.4.3　逃逸分析 417<br>11.4.4　公共子表达式消除 420<br>11.4.5　数组边界检查消除 421<br>11.5　实战：深入理解Graal编译器 423<br>11.5.1　历史背景 423<br>11.5.2　构建编译调试环境 424<br>11.5.3　JVMCI编译器接口 426<br>11.5.4　代码中间表示 429<br>11.5.5　代码优化与生成 432<br>11.6　本章小结 436<br>第五部分　高效并发<br>第12章　Java内存模型与线程 438<br>12.1　概述 438<br>12.2　硬件的效率与一致性 439<br>12.3　Java内存模型 440<br>12.3.1　主内存与工作内存 441<br>12.3.2　内存间交互操作 442<br>12.3.3　对于volatile型变量的特殊规则 444<br>12.3.4　针对long和double型变量的特殊规则 450<br>12.3.5　原子性、可见性与有序性 450<br>12.3.6　先行发生原则 452<br>12.4　Java与线程 455<br>12.4.1　线程的实现 455<br>12.4.2　Java线程调度 458<br>12.4.3　状态转换 460<br>12.5　Java与协程 461<br>12.5.1　内核线程的局限 461<br>12.5.2　协程的复苏 462<br>12.5.3　Java的解决方案 464<br>12.6　本章小结 465<br>第13章　线程安全与锁优化 466<br>13.1　概述 466<br>13.2　线程安全 466<br>13.2.1　Java语言中的线程安全 467<br>13.2.2　线程安全的实现方法 471<br>13.3　锁优化 479<br>13.3.1　自旋锁与自适应自旋 479<br>13.3.2　锁消除 480<br>13.3.3　锁粗化 481<br>13.3.4　轻量级锁 481<br>13.3.5　偏向锁 483<br>13.4　本章小结 485<br>附录A　在Windows系统下编译OpenJDK 6 486<br>附录B　展望Java技术的未来（2013年版） 493<br>附录C　虚拟机字节码指令表 499<br>附录D　对象查询语言（OQL）简介 506<br>附录E　JDK历史版本轨迹 512</p><h3 id="深入理解Java虚拟机（第3版）-PDF-下载"><a href="#深入理解Java虚拟机（第3版）-PDF-下载" class="headerlink" title="深入理解Java虚拟机（第3版） PDF 下载"></a>深入理解Java虚拟机（第3版） PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1516g8be4qA8OxZFXxA60Bw?pwd=zn83">https://pan.baidu.com/s/1516g8be4qA8OxZFXxA60Bw?pwd=zn83</a> </p><p>提取码：zn83</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Jenkins 2权威指南》</title>
      <link href="/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/DCC8A35F0B25E6C033260746B89DAF45.png" alt="《Jenkins 2权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>设计、实现并且执行具有一定灵活性、可控性以及易于维护性的持续交付流水线，对于以前版本的Jenkins来说是不可能实现的。通过这本实用的书籍，构建管理人员、开发人员、测试人员以及其他专业人员将会学到如何利用Jenkins 2的新特性来定义流水线即代码、集成其他关键技术，以及创建自动化的、可靠的流水线，以便简化和加速DevOps环境的建设。</p><p>作者Brent Laster向你展示了Jenkins 2与这个流行的开源自动化平台基于Web的传统版本有着很大的不同。如果你熟悉Jenkins并且想利用这些新技术来改造老旧流水线或者构建现代的自动化持续交付环境，那么这本书适合你。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝树伟</p><p>《Jenkins权威指南》第一译者，阿里云高级研发工程师，主要负责开源集成和DevOps相关产品的研发，在CI&#x2F;CD领域有丰富经验，在Jenkins开源社区与相关书籍翻译、汉化方面有较多贡献和经验。</p><p>石雪峰</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、Jenkins中文社区核心成员、Jenkins的狂热爱好者。目前就职于京东商城前台工程效率团队，负责公司级持续交付和DevOps平台体系建设。</p><p>雷涛</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、DevOps标准核心编写专家。目前就职于百度工程效率部，曾先后就职于新浪网、摩托罗拉、诺基亚、爱立信、乐视致新等国内外知名企业，专注于互联网、电信、金融、无人驾驶汽车等行业的软件工程效率提升，DevOps解决方案，持续交付，ASPICE&#x2F;ISO 26262研发过程落地等领域。</p><p>李华强</p><p>乐融致新高级配置经理，软件配置管理（SCM）领域的一名老兵，先后就职于北电网络、爱立信、飞维美地、乐视、乐融等多家企业，从事与SCM、DevOps相关的工作。Jenkins的忠实粉丝、最佳实践的推广者，Jenkins官方Certified Jenkins Engineer（CJE）和Certified CloudBees Jenkins Platform Engineer（CCJE）认证者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Jenkins 2简介 1<br>Jenkins 2是什么 2<br>Jenkinsfile 3<br>声明式流水线 5<br>Blue Ocean界面 6<br>Jenkins 2的全新任务类型 7<br>做出转变的原因 10<br>DevOps理念的转变 10<br>装配流水线 11<br>可恢复性 11<br>可配置性 11<br>共享工作空间 11<br>专业知识 12<br>访问逻辑 12<br>流水线源管理 12<br>竞争 12<br>迎接挑战 13<br>兼容性 13<br>流水线兼容性 13<br>插件兼容性 15<br>检查兼容性 20<br>总结 21<br>第2章 基础知识 23<br>语法：脚本式流水线和声明式流水线 24<br>如何选择脚本式语法和声明式语法 25<br>系统（system）：主节点（master）、节点（node）、代理节点（agent）和执行器（executor）26<br>主节点 27<br>节点 27<br>代理节点 27<br>执行器 28<br>创建节点 29<br>结构：使用Jenkins DSL 31<br>节点 32<br>阶段 34<br>步骤 34<br>支持环境：开发一个流水线脚本 36<br>创建一个流水线项目 36<br>编辑器 38<br>使用代码片段生成器 39<br>运行一条流水线 43<br>回放 49<br>总结 52<br>第3章 流水线执行流程 53<br>触发任务 53<br>在其他项目构建后构建 54<br>周期性构建 54<br>使用GitHub钩子触发器进行GitSCM轮询 57<br>SCM轮询 57<br>静默期 58<br>远程触发构建 58<br>用户输入 58<br>输入 59<br>参数 62<br>多个输入参数的返回值 68<br>参数与声明式流水线 69<br>流程控制选项 74<br>超时（timeout） 74<br>重试（retry） 76<br>睡眠（sleep） 76<br>等待直到（waitUntil） 76<br>处理并发 78<br>使用lock步骤对资源加锁 78<br>使用milestone来控制并发构建 80<br>在多分支流水线中限制并发 82<br>并行地运行任务 82<br>有条件的执行功能 92<br>构建后处理 94<br>脚本式流水线构建后处理 94<br>声明式流水线与构建后处理 96<br>总结 97<br>第4章 通知与报告 99<br>通知 99<br>电子邮件 100<br>协作服务 110<br>报告 120<br>发布HTML报告 120<br>总结 123<br>第5章 访问与安全 125<br>安全加固Jenkins 125<br>启用安全性 126<br>其他全局安全配置 129<br>Jenkins中的凭证 133<br>凭证范围 134<br>凭证域 135<br>凭证提供者 135<br>凭证存储 136<br>管理凭证 136<br>选择凭证提供者 136<br>选择凭证类型 137<br>通过提供者指定凭证类型 138<br>创建和管理凭证 139<br>上下文链接 141<br>添加一个新域或者凭证 141<br>使用新域和凭证 144<br>高级凭证：基于角色的访问权限 145<br>基本用途 146<br>管理角色 147<br>分配角色 152<br>角色策略宏 155<br>在流水线中使用凭证 157<br>用户名和密码 157<br>SSH密钥 158<br>令牌凭证 159<br>控制脚本安全性 160<br>脚本检查 160<br>脚本批准 161<br>Groovy沙箱 162<br>Jenkins凭证与Vault配合使用 164<br>方法 164<br>安装 165<br>创建一个策略 165<br>身份验证 166<br>在Jenkins中使用Vault 168<br>总结 171<br>第6章 扩展你的流水线 173<br>可信库和不可信库 173<br>内部库与外部库 174<br>内部库 174<br>外部库 176<br>从代码仓库获取库 178<br>Modern SCM 178<br>Legacy SCM 178<br>在流水线脚本中使用库 179<br>从源码版本控制中自动下载库 180<br>加载库到脚本中 180<br>Jenkins项目中的库范围 182<br>库结构 183<br>样本库例程 183<br>共享库代码的结构 184<br>使用第三方库 195<br>直接加载代码 196<br>从外部SCM加载代码 196<br>回放外部代码和库 198<br>深入研究可信与不可信代码 200<br>总结 203<br>第7章 声明式流水线 205<br>动机 206<br>不直观 206<br>掌握Groovy 206<br>其他必需的装配 206<br>结构 207<br>代码块 208<br>部分 208<br>指令 209<br>步骤 209<br>条件 210<br>构建代码块 210<br>Pipeline 211<br>Agent 212<br>Environment 215<br>Tools 216<br>Options 219<br>Triggers 222<br>Parameters 224<br>Libraries 227<br>Stages 228<br>Post 231<br>处理非声明式的代码 232<br>检查你的插件 233<br>创建一个共享库 233<br>在pipeline代码块之外放置代码 233<br>script语句 234<br>在一个阶段中使用 parallel234<br>脚本检查与错误报告 235<br>声明式流水线与Blue Ocean接口 238<br>总结 238<br>第8章 理解项目类型 241<br>通用项目选项 241<br>基础设置 241<br>源码管理 247<br>构建触发器 249<br>构建环境 256<br>构建 266<br>构建后操作 266<br>项目类型 266<br>自由风格类型项目 267<br>Maven项目类型 267<br>流水线项目类型 270<br>外部任务项目类型 272<br>多配置项目类型 275<br>Ivy项目 280<br>文件夹 282<br>多分支流水线项目 287<br>GitHub组织项目 292<br>Bitbucket团队&#x2F;项目 296<br>总结 299<br>第9章 Blue Ocean用户界面 301<br>第一部分：管理已有的流水线 302<br>主界面 302<br>项目详情页面 305<br>运行页面 316<br>第二部分：使用Blue Ocean编辑器 325<br>不依赖现有Jenkinsfile创建一个全新的流水线 326<br>使用编辑器 330<br>编辑已有的流水线 340<br>导入和编辑已有的流水线 344<br>使用非GitHub仓库支持流水线 354<br>总结 356<br>第10章 转换 357<br>通用的准备 358<br>逻辑和准确性 358<br>项目类型 358<br>系统 358<br>访问 358<br>全局配置 359<br>插件 359<br>共享库 359<br>将自由风格类型的流水线转换为脚本式流水线 360<br>源码 364<br>编译 369<br>单元测试 373<br>集成测试 377<br>迁移流水线接下来的部分 380<br>从Jenkins流水线项目转换为Jenkinsfile 385<br>方法 388<br>最后的步骤 395<br>从脚本式流水线转换为声明式流水线 397<br>样本流水线 397<br>转换 399<br>完成转换 402<br>可用于转换的通用指南 403<br>总结 405<br>第11章 操作系统环境集成（shell、工作空间、环境和文件） 407<br>使用shell的步骤 407<br>sh步骤 408<br>bat步骤 413<br>powershell步骤 414<br>使用环境变量 415<br>withEnv步骤 416<br>使用工作空间 418<br>创建自定义工作空间 418<br>清理工作空间 420<br>文件和目录步骤 422<br>使用文件 422<br>使用目录 423<br>使用文件和目录的更多操作 424<br>总结 425<br>第12章 集成分析工具 427<br>SonarQube调查 427<br>使用个人规则 428<br>质量门和配置文件 432<br>扫描程序 434<br>将SonarQube与Jenkins一起使用 434<br>全局配置 434<br>在自由风格类型项目中使用SonarQube 436<br>在流水线项目中使用SonarQube 436<br>利用SonarQube分析的结果 437<br>在Jenkins中集成SonarQube的输出 441<br>代码覆盖率：与JaCoCo集成 442<br>关于JaCoCo 442<br>JaCoCo与流水线集成 443<br>在Jenkins中集成JaCoCo的输出 445<br>总结 446<br>第13章 集成制品管理 447<br>发布和获取制品 447<br>安装和全局配置 448<br>在脚本式流水线中使用Artifactory 449<br>执行其他任务 454<br>下载指定文件到指定目录 454<br>上传指定文件到指定路径 454<br>设置构建保留策略 455<br>构建提升 455<br>声明式流水线集成 455<br>Artifactory与Jenkins输出集成 456<br>制品归档和指纹 457<br>总结 462<br>第14章 集成容器 465<br>配置成一个云 465<br>全局配置 466<br>使用Docker镜像作为代理节点 469<br>在流水线中使用云镜像 473<br>在声明式流水线中动态创建的代理节点 477<br>Docker流水线全局变量 480<br>全局变量 480<br>Docker应用全局变量方法 481<br>Docker镜像全局变量方法 487<br>Docker容器全局变量方法 491<br>通过shell运行Docker 492<br>总结 493<br>第15章 其他接口 495<br>使用命令行接口 496<br>直接使用SSH接口 496<br>使用CLI客户端 499<br>使用Jenkins REST API 501<br>过滤结果 502<br>启动构建 504<br>使用脚本控制台 506<br>总结 508<br>第16章 故障处理 509<br>深入流水线步骤 509<br>处理序列化错误 512<br>连续传递风格 513<br>序列化流水线 513<br>NotSerializableException 513<br>处理非序列化错误 514<br>识别引发错误的脚本行 517<br>处理流水线异常 518<br>在声明式流水线中使用非声明式代码 518<br>未授权代码（脚本和方法授权） 522<br>不支持的操作 523<br>系统日志 523<br>时间戳 525<br>流水线耐用性设置 526<br>总结 527<br>关于作者 529<br>封面介绍 529<br>关于译者 530</p><h3 id="Jenkins-2权威指南-PDF-下载"><a href="#Jenkins-2权威指南-PDF-下载" class="headerlink" title="Jenkins 2权威指南 PDF 下载"></a>Jenkins 2权威指南 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1MjjGZ16iWq4MthUmeOe7uw?pwd=cg1r">https://pan.baidu.com/s/1MjjGZ16iWq4MthUmeOe7uw?pwd=cg1r</a> </p><p>提取码：cg1r</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kong网关：入门、实战与进阶》</title>
      <link href="/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/9873662DB6DD82154A4484E46FD188A3.png" alt="《Kong网关：入门、实战与进阶》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>这是一本关于Kong网关开发和运维的集大成之作。作者基于自己在该领域的丰富实践经验，从零开始，不仅循序渐进地讲解了Kong网关的核心概念、使用方法、工作原理、工程实践和源码，而且还将微服务设计、分布式架构、DevOps等相关技术融入其中，帮助读者打通Kong网关的整个技术体系，轻松跨越从理论到项目实战的鸿沟。</p><p>全书共16章，分为4篇，具体内容如下。</p><p>入门篇（第1~4章）</p><p>首先对网关层和Kong网关做了整体性介绍，然后有针对性地讲解了Nginx、OpenResty和Lua语言等必备知识，为之后深入学习打下基础。</p><p>基础篇（第5~8章）</p><p>这部分围绕Kong网关的日常配置和操作展开，具体包括Kong网关配置文件、部署方案、命令行向导、代理、鉴权、负载均衡策略和健康检查机制等内容。</p><p>进阶篇（第9~12章）</p><p>主要介绍了Kong网关区别于其他传统网关的插件机制，以及Kong网关在整个架构体系中与其他系统之间的交互和联动。</p><p>应用篇（第13~16章）</p><p>主要结合当前日益成熟的云原生环境，给出Kong网关在不同场景下的整体解决方案，如与微服务、Service Mesh、Kubernetes、Serverless的结合等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>孔庆雍</p><p>毕业于同济大学，曾就职于华为、中国移动、数禾科技等多家公司，任职期间参与了多个大型系统设计、研发工作。现任上海珞瑾数据信息有限公司CTO、首席架构师，在现公司主导了内部自研DevOps平台的搭建及底层架构设计与规划。敏捷开发思想践行者，擅长利用技术推进项目管理与产品交付。</p><p>在企业级SaaS服务、大规模分布式架构、微服务治理、网关层设计研发等领域积累了丰富的经验，在现公司主导研发的酒店管理系统已累计覆盖10万家门店，日均请求量超1亿。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>入门篇<br>第1章 全面了解Kong网关 2<br>1.1 网关简介 2<br>1.1.1 网关的由来 3<br>1.1.2 网关的作用 3<br>1.2 Kong网关简介 6<br>1.2.1 Kong网关的发展历程 6<br>1.2.2 Kong网关与传统网关对比 6<br>1.2.3 其他主流网关 7<br>1.3 Kong网关基础组件 12<br>1.3.1 Kong服务器 12<br>1.3.2 数据库 13<br>1.3.3 Kong管理GUI 14<br>1.4 Kong网关安装指南 14<br>1.4.1 在Mac环境中安装Kong网关 15<br>1.4.2 在Linux环境中安装Kong网关 15<br>1.4.3 在Docker环境中安装Kong网关 15<br>1.5 使用Kong网关搭建Web应用 16<br>1.5.1 示例项目介绍 16<br>1.5.2 后端服务路由 18<br>1.5.3 静态页面代理 20<br>1.6 本章小结 24<br>第2章 Nginx必备知识 25<br>2.1 Nginx安装 25<br>2.1.1 在Mac环境中安装Nginx 25<br>2.1.2 在Linux环境中安装Nginx 26<br>2.1.3 在Docker环境中安装Nginx 26<br>2.2 Nginx详解 26<br>2.2.1 Nginx文件的目录结构 26<br>2.2.2 命令行参数 28<br>2.2.3 配置文件 29<br>2.2.4 依赖库 32<br>2.2.5 Nginx的工作原理 33<br>2.2.6 Nginx优化指南 35<br>2.3 项目实践 37<br>2.3.1 从Kong切换到Nginx 37<br>2.3.2 添加黑白名单 39<br>2.3.3 添加限流 39<br>2.3.4 从Nginx切换到Kong 41<br>2.3.5 小结 41<br>2.4 本章小结 42<br>第3章 Lua必备知识 43<br>3.1 Lua入门与规范 43<br>3.1.1 基础知识 43<br>3.1.2 安装指南 44<br>3.1.3 解释器 45<br>3.1.4 语法规范 46<br>3.2 数据类型 47<br>3.3 操作符 52<br>3.4 表达式语句 54<br>3.4.1 赋值语句 54<br>3.4.2 控制语句 55<br>3.5 Lua库 58<br>3.6 本章小结 62<br>第4章 OpenResty必备知识 63<br>4.1 OpenResty入门安装 63<br>4.1.1 在Mac环境中安装OpenResty 63<br>4.1.2 在Linux环境中安装OpenResty 64<br>4.1.3 在Docker环境中安装OpenResty 64<br>4.2 OpenResty详解 64<br>4.2.1 OpenResty服务器的目录结构 64<br>4.2.2 Resty CLI 65<br>4.2.3 OpenResty包管理工具 67<br>4.3 OpenResty工作原理 69<br>4.4 OpenResty性能优化 71<br>4.4.1 避免使用阻塞函数 72<br>4.4.2 巧用table组件 72<br>4.4.3 使用缓存 73<br>4.4.4 火焰图 73<br>4.5 项目实践 75<br>4.6 本章小结 82<br>基础篇<br>第5章 Kong网关配置与部署 84<br>5.1 Kong启动项配置 84<br>5.1.1 配置项加载流程 85<br>5.1.2 配置项详解 86<br>5.1.3 环境变量 89<br>5.1.4 配置文件示例 89<br>5.2 注入Nginx指令 90<br>5.2.1 注入单个Nginx指令 91<br>5.2.2 通过文件方式注入Nginx指令 92<br>5.3 个性化使用场景 92<br>5.3.1 自定义Nginx模板文件 93<br>5.3.2 在OpenResty实例中嵌入Kong 93<br>5.4 Kong网关部署 94<br>5.4.1 无数据库部署模式 94<br>5.4.2 数据库部署模式 97<br>5.4.3 混合部署模式 100<br>5.5 本章小结 102<br>第6章 Kong网关命令行 103<br>6.1 通用标志参数 104<br>6.2 Kong网关命令行详解 104<br>6.2.1 kong check 104<br>6.2.2 kong config 106<br>6.2.3 kong health 109<br>6.2.4 kong hybrid 109<br>6.2.5 kong migrations 110<br>6.2.6 kong prepare 112<br>6.2.7 kong quit 113<br>6.2.8 kong reload 113<br>6.2.9 kong restart 114<br>6.2.10 kong start 114<br>6.2.11 kong stop 115<br>6.2.12 kong version 116<br>6.3 本章小结 116<br>第7章 Kong网关代理及鉴权 117<br>7.1 Kong网关代理基础知识 117<br>7.1.1 Kong网关术语简介 117<br>7.1.2 Kong网关代理环境配置 118<br>7.2 Kong网关代理示例 118<br>7.3 路由匹配规则 121<br>7.3.1 通用匹配规则 121<br>7.3.2 paths属性 123<br>7.3.3 hosts属性 126<br>7.3.4 methods属性 128<br>7.3.5 headers属性（hosts除外） 129<br>7.3.6 sources &amp; destinations属性 129<br>7.3.7 snis属性 129<br>7.4 路由匹配优先级 130<br>7.4.1 优先级策略 130<br>7.4.2 后备路由策略 131<br>7.5 Kong网关代理行为 132<br>7.5.1 超时机制 132<br>7.5.2 错误重试机制 133<br>7.5.3 插件执行策略 133<br>7.5.4 响应内容 133<br>7.6 配置SSL协议 134<br>7.7 代理WebSocket流量 135<br>7.8 代理gRPC流量 138<br>7.9 Kong网关鉴权 140<br>7.9.1 通用鉴权流程 140<br>7.9.2 匿名接入流程 142<br>7.9.3 多重认证策略 143<br>7.10 本章小结 144<br>第8章 Kong网关负载均衡策略与健康检查 145<br>8.1 负载均衡 145<br>8.1.1 负载均衡简介 145<br>8.1.2 负载均衡解决方案 146<br>8.1.3 Kong网关中的负载均衡 146<br>8.2 基于DNS的负载均衡 146<br>8.2.1 A记录（包含AAAA记录） 147<br>8.2.2 SRV记录 147<br>8.2.3 DNS 记录优先级 147<br>8.2.4 其他注意事项 148<br>8.3 环状负载均衡器 148<br>8.3.1 基础概念 148<br>8.3.2 负载均衡策略 150<br>8.3.3 其他注意事项 151<br>8.4 负载均衡特性使用场景 151<br>8.4.1 蓝绿发布 151<br>8.4.2 金丝雀发布 155<br>8.5 健康检查 157<br>8.5.1 健康检查标准 157<br>8.5.2 健康检查类型 159<br>8.5.3 健康检查配置 160<br>8.6 本章小结 162<br>进阶篇<br>第9章 Kong网关插件 164<br>9.1 Kong网关插件简介 164<br>9.1.1 Kong网关插件概念 164<br>9.1.2 Kong网关插件原理 165<br>9.2 Kong官方插件 166<br>9.2.1 鉴权类插件 166<br>9.2.2 安全类插件 177<br>9.2.3 流量类插件 179<br>9.2.4 分析监控类插件 195<br>9.2.5 内容转换类插件 197<br>9.2.6 日志类插件 204<br>9.2.7 其他插件 210<br>9.3 自定义Kong网关插件 210<br>9.3.1 自定义插件开发流程和插件生命周期管理详解 210<br>9.3.2 插件开发套件 240<br>9.3.3 Go插件开发向导 241<br>9.3.4 自定义插件实例 243<br>9.4 本章小结 245<br>第10章 Kong网关日志 246<br>10.1 Kong网关日志简介 246<br>10.1.1 Kong网关日志分类 246<br>10.1.2 Kong网关日志级别 248<br>10.2 Kong网关结合日志平台 249<br>10.2.1 ELK方案简介 249<br>10.2.2 Kong网关结合ELK 253<br>10.2.3 日志系统使用场景 256<br>10.3 自定义日志 261<br>10.3.1 Kong网关定制日志 262<br>10.3.2 ELK定制日志 264<br>10.3.3 小结 265<br>10.4 本章小结 266<br>第11章 Kong网关运维 267<br>11.1 资源选型 267<br>11.1.1 服务器资源 267<br>11.1.2 数据库资源 268<br>11.1.3 弹性伸缩 269<br>11.1.4 性能参数 269<br>11.2 Kong网关监控 270<br>11.2.1 监控平台选型 270<br>11.2.2 搭建监控平台 271<br>11.2.3 Kong网关监控平台配置 272<br>11.2.4 Kong网关监控平台指标详解 278<br>11.2.5 Kong监控平台指标测试 279<br>11.2.6 Kong监控平台的预警功能 281<br>11.3 Kong网关运维 284<br>11.3.1 数据备份 284<br>11.3.2 软&#x2F;硬件维护 286<br>11.3.3 突发事件处理 288<br>11.4 本章小结 288<br>第12章 Kong网关安全与集群高可用 289<br>12.1 Kong网关安全配置 289<br>12.1.1 网络层访问限制 289<br>12.1.2 Kong API 回路 290<br>12.1.3 自定义Nginx配置 291<br>12.2 Kong集群 292<br>12.2.1 Kong集群简介 292<br>12.2.2 Kong集群缓存 293<br>12.3 Kong网关高可用 298<br>12.3.1 架构设计 298<br>12.3.2 引入HAProxy层 300<br>12.3.3 高可用方案测试 301<br>12.4 本章小结 308<br>应用篇<br>第13章 Kong网关结合微服务架构 310<br>13.1 微服务简介 310<br>13.1.1 微服务的优点 311<br>13.1.2 单体应用和微服务 311<br>13.1.3 微服务12要素 313<br>13.2 单体应用向微服务迁移 313<br>13.2.1 采用微服务的注意事项 314<br>13.2.2 迁移细节 314<br>13.3 使用CI&#x2F;CD流程促进微服务开发 316<br>13.3.1 CI&#x2F;CD流程基础组件 316<br>13.3.2 构建CI&#x2F;CD流程 318<br>13.4 基于Kong打造DevOps平台 320<br>13.4.1 场景描述 320<br>13.4.2 设计思路 321<br>13.4.3 DevOps平台使用指南 325<br>13.4.4 DevOps平台源码解析 329<br>13.4.5 DevOps平台扩展 335<br>13.5 本章小结 336<br>第14章 Kong网关结合Kubernetes架构方案 337<br>14.1 Kubernetes详解 337<br>14.1.1 Kubernetes简介 337<br>14.1.2 Kubernetes发展史 338<br>14.1.3 Kubernetes基本概念和术语 340<br>14.1.4 Kubernetes的HelloWorld示例 342<br>14.2 Kubernetes与Kong网关结合 350<br>14.2.1 概念描述 350<br>14.2.2 使用Kubernetes安装Kong 358<br>14.3 Kubernetes实战 359<br>14.3.1 安装Kong网关 359<br>14.3.2 使用Kong网关 360<br>14.3.3 配置Kong网关插件 361<br>14.4 本章小结 363<br>第15章 Service Mesh实践之Kuma 364<br>15.1 Service Mesh简介 364<br>15.2 Kuma简介 366<br>15.2.1 为什么使用Kuma 366<br>15.2.2 Kuma与其他Service Mesh方案的比较 366<br>15.2.3 Kuma系统组件 367<br>15.2.4 Kuma部署示例 368<br>15.3 Kuma策略概述 369<br>15.3.1 策略配置项描述 369<br>15.3.2 使用策略 370<br>15.3.3 策略匹配规则 371<br>15.4 Kuma内置策略详解 372<br>15.4.1 安全类策略 372<br>15.4.2 流量控制类策略 376<br>15.4.3 观测类策略 382<br>15.5 Kuma实战 388<br>15.5.1 适配Kuma架构 388<br>15.5.2 启动mTSL和TrafficPermission 390<br>15.6 本章小结 391<br>第16章 Serverless架构 392<br>16.1 Serverless简介 392<br>16.1.1 系统架构演化 392<br>16.1.2 部署方式演化 393<br>16.1.3 Serverless内核 395<br>16.2 Serverless实践 396<br>16.2.1 搭建开发环境 396<br>16.2.2 Web应用服务 402<br>16.3 本章小结 407<br>附录A Docker安装指南 408<br>附录B KONGA安装指南 412<br>附录C 数据库明细 417<br>附录D Admin API 422</p><h3 id="Kong网关：入门、实战与进阶-PDF-下载"><a href="#Kong网关：入门、实战与进阶-PDF-下载" class="headerlink" title="Kong网关：入门、实战与进阶 PDF 下载"></a>Kong网关：入门、实战与进阶 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1aSmiqNJZzFwMUko0RAIeZA?pwd=ox4u">https://pan.baidu.com/s/1aSmiqNJZzFwMUko0RAIeZA?pwd=ox4u</a> </p><p>提取码：ox4u</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Kong </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python编程：从入门到实践》</title>
      <link href="/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/031C7413E5CDC918603FDAB290074F33.png" alt="《Python编程：从入门到实践》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是针对所有层次Python读者而作的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括Matplotlib等强大的Python库和工具，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的2D游戏、利用数据生成交互式的信息图以及创建和定制简单的Web应用，并帮助读者解决常见编程问题和困惑。第2版进行了全面修订，简化了Python安装流程，新增了f字符串、get()方法等内容，并且在项目中使用了Plotly库以及新版本的Django和Bootstrap，等等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>埃里克·马瑟斯（Eric Matthes）</p><p>高中科学和数学老师，现居住在阿拉斯加，在当地讲授Python入门课程。他从5岁开始就一直在编写程序。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 基础知识<br>第1章 起步　　2<br>1.1 搭建编程环境　　2<br>1.1.1 Python版本　　2<br>1.1.2 运行Python代码片段　　2<br>1.1.3 Sublime Text简介　　3<br>1.2 在不同操作系统中搭建Python编程环境　　3<br>1.2.1 在Windows系统中搭建Python编程环境　　4<br>1.2.2 在macOS系统中搭建Python编程环境　　5<br>1.2.3 在Linux 系统中搭建Python编程环境　　7<br>1.3 运行Hello World 程序　　8<br>1.3.1 配置Sublime Text以使用正确的Python版本　　8<br>1.3.2 运行程序hello_world.py　　8<br>1.4 解决安装问题　　9<br>1.5 从终端运行Python程序　　9<br>1.5.1 在Windows系统中从终端运行Python 程序　　10<br>1.5.2 在Linux和macOS系统中从终端运行Python程序　　10<br>1.6 小结　　11<br>第2章 变量和简单数据类型　　12<br>2.1 运行hello_world.py时发生的情况　　12<br>2.2 变量　　13<br>2.2.1 变量的命名和使用　　13<br>2.2.2 使用变量时避免命名错误　　14<br>2.2.3 变量是标签　　15<br>2.3 字符串　　16<br>2.3.1 使用方法修改字符串的大小写　　17<br>2.3.3 使用制表符或换行符来添加空白　　18<br>2.3.4 删除空白　　19<br>2.3.5 使用字符串时避免语法错误　　20<br>2.4 数　　21<br>2.4.1 整数　　22<br>2.4.2 浮点数　　22<br>2.4.3 整数和浮点数　　23<br>2.4.4 数中的下划线　　23<br>2.4.5 同时给多个变量赋值　　24<br>2.4.6 常量　　24<br>2.5 注释　　25<br>2.5.1 如何编写注释　　25<br>2.5.2 该编写什么样的注释　　25<br>2.6 Python之禅　　26<br>2.7 小结　　27<br>第3章 列表简介　　28<br>3.1 列表是什么　　28<br>3.1.1 访问列表元素　　29<br>3.1.2 索引从0而不是1开始　　29<br>3.1.3 使用列表中的各个值　　30<br>3.2 修改、添加和删除元素　　31<br>3.2.1 修改列表元素　　31<br>3.2.2 在列表中添加元素　　31<br>3.2.3 从列表中删除元素　　32<br>3.3 组织列表　　36<br>3.3.1 使用方法sort()对列表永久排序　　37<br>3.3.2 使用函数sorted()对列表临时排序　　37<br>3.3.3 倒着打印列表　　38<br>3.3.4 确定列表的长度　　38<br>3.4 使用列表时避免索引错误　　39<br>3.5 小结　　41<br>第4章 操作列表　　42<br>4.1 遍历整个列表　　42<br>4.1.1 深入研究循环　　43<br>4.1.2 在for 循环中执行更多操作　　44<br>4.1.3 在for 循环结束后执行一些操作　　45<br>4.2 避免缩进错误　　45<br>4.2.1 忘记缩进　　46<br>4.2.2 忘记缩进额外的代码行　　46<br>4.2.3 不必要的缩进　　47<br>4.2.4 循环后不必要的缩进　　47<br>4.2.5 遗漏了冒号　　48<br>4.3 创建数值列表　　49<br>4.3.1 使用函数range()　　49<br>4.3.2 使用range()创建数字列表　　50<br>4.3.3 对数字列表执行简单的统计计算　　51<br>4.3.4 列表解析　　52<br>4.4 使用列表的一部分　　53<br>4.4.1 切片　　53<br>4.4.2 遍历切片　　54<br>4.4.3 复制列表　　55<br>4.5 元组　　57<br>4.5.1 定义元组　　57<br>4.5.2 遍历元组中的所有值　　58<br>4.5.3 修改元组变量　　59<br>4.6 设置代码格式　　60<br>4.6.1 格式设置指南　　60<br>4.6.2 缩进　　60<br>4.6.3 行长　　60<br>4.6.4 空行　　61<br>4.6.5 其他格式设置指南　　61<br>4.7 小结　　62<br>第5章 if语句　　63<br>5.1 一个简单示例　　63<br>5.2 条件测试　　64<br>5.2.1 检查是否相等　　64<br>5.2.2 检查是否相等时忽略大小写　　64<br>5.2.3 检查是否不相等　　65<br>5.2.4 数值比较　　66<br>5.2.5 检查多个条件　　66<br>5.2.6 检查特定值是否包含在列表中　　68<br>5.2.8 布尔表达式　　68<br>5.3 if语句　　69<br>5.3.1 简单的if语句　　69<br>5.3.2 if-else语句　　70<br>5.3.3 if-elif-else结构　　71<br>5.3.4 使用多个elif代码块　　72<br>5.3.5 省略else代码块　　73<br>5.3.6 测试多个条件　　73<br>5.4 使用if语句处理列表　　76<br>5.4.1 检查特殊元素　　76<br>5.4.2 确定列表不是空的　　77<br>5.4.3 使用多个列表　　77<br>5.5 设置if语句的格式　　79<br>5.6 小结　　80<br>第6章 字典　　81<br>6.1 一个简单的字典　　81<br>6.2 使用字典　　82<br>6.2.1 访问字典中的值　　82<br>6.2.2 添加键值对　　83<br>6.2.3 先创建一个空字典　　83<br>6.2.4 修改字典中的值　　84<br>6.2.5 删除键值对　　85<br>6.2.6 由类似对象组成的字典　　86<br>6.2.7 使用get()来访问值　　87<br>6.3 遍历字典　　88<br>6.3.1 遍历所有键值对　　88<br>6.3.2 遍历字典中的所有键　　90<br>6.3.3 按特定顺序遍历字典中的所有键　　92<br>6.3.4 遍历字典中的所有值　　92<br>6.4 嵌套　　94<br>6.4.1 字典列表　　94<br>6.4.2 在字典中存储列表　　97<br>6.4.3 在字典中存储字典　　98<br>6.5 小结　　100<br>第7章 用户输入和while循环　　101<br>7.1 函数input()的工作原理　　101<br>7.1.1 编写清晰的程序　　102<br>7.1.2 使用int()来获取数值输入　　102<br>7.1.3 求模运算符　　104<br>7.2 while循环简介　　105<br>7.2.1 使用while循环　　105<br>7.2.2 让用户选择何时退出　　105<br>7.2.3 使用标志　　107<br>7.2.4 使用break退出循环　　108<br>7.2.5 在循环中使用continue　　109<br>7.2.6 避免无限循环　　109<br>7.3 使用while循环处理列表和字典　　111<br>7.3.1 在列表之间移动元素　　111<br>7.3.2 删除为特定值的所有列表元素　　112<br>7.3.3 使用用户输入来填充字典　　112<br>7.4 小结　　114<br>第8章 函数　　115<br>8.1 定义函数　　115<br>8.1.1 向函数传递信息　　116<br>8.1.2 实参和形参　　116<br>8.2 传递实参　　117<br>8.2.1 位置实参　　117<br>8.2.2 关键字实参　　119<br>8.2.3 默认值　　119<br>8.2.4 等效的函数调用　　120<br>8.2.5 避免实参错误　　121<br>8.3 返回值　　122<br>8.3.1 返回简单值　　122<br>8.3.2 让实参变成可选的　　123<br>8.3.3 返回字典　　124<br>8.3.4 结合使用函数和while循环　　125<br>8.4 传递列表　　127<br>8.4.1 在函数中修改列表　　128<br>8.4.2 禁止函数修改列表　　130<br>8.5 传递任意数量的实参　　131<br>8.5.1 结合使用位置实参和任意数量实参　　132<br>8.5.2 使用任意数量的关键字实参　　134<br>8.6.1 导入整个模块　　134<br>8.6.2 导入特定的函数　　135<br>8.6.3 使用as给函数指定别名　　136<br>8.6.4 使用as给模块指定别名　　136<br>8.6.5 导入模块中的所有函数　　137<br>8.7 函数编写指南　　137<br>8.8 小结　　138<br>第9章 类　　140<br>9.1 创建和使用类　　140<br>9.1.1 创建Dog类　　141<br>9.1.2 根据类创建实例　　142<br>9.2 使用类和实例　　144<br>9.2.1 Car类　　145<br>9.2.2 给属性指定默认值　　145<br>9.2.3 修改属性的值　　146<br>9.3 继承　　149<br>9.3.1 子类的方法__init__()　　149<br>9.3.2 给子类定义属性和方法　　151<br>9.3.3 重写父类的方法　　152<br>9.3.4 将实例用作属性　　152<br>9.3.5 模拟实物　　154<br>9.4 导入类　　155<br>9.4.1 导入单个类　　155<br>9.4.2 在一个模块中存储多个类　　157<br>9.4.3 从一个模块中导入多个类　　158<br>9.4.4 导入整个模块　　158<br>9.4.5 导入模块中的所有类　　159<br>9.4.6 在一个模块中导入另一个模块　　159<br>9.4.7 使用别名　　160<br>9.4.8 自定义工作流程　　160<br>9.5 Python标准库　　161<br>9.6 类编码风格　　162<br>9.7 小结　　163<br>第10章 文件和异常　　164<br>10.1 从文件中读取数据　　164<br>10.1.1 读取整个文件　　164<br>10.1.2 文件路径　　166<br>10.1.3 逐行读取　　167<br>10.1.4 创建一个包含文件各行内容的列表　　168<br>10.1.5 使用文件的内容　　168<br>10.1.6 包含一百万位的大型文件　　170<br>10.2 写入文件　　171<br>10.2.1 写入空文件　　171<br>10.2.2 写入多行　　172<br>10.2.3 附加到文件　　173<br>10.3 异常　　174<br>10.3.1 处理ZeroDivisionError异常　　174<br>10.3.2 使用try-except 代码块　　174<br>10.3.3 使用异常避免崩溃　　175<br>10.3.4 else代码块　　176<br>10.3.5 处理FileNotFoundError异常　　177<br>10.3.6 分析文本　　178<br>10.3.7 使用多个文件　　179<br>10.3.8 静默失败　　180<br>10.3.9 决定报告哪些错误　　181<br>10.4 存储数据　　182<br>10.4.1 使用json.dump()和json.load()　　182<br>10.4.2 保存和读取用户生成的数据　　183<br>10.4.3 重构　　185<br>10.5 小结　　187<br>第11章 测试代码　　188<br>11.1 测试函数　　188<br>11.1.1 单元测试和测试用例　　189<br>11.1.2 可通过的测试　　189<br>11.1.3 未通过的测试　　191<br>11.1.4 测试未通过时怎么办　　192<br>11.1.5 添加新测试　　193<br>11.2 测试类　　194<br>11.2.1 各种断言方法　　194<br>11.2.2 一个要测试的类　　195<br>11.2.3 测试AnonymousSurvey类　　197<br>11.2.4 方法setUp()　　198<br>11.3 小结　　200<br>第二部分 项 目<br>项目1 外星人入侵　　202<br>第12章 武装飞船　　203<br>12.1 规划项目　　203<br>12.2 安装Pygame　　204<br>12.3 开始游戏项目　　204<br>12.3.1 创建Pygame窗口及响应用户输入　　204<br>12.3.2 设置背景色　　206<br>12.3.3 创建设置类　　207<br>12.4 添加飞船图像　　208<br>12.4.1 创建Ship类　　209<br>12.4.2 在屏幕上绘制飞船　　210<br>12.5 重构：方法_check_events()和__update_screen()　　211<br>12.5.1 方法_check_events()　　211<br>12.5.2 方法_update_screen()　　212<br>12.6 驾驶飞船　　213<br>12.6.1 响应按键　　213<br>12.6.2 允许持续移动　　214<br>12.6.3 左右移动　　215<br>12.6.4 调整飞船的速度　　216<br>12.6.5 限制飞船的活动范围　　218<br>12.6.6 重构_check_events()　　218<br>12.6.7 按Q键退出　　219<br>12.6.8 在全屏模式下运行游戏　　219<br>12.7 简单回顾　　220<br>12.7.1 alien_invasion.py　　220<br>12.7.2 settings.py　　220<br>12.7.3 ship.py　　220<br>12.8 射击　　221<br>12.8.1 添加子弹设置　　221<br>12.8.2 创建Bullet类　　221<br>12.8.3 将子弹存储到编组中　　223<br>12.8.4 开火　　223<br>12.8.5 删除消失的子弹　　225<br>12.8.6 限制子弹数量　　225<br>12.8.7 创建方法_update_bullets()　　227<br>第13章 外星人来了　　228<br>13.1 项目回顾　　228<br>13.2 创建第一个外星人　　229<br>13.2.1 创建Alien类　　229<br>13.2.2 创建Alien实例　　230<br>13.3 创建一群外星人　　232<br>13.3.1 确定一行可容纳多少个外星人　　232<br>13.3.2 创建一行外星人　　232<br>13.3.3 重构_create_fleet()　　234<br>13.3.4 添加行　　234<br>13.4 让外星人群移动　　237<br>13.4.1 向右移动外星人群　　237<br>13.4.2 创建表示外星人移动方向的设置　　238<br>13.4.3 检查外星人是否撞到了屏幕边缘　　238<br>13.4.4 向下移动外星人群并改变移动方向　　239<br>13.5 射杀外星人　　240<br>13.5.1 检测子弹与外星人的碰撞　　241<br>13.5.3 生成新的外星人群　　242<br>13.5.4 提高子弹的速度　　243<br>13.5.5 重构_update_bullets()　　243<br>13.6 结束游戏　　244<br>13.6.1 检测外星人和飞船碰撞　　244<br>13.6.2 响应外星人和飞船碰撞　　245<br>13.6.3 有外星人到达屏幕底端　　247<br>13.6.4 游戏结束　　248<br>13.7 确定应运行游戏的哪些部分　　248<br>13.8 小结　　249<br>第14章 记分　　250<br>14.1 添加Play按钮　　250<br>14.1.1 创建Button类　　250<br>14.1.2 在屏幕上绘制按钮　　252<br>14.1.3 开始游戏　　253<br>14.1.4 重置游戏　　254<br>14.1.5 将Play按钮切换到非活动状态　　254<br>14.1.6 隐藏鼠标光标　　255<br>14.2 提高等级　　256<br>14.2.1 修改速度设置　　256<br>14.2.2 重置速度　　258<br>14.3 记分　　258<br>14.3.1 显示得分　　259<br>14.3.2 创建记分牌　　260<br>14.3.3 在外星人被消灭时更新得分　　261<br>14.3.4 重置得分　　262<br>14.3.5 将消灭的每个外星人都计入得分　　262<br>14.3.6 提高分数　　263<br>14.3.7 舍入得分　　264<br>14.3.8 最高得分　　265<br>14.3.9 显示等级　　267<br>14.3.10 显示余下的飞船数　　269<br>14.4 小结　　272<br>项目2 数据可视化　　273<br>第15章 生成数据　　274<br>15.1 安装Matplotlib　　274<br>15.2 绘制简单的折线图　　275<br>15.2.1 修改标签文字和线条粗细　　277<br>15.2.3 使用内置样式　　278<br>15.2.4 使用scatter()绘制散点图并设置样式　　279<br>15.2.5 使用scatter()绘制一系列点　　280<br>15.2.6 自动计算数据　　281<br>15.2.7 自定义颜色　　282<br>15.2.8 使用颜色映射　　283<br>15.2.9 自动保存图表　　284<br>15.3 随机漫步　　284<br>15.3.1 创建RandomWalk类　　284<br>15.3.2 选择方向　　285<br>15.3.3 绘制随机漫步图　　286<br>15.3.4 模拟多次随机漫步　　287<br>15.3.5 设置随机漫步图的样式　　288<br>15.4 使用Plotly模拟掷骰子　　292<br>15.4.1 安装Plotly　　292<br>15.4.2 创建Die类　　293<br>15.4.3 掷骰子　　293<br>15.4.4 分析结果　　294<br>15.4.5 绘制直方图　　294<br>15.4.6 同时掷两个骰子　　296<br>15.4.7 同时掷两个面数不同的骰子　　298<br>15.5 小结　　300<br>第16章 下载数据　　301<br>16.1 CSV文件格式　　301<br>16.1.1 分析CSV文件头　　302<br>16.1.2 打印文件头及其位置　　302<br>16.1.3 提取并读取数据　　303<br>16.1.4 绘制温度图表　　304<br>16.1.5 模块datetime　　305<br>16.1.6 在图表中添加日期　　306<br>16.1.7 涵盖更长的时间　　307<br>16.1.8 再绘制一个数据系列　　308<br>16.1.9 给图表区域着色　　309<br>16.1.10 错误检查　　310<br>16.1.11 自己动手下载数据　　313<br>16.2 制作全球地震散点图：JSON格式　　315<br>16.2.2 查看JSON数据　　315<br>16.2.3 创建地震列表　　317<br>16.2.4 提取震级　　317<br>16.2.5 提取位置数据　　318<br>16.2.6 绘制震级散点图　　319<br>16.2.7 另一种指定图表数据的方式　　320<br>16.2.8 定制标记的尺寸　　321<br>16.2.9 定制标记的颜色　　322<br>16.2.10 其他渐变　　323<br>16.2.11 添加鼠标指向时显示的文本　　324<br>16.3 小结　　325<br>第17章 使用API　　326<br>17.1 使用Web API　　326<br>17.1.1 Git 和GitHub　　326<br>17.1.2 使用API调用请求数据　　327<br>17.1.3 安装Requests　　327<br>17.1.4 处理API响应　　328<br>17.1.5 处理响应字典　　329<br>17.1.6 概述最受欢迎的仓库　　331<br>17.1.7 监视API的速率限制　　332<br>17.2 使用Plotly可视化仓库　　332<br>17.2.1 改进Plotly图表　　334<br>17.2.2 添加自定义工具提示　　336<br>17.2.3 在图表中添加可单击的链接　　337<br>17.2.4 深入了解Plotly和GitHub API　　338<br>17.3 Hacker News API　　338<br>17.4 小结　　341<br>项目3 Web 应用程序　　342<br>第18章 从Django 入手　　343<br>18.1 建立项目　　343<br>18.1.1 制定规范　　343<br>18.1.2 建立虚拟环境　　344<br>18.1.3 激活虚拟环境　　344<br>18.1.4 安装Django　　345<br>18.1.5 在Django中创建项目　　345<br>18.1.6 创建数据库　　346<br>18.1.7 查看项目　　346<br>18.2 创建应用程序　　348<br>18.2.1 定义模型　　348<br>18.2.2 激活模型　　349<br>18.2.3 Django管理网站　　351<br>18.2.4 定义模型Entry　　353<br>18.2.5 迁移模型Entry　　354<br>18.2.6 向管理网站注册Entry　　354<br>18.2.7 Django shell　　355<br>18.3 创建页面：学习笔记主页　　357<br>18.3.1 映射URL　　358<br>18.3.2 编写视图　　359<br>18.3.3 编写模板　　360<br>18.4 创建其他页面　　361<br>18.4.1 模板继承　　361<br>18.4.2 显示所有主题的页面　　363<br>18.4.3 显示特定主题的页面　　366<br>18.5 小结　　369<br>第19章 用户账户　　370<br>19.1 让用户输入数据　　370<br>19.1.1 添加新主题　　370<br>19.1.2 添加新条目　　374<br>19.1.3 编辑条目　　378<br>19.2 创建用户账户　　381<br>19.2.1 应用程序users　　381<br>19.2.2 将users添加到settings.py 中　　381<br>19.2.3 包含users的URL　　382<br>19.2.4 登录页面　　382<br>19.2.5 注销　　384<br>19.2.6 注册页面　　386<br>19.3 让用户拥有自己的数据　　388<br>19.3.1 使用@login_required限制访问　　388<br>19.3.2 将数据关联到用户　　390<br>19.3.3 只允许用户访问自己的主题　　393<br>19.3.4 保护用户的主题　　393<br>19.3.5 保护页面edit_entry　　394<br>19.3.6 将新主题关联到当前用户　　396<br>第20章 设置应用程序的样式并部署　　397<br>20.1.1 应用程序django-bootstrap4　　398<br>20.1.3 修改base.html　　399<br>20.1.4 使用jumbotron设置主页的样式　　403<br>20.1.5 设置登录页面的样式　　404<br>20.1.6 设置显示所有主题的页面的样式　　405<br>20.1.7 设置显示单个主题的页面中的条目样式　　406<br>20.2 部署“学习笔记”　　407<br>20.2.1 建立Heroku账户　　408<br>20.2.2 安装Heroku CLI　　408<br>20.2.3 安装必要的包　　408<br>20.2.4 创建文件requirements.txt　　409<br>20.2.6 为部署到Heroku而修改settings.py　　410<br>20.2.7 创建启动进程的Procfile　　410<br>20.2.8 使用Git 跟踪项目文件　　410<br>20.2.9 推送到Heroku　　412<br>20.2.10 在Heroku上建立数据库　　414<br>20.2.12 确保项目的安全　　416<br>20.2.13 提交并推送修改　　416<br>20.2.14 在Heroku 上设置环境变量　　417<br>20.2.15 创建自定义错误页面　　418<br>20.2.16 继续开发　　420<br>20.2.17 设置SECRET_KEY　　421<br>20.2.18 将项目从Heroku删除　　421<br>20.3 小结　　422<br>附录A 安装与故障排除　　423<br>附录B 文本编辑器与IDE　　428<br>附录C 寻求帮助　　432<br>附录D 使用Git 进行版本控制　　436<br>后记　　445</p><h3 id="Python编程：从入门到实践-PDF-下载地址"><a href="#Python编程：从入门到实践-PDF-下载地址" class="headerlink" title="Python编程：从入门到实践 PDF 下载地址:"></a>Python编程：从入门到实践 PDF 下载地址:</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Y3kieRXl42PGLymLpxszAw?pwd=k4fy">https://pan.baidu.com/s/1Y3kieRXl42PGLymLpxszAw?pwd=k4fy</a> </p><p>提取码：k4fy</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站所有文档密码</title>
      <link href="//mima/"/>
      <url>//mima/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="8db921aceeece298fa0ee0c99b8d3229beacb72c92e02fe4c1e252f461de7186">7c351404e46fa1c7280678d51bf9554c54ebb642ef2fdc7f9d2e4e83b89517e84c2b4fa42deb4a15a5e466b16087a1cb77ef0bc6c5672c6fa7950d637c05b9f18ee4bb8c88dc6442955d25749c1de471a0aacf3a752a169658acd879372ae5a669d756844de2c7c154cc10a9038bf4f72217f859aeab3eaffbd4379fa0d1b1fd324da80ab45781acb4f43cd8f467c2aa223ab9b684cc7ea3313a51551eb5b97debd6d71e067781a937932c4ac84c69a4e307af4c80ba5a1a768ed2e3be20e59d3c684778afe7a20d5f0eafae7338aa9b16557b54c07be3cea4f2ee8d5690a128e9e5aedf5c4fe18f249e2500953adf8bb6777996ea50c338fb04d4e2661aa8f7798536c6cc5bedc6b8ea654bc1ff6aead4d0775a8dfb00c39d1a39668187b3c13d6259d800878d07d3a3e81547653401df1c05b1b0c84fb84c6f7d5ee5778b0ee4895602215ca19f8e46f1142bb607d0ab5c2fc1e6861d086da9eca8f72011d65bbae25bd7d57ac243548014f56aabea40c4133db7893eb69dc67faffe84ca0669108db026bdb7766221fb8c4d1a477d4ba99fa188741adb17f05896200f41f31a049104e53c40d1cdcbe80b04ec70b802413a48b31d317ecaf6cd7b9a2a8b894ef70619db14193b21aa9e4f12b8a09195fa8327e64261539f58030f3983d068c98c43fb9fb1f3a489a9c937fa40a0b706f7a861a2aa9e29cfc5a5ca9434a25da38a7e6455bd0be779aa0637930737bf3bd62a5d67d4c81ee2750c8d00426cce0dc134ad106059ae742b8da21864298d4369dbd6e15c7eba1ccd398b264a653206f591d9987da0ad189727fd5b6c3636d3577c424bf58ed3a317148fa95e5e9aca0309c1a12d6b2eb42066d7494b3c54a55d2514939eb08773d890152c8d7a79076c9f566d2fbe2413eecd912bd26e92b4ba6ccbd988757fea94f2db39202d91607c4079e5cccead49d816606bf109d696790e9854abaf34fcb2d24bdbc921c30dbb0604615b63e4392cebbbd271be5e3fff1654ec45ca81e4f390762882245fbe09adb42362474bb6d336ad0ade506b429dd52409dba3999059b24b05c77290ce41568ca886eccb6c7f604d5261d005f2fea5a00c33dcfe002becdf9bda7adf88be3a8350e23a304ba1165d0ea9fa1bf9008a317cb879794a0f61764fcda6a68fe2218ebda838a6242c2fc91409a93f1d0925c8258e752026682ab2c9efcf376ef38c60699c1417e4150ebcc540285661f43f10520c23128aa3de1b9aabfae3bd2a399539567909ac11b09adab08ae744cd9ef2831e3b39a9cb6355b1b9981500f0433b29489740b775c3859f64d1472a0fefebee360eb20657321c77911976a6990d42e3c2f68114121ac8fbf39be5175ebeeb001a8ed72a9fcd1d901d213ce56e05fefc7f846516092b115f7fb4ca471896a7553ca2fd86923ff7381703e5af202d68117a603a830642b3d228d8d769e6dcf2bb96450d83e993da403ea330b26faf1df65e5e140d0d5fc6973491cd91d0b2da53c631ae501c3a19b5a94a1723204d1755e3616b4d8e3e4a87722e87cd73880d48d14cd515ddaa54bf797de4cef3b39458600c08cb1f297c146f986740cb6c937d81391ef600cb84e57382c78c563acd2d1703d74341f65d1e2f34f86abf93b566acfdd09a1f45611289d4ef66373882e75780ac555f6d1b18bc978f29c7005b7e14671a67abd408b9149eac26befbdc182fa1626ae7349ae6ee3858d3371e21cc5d3c75614b3245bed02bab7c19de59f5c93987471d9628c509516aa3e15bbd3fb7de6c8d9dbc0bebf70d92b69205e2721bbd0d520177c3245fc62a5eeee2e04f9ad967149bf0888d4104c8428b5a33357cbf6ade56afe98e6ff4451d9d4a18ee4ba40a90b887f1bf00b3b12b6f124e908a7ab2a751665570d88a8f8bbb8c94159643b896e23ffa24542b4ffa576387f30e791b58dc61aa5711c74d37a667bcf8dcc3a36cfbb08b3135aea050fcc854d2eaab35941f85164d8c3fd9461130ea4639ddc88b5e41144d319447fc32b1775ef4a73bf1614e4c73233ad4575849ccad5f03f58d5a3ddcefd516695517f03e898737ac02abb21236f78688450f30ddd0339ee8f65e7c63df1ebefbf53904c9b624e185e22242f7941fb71028d62e44dab5068af8af4ae14c8ba2226eb084e4c1eb550e3547dd666824f2884c7a725d72f2e8dde649d24bbc382eccfae035c953936eba6650c79ced5e70afb93b1e10b1ddd64017ef419046bd05785caf1c84c2232c325c21dbcba87defd4ea6cc58683b8a030bddf935bcb8e4d0c22b43cf0b4f42d6a1e4c6f3372e1185a05e3f82bff3ca98538aa42203ee0abf8b977f547cc4fec7bbd86aaa4cbafe15e4ec33bb2482f015717a0ec7f4b9f376a36a83ff2925e492598a705e74ed6a0678e73b5141dfd51811e56a877d59f934daf9b842f947d64f39510fed315af39446a0fc4ce0e3ed78036b8d0b44543867992bf1782727659cfaaf83890f15a84eaa63c184bd1dc89ff5c0a27b7e86c8a1ed806d6f188a117b9f46d9ace1ef33efce69fe85bba37f7dae34ed230757b66944c24c5e8e24d35a5893845aa1cba0d8df2dd803197535e3379f57ba70eb6b1c388d47d0d6cc0ffda70e7278845724db5134f70005fa40e541bbe8bbc6324d5aa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 此文章需要要密码才可以查看.">您好, 此文章需要要密码才可以查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> PDF密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《pytest测试实战》</title>
      <link href="/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/6E7FFAC4BE6AA9069DB81181D116D110.png" alt="《pytest测试实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>pytest是动态编程语言Python专用的测试框架，它具有易于上手、功能强大、第三方插件丰富、效率高、可扩展性好、兼容性强等特点。《pytest测试实战》深入浅出地讲解了pytest的使用方法，尤其是具有特色的fixture的用法。作者通过丰富的测试实例，手把手教读者编写简洁、易于维护的测试代码和插件，让你轻松掌握这个业界最受欢迎的Python测试工具。</p><p>第1章介绍pytest的安装，同时会介绍Tasks项目的数据结构部分（名为Task的namedtuple），并用它作为测试示例。我们会学习如何指定测试文件运行，以及pytest常用的命令行命令，包括重新运行失败测试、遇到失败即停止所有测试、控制堆栈跟踪、控制日志输出，等等。</p><p>第2章将使用pip在本地安装Tasks项目，学习在Python项目中如何组织测试目录，这样才能针对实际项目编写测试用例。这一章的所有示例都依赖外部程序，包括数据库写入。</p><p>第2章的重点是测试函数，你将学习在pytest中高效使用断言语句。这一章还会讲解marker标记功能的用法，marker标记可以将测试进行归类或分组，方便一起运行，也可以将某些测试标记为skip（跳过不执行），marker标记还可以告诉pytest我们知道某些测试是一定会失败的。如果希望运行指定的测试子集，除了使用marker，还可以将测试代码组织成测试目录、测试模块、测试类，然后运行。</p><p>并非所有的测试代码都要放到测试函数中。第3章介绍如何将测试数据、启动逻辑、销毁逻辑放入fixture（pytest定义的一种测试脚手架）。设置系统（或子系统、系统单元）是软件测试的重要环节，第3章将介绍用一个简单的fixture完成这方面的工作（包括对数据库进行初始化，写入数据以备测试之用）。Fixture模块的功能非常强大，你可以利用它简化测试代码，从而提高代码的可读性和可维护性。Fixture像测试函数一样，也有参数。利用参数，你只需要编写一份代码，就可以针对TinyDB和MongoDB（或其他Tasks项目支持的数据库）开展测试。</p><p>第4章介绍pytest内置的fixture以满足测试中常见的一些需求，包括生成和销毁临时目录、截取输出流（通过日志判定结果）、使用monkey patch、检查是否发出警告，等等。</p><p>第5章讲解如何在pytest中添加命令行选项，如何改进打印输出，如何打包分发自己编写的插件，如何共享定制化的pytest（包括fixture）。这一章开发的插件可以改善Tasks项目测试失败时的输出呈现方式。你还将学习测试自己的测试插件（元测试）。读完这一章，想必你已经等不及编写自己的插件了。附录C收集了一些热门的社区插件，可供参考。</p><p>第6章讲解通过pytest.ini文件修改默认配置，自定义pytest的运行方式。pytest.ini文件可以存放某些命令选项，从而减少你重复输入命令的次数；利用它还可以指定pytest忽略某些测试目录，或者指定pytest的最低版本，等等。使用tox.ini和setup.cfg文件也可以实现同样的功能。</p><p>第7章（最后一章）介绍pytest与其他工具的结合使用。我们将借助tox让Tasks项目在多个Python版本上运行；学习如何测试Tasks项目的CLI部分，而不必mock系统的其余部分；借助coverage.py检查Tasks项目代码块的测试覆盖情况；通过Jenkins发起测试并实时显示结果。最后，还会学习如何让pytest运行基于unittest的测试用例，以及把pytest的fixture共享给unittest的测试用例使用。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Okken是一位有二十多年工作经验的软件测试工程师，他业余时间录制了Test &amp; Code和Python Bytes两个播客。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>第1章 pytest入门 1<br>1.1 资源获取 4<br>1.2 运行Pytest 5<br>1.3 运行单个测试用例 10<br>1.4 使用命令行选项 10<br>–collect-only选项 11<br>-k选项 11<br>-m选项 12<br>-x选项 13<br>–maxfail&#x3D;num 15<br>-s与–capture&#x3D;method 16<br>–lf（–last-failed）选项 16<br>–ff（–failed-first）选项 17<br>-v（–verbose）选项 17<br>-q（–quiet）选项 18<br>-l（–showlocals）选项 19<br>–tb&#x3D;style选项 20<br>–duration&#x3D;N选项 21<br>–version选项 22<br>-h（–help）选项 23<br>1.5 练习 24<br>1.6 预告 25<br>第2章 编写测试函数 27<br>2.1 测试示例程序 27<br>本地安装Tasks项目程序包 30<br>2.2 使用assert声明 32<br>2.3 预期异常 35<br>2.4 测试函数的标记 36<br>完善冒烟测试 38<br>2.5 跳过测试 40<br>2.6 标记预期会失败的测试 43<br>2.7 运行测试子集 45<br>单个目录 45<br>单个测试文件&#x2F;模块 46<br>单个测试函数 47<br>单个测试类 47<br>单个测试类中的测试方法 48<br>用测试名划分测试集合 48<br>2.8 参数化测试 49<br>2.9 练习 56<br>2.10 预告 57<br>第3章 pytest Fixture 59<br>3.1 通过conftest.py共享fixture 60<br>3.2 使用fixture执行配置及销毁逻辑 61<br>3.3 使用–setup-show回溯fixture的执行过程 63<br>3.4 使用fixture传递测试数据 64<br>3.5 使用多个fixture 66<br>3.6 指定fixture作用范围 68<br>修改Tasks项目的fixture作用范围 70<br>3.7 使用usefixtures指定fixture 73<br>3.8 为常用fixture添加autouse选项 74<br>3.9 为fixture重命名 75<br>3.10 Fixture的参数化 77<br>3.11 参数化Tasks项目中的fixture 80<br>3.12 练习 83<br>3.13 预告 83<br>第4章 内置Fixture 85<br>4.1 使用tmpdir和tmpdir_factory 86<br>在其他作用范围内使用临时目录 88<br>4.2 使用pytestconfig 90<br>4.3 使用cache 92<br>4.4 使用capsys 100<br>4.5 使用monkeypatch 102<br>4.6 使用doctest_namespace 106<br>4.7 使用recwarn 109<br>4.8 练习 110<br>4.9 预告 111<br>第5章 插件 113<br>5.1 寻找插件 114<br>5.2 安装插件 114<br>从PyPI安装 114<br>从PyPI安装指定版本 115<br>从.tar.gz或.whl文件安装 115<br>从本地目录安装 115<br>从Git存储仓库安装 116<br>5.3 编写自己的插件 116<br>5.4 创建可安装插件 121<br>5.5 测试插件 125<br>5.6 创建发布包 129<br>通过共享目录分发插件 130<br>通过PyPI发布插件 130<br>5.7 练习 131<br>5.8 预告 131<br>第6章 配置 133<br>6.1 理解pytest的配置文件 133<br>用pytest –help查看ini文件选项 135<br>插件可以添加ini文件选项 135<br>6.2 更改默认命令行选项 136<br>6.3 注册标记来防范拼写错误 136<br>6.4 指定pytest的最低版本号 138<br>6.5 指定pytest忽略某些目录 138<br>6.6 指定测试目录 139<br>6.7 更改测试搜索的规则 141<br>6.8 禁用XPASS 142<br>6.9 避免文件名冲突 143<br>6.10 练习 145<br>6.11 预告 145<br>第7章 pytest与其他工具的搭配使用 147<br>7.1 pdb：调试失败的测试用例 147<br>7.2 coverage.py：判断测试覆盖了多少代码 151<br>7.3 mock：替换部分系统 155<br>7.4 tox：测试多种配置 162<br>7.5 Jenkins CI：让测试自动化 166<br>7.6 unittest：用pytest运行历史遗留测试用例 173<br>7.7 练习 179<br>7.8 预告 180<br>附录A 虚拟环境 181<br>附录B Pip 183<br>附录C 常用插件 187<br>C.1 改变测试流程的插件 187<br>pytest-repeat：重复运行测试 187<br>pytest-xdist：并行运行测试 189<br>pytest-timeout：为测试设置时间限制 190<br>C.2 改善输出效果的插件 191<br>pytest-instafail：查看错误的详细信息 191<br>pytest-sugar：显示色彩和进度条 192<br>pytest-emoji：为测试增添一些乐趣 193<br>pytest-html：为测试生成HTML报告 195<br>C.3 静态分析用的插件 197<br>pytest-pycodestyle和pytest-pep8：Python代码风格检查 197<br>pytest-flake8：更多的风格检查 197<br>C.4 Web开发用的插件 198<br>pytest-selenium：借助浏览器完成自动化测试 198<br>pytest-django：测试Django应用 198<br>pytest-flask：测试Flask应用 199<br>附录D 打包和发布Python项目 201<br>D.1 创建可安装的模块 201<br>D.2 创建可安装的包 203<br>D.3 创建源码发布包和Wheel文件 205<br>D.4 创建可以从PyPI安装的包 209<br>附录E xUnit Fixture 211<br>E.1 xUnit Fixture的语法 211<br>E.2 混合使用pytest Fixture和xUnit Fixture 214<br>E.3 xUnit Fixture的限制 215<br>索引 216</p><h3 id="pytest测试实战-PDF-下载"><a href="#pytest测试实战-PDF-下载" class="headerlink" title="pytest测试实战 PDF 下载"></a>pytest测试实战 PDF 下载</h3><hr><p>链接：<a href="https://pan.baidu.com/s/1Mg_nwvwOtwIiWakKA2BPJA?pwd=ylqm">https://pan.baidu.com/s/1Mg_nwvwOtwIiWakKA2BPJA?pwd=ylqm</a> </p><p>提取码：ylqm</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> PyTest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
