<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《DevOps实践指南》</title>
      <link href="/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/23/DevOps%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/c9c87291194e8042c6dd80f9f4756516.png" alt="《DevOps实践指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书共分为6个部分：第一部分概述DevOps的历史和三个基本原则，即“三步工作法”；第二部分介绍开启DevOps转型的过程；第三到五部分深入探讨“三步工作法”的各个要素；第六部分关注如何将安全性和合规性正确集成到日常工作中。全书涵盖40余个DevOps案例，以谷歌、亚马逊、Facebook等全球知名企业和组织的实际调查结果为依据，展示如何通过现代化的运维管理提升管理效率，进而为企业赢得更大市场、创造更多利润。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Gene Kim</p><p>Tripwire创始人、前CTO，IT Revolution创始人，DevOps企业峰会主办人，畅销书《凤凰项目》合著者。</p><p>Jez Humble</p><p>DevOps Research and Assessment公司CTO，加州大学伯克利分校信息学院讲师；曾任ThoughtWorks首席顾问。《精益企业》和Jolt大奖图书《持续交付》的合著者。</p><p>Patrick Debois</p><p>DevOps之父，致力于通过在开发、项目管理和系统管理之中应用敏捷技术来填补项目和运维之间的鸿沟。</p><p>John Willis</p><p>Chain Bridge System创始人，曾任Docker公司布道师，现就职于SJ Technologies公司。</p><p>译者简介：</p><p>刘征</p><p>Nutanix路坦力资深架构师，EXIN首批国内DevOps Master和DevOps Professional认证讲师，持有红帽RHCA认证和AWS高级架构师认证，谙熟企业数据中心的IT服务管理。目前致力于推广DevOps相关的理念和实践，在DevOps社区中积极地参与培训和研讨会等活动，是DevOpsDays大会社区在中国的核心组织者和志愿工作者。</p><p>王磊</p><p>前ThoughtWorks咨询师，EXIN首批国内DevOps Master认证讲师。拥有10多年软件行业经验，以及服务化架构、持续交付和DevOps转型等方面的丰富实践经验。国内较早倡导和实践微服务的先行者，著有国内首本微服务架构相关图书《微服务架构与实践》，是西安DevOps Meetup活动的联合发起人。</p><p>马博文</p><p>前ThoughtWorks咨询师，AWS认证助理架构师、开发者。拥有多年Web开发和DevOps经验，熟悉持续交付、微服务。曾参与翻译《Scala编程实战》《DevOps实践》等书，是西安DevOps Meetup活动的发起人。</p><p>曾朝京</p><p>Micro Focus资深解决方案顾问，曾参加EXIN首批国内Devops Master讲师认证培训。长期从事IT运维管理领域咨询工作，曾为能源、金融、航空运输、政府行业中的多个大型企业提供IT运维管理规划。目前致力于探索DevOps理念在企业IT部门的实践。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　DevOps介绍<br>第1章　敏捷、持续交付和三步法　　4<br>1.1　制造业价值流　　4<br>1.2　技术价值流　　4<br>1.2.1　聚焦于部署前置时间　　5<br>1.2.2　关注返工指标——%C&#x2F;A　　7<br>1.3　三步工作法：DevOps的基础原则　　7<br>1.4　小结　　8<br>第2章　第一步：流动原则　　9<br>2.1　使工作可见　　9<br>2.2　限制在制品数　　10<br>2.3　减小批量大小　　11<br>2.4　减少交接次数　　13<br>2.5　持续识别和改善约束点　　14<br>2.6　消除价值流中的困境和浪费　　15<br>2.7　小结　　16<br>第3章　第二步：反馈原则　　17<br>3.1　在复杂系统中安全地工作　　17<br>3.2　及时发现问题　　18<br>3.3　群策群力，战胜问题获取新知　　19<br>3.4　在源头保障质量　　21<br>3.5　为下游工作中心而优化　　22<br>3.6　小结　　22<br>第4章　第三步：持续学习与实验原则　　23<br>4.1　建立学习型组织和安全文化　　23<br>4.2　将日常工作的改进制度化　　25<br>4.3　把局部发现转化为全局优化　　26<br>4.4　在日常工作中注入弹性模式　　27<br>4.5　领导层强化学习文化　　27<br>4.6　小结　　29<br>4.7　第一部分总结　　29<br>第二部分　从何处开始<br>第5章　选择合适的价值流作为切入点　　32<br>5.1　绿地项目与棕地项目　　34<br>5.2　兼顾记录型系统和交互型系统　　35<br>5.3　从最乐于创新的团队开始　　36<br>5.4　扩大DevOps的范围　　37<br>5.5　小结　　38<br>第6章　理解、可视化和运用价值流　　39<br>6.1　确定创造客户价值所需的团队　　40<br>6.2　针对团队工作绘制价值流图　　40<br>6.3　组建专门的转型团队　　42<br>6.3.1　拥有共同的目标　　43<br>6.3.2　保持小跨度的改进计划　　44<br>6.3.3　为非功能性需求预留20%的<br>开发时间，减少技术债务　　44<br>6.3.4　提高工作的可视化程度　　47<br>6.4　用工具强化预期行为　　47<br>6.5　小结　　48<br>第7章　参考康威定律设计组织结构　　49<br>7.1　组织原型　　51<br>7.2　过度职能导向的危害（“成本优化”）　　51<br>7.3　组建以市场为导向的团队（“速度优化”）　　52<br>7.4　使职能导向有效　　53<br>7.5　将测试、运维和信息安全融入日常工作　　54<br>7.6　使团队成员都成为通才　　54<br>7.7　投资于服务和产品，而非项目　　56<br>7.8　根据康威定律设定团队边界　　56<br>7.9　创建松耦合架构，提高生产力和安全性　　57<br>7.10　小结　　60<br>第8章　将运维融入日常开发工作　　61<br>8.1　创建共享服务，提高开发生产力　　62<br>8.2　将运维工程师融入服务团队　　63<br>8.3　为每个服务团队分派运维联络人　　64<br>8.4　邀请运维工程师参加开发团队的会议　　65<br>8.4.1　邀请运维工程师参加每日站会　　65<br>8.4.2　邀请运维工程师参加回顾会议　　66<br>8.4.3　使用看板图展示运维工作　　66<br>8.5　小结　　67<br>8.6　第二部分总结　　67<br>第三部分　第一步：流动的技术实践<br>第9章　为部署流水线奠定基础　　70<br>9.1　按需搭建开发环境、测试环境和生产环境　　71<br>9.2　应用统一的代码仓库　　72<br>9.3　使基础设施的重建更容易　　74<br>9.4　运行在类生产环境里才算“完成”　　75<br>9.5　小结　　76<br>第10章　实现快速可靠的自动化测试　　77<br>10.1　对代码和环境做持续构建、测试和集成　　79<br>10.2　构建快速可靠的自动化测试套件　　81<br>10.2.1　在自动化测试中尽早发现<br>错误　　83<br>10.2.2　尽可能并行地快速执行测试　　84<br>10.2.3　先编写自动化测试　　84<br>10.2.4　尽量将手动测试自动化　　85<br>10.2.5　在测试套件中集成性能测试　　86<br>10.2.6　在测试套件中集成非功能性需求测试　　86<br>10.3　在部署流水线失败时拉下安灯绳　　87<br>10.4　小结　　89<br>第11章　应用和实践持续集成　　90<br>11.1　小批量开发与大批量合并　　92<br>11.2　应用基于主干的开发实践　　93<br>11.3　小结　　95<br>第12章　自动化和低风险发布　　96<br>12.1　自动化部署流程　　97<br>12.1.1　应用自动化的自助式部署　　100<br>12.1.2　在部署流水线中集成代码部署　　101<br>12.2　将部署与发布解耦　　104<br>12.2.1　基于环境的发布模式　　105<br>12.2.2　基于应用的发布模式更安全　　109<br>12.3　持续交付和持续部署实践的调查　　112<br>12.4　小结　　113<br>第13章　降低发布风险的架构　　114<br>13.1　能提高生产力、可测试性和安全性的架构　　115<br>13.2　架构原型：单体架构与微服务　　116<br>13.3　安全地演进企业架构　　118<br>13.4　小结　　121<br>13.5　第三部分总结　　121<br>第四部分　第二步：反馈的技术实践<br>第14章　建立能发现并解决问题的遥测系统　　125<br>14.1　建设集中式监控架构　　127<br>14.2　建立生产环境的应用程序日志遥测　　129<br>14.3　使用遥测指导问题的解决　　131<br>14.4　将建立生产遥测融入日常工作　　132<br>14.5　建立自助访问的遥测和信息辐射器　　133<br>14.6　发现和填补遥测的盲区　　135<br>14.6.1　应用程序和业务度量指标　　136<br>14.6.2　基础架构度量指标　　137<br>14.6.3　显示叠加的指标组合　　138<br>14.7　小结　　139<br>第15章　分析遥测数据以更好地预测故障和实现目标　　140<br>15.1　用均值和标准差识别潜在问题　　141<br>15.2　异常状态的处理和告警　　142<br>15.3　非高斯分布遥测数据的问题　　143<br>15.4　应用异常检测技术　　146<br>15.5　小结　　149<br>第16章　应用反馈实现安全部署　　150<br>16.1　通过遥测使部署更安全　　151<br>16.2　开发和运维共同承担值班工作　　153<br>16.3　让开发人员跟踪工作对下游的影响　　153<br>16.4　让开发人员自行管理生产服务　　155<br>16.5　小结　　159<br>第17章　将假设驱动的开发和A&#x2F;B测试融入日常工作　　160<br>17.1　A&#x2F;B测试简史　　161<br>17.2　在功能测试中集成A&#x2F;B测试　　162<br>17.3　在发布中集成A&#x2F;B测试　　162<br>17.4　在功能规划中集成A&#x2F;B测试　　163<br>17.5　小结　　165<br>第18章　建立评审和协作流程以提升当前工作的质量　　166<br>18.1　变更审批流程的危险　　168<br>18.2 “过度控制变更”的潜在危险　　168<br>18.3　变更的协调和排程　　170<br>18.4　变更的同行评审　　170<br>18.5　人工测试和变更冻结的潜在危害　　173<br>18.6　利用结对编程改进代码变更　　173<br>18.7　消除官僚流程　　176<br>18.8　小结　　177<br>18.9　第四部分总结　　178<br>第五部分　第三步：持续学习与实验的技术实践<br>第19章　将学习融入日常工作　　180<br>19.1　建立公正和学习的文化　　181<br>19.2　举行不指责的事后分析会议　　182<br>19.3　尽可能广泛地公开事后分析会议结果　　184<br>19.4　降低事故容忍度，寻找更弱的故障信号　　185<br>19.5　重新定义失败，鼓励评估风险　　186<br>19.6　在生产环境注入故障来恢复和学习　　186<br>19.7　创建故障演练日　　187<br>19.8　小结　　189<br>第20章　将局部经验转化为全局改进　　190<br>20.1　使用聊天室和聊天机器人自动积累组织知识　　190<br>20.2　软件中便于重用的自动化、标准化流程　　192<br>20.3　创建全组织共享的单一源代码库　　192<br>20.4　运用自动化测试记录和交流实践来传播知识　　194<br>20.5　通过确定非功能性需求来设计运维　　194<br>20.6　把可重用的运维用户故事纳入开发　　195<br>20.7　确保技术选型有助于实现组织目标　　195<br>20.8　小结　　197<br>第21章　预留组织学习和改进的时间　　198<br>21.1　偿还技术债务的制度化惯例　　199<br>21.2　让所有人教学相长　　200<br>21.3　在DevOps会议中分享经验　　201<br>21.4　传播实践的内部顾问和教练　　203<br>21.5　小结　　204<br>21.6　第五部分总结　　204<br>第六部分　集成信息安全、变更管理和合规性的技术实践<br>第22章　将信息安全融入每个人的日常工作　　207<br>22.1　将安全集成到开发迭代的演示中　　207<br>22.2　将安全集成到缺陷跟踪和事后分析会议中　　208<br>22.3　将预防性安全控制集成到共享源代码库及共享服务中　　208<br>22.4　将安全集成到部署流水线中　　209<br>22.5　保证应用程序的安全性　　210<br>22.6　确保软件供应链的安全　　214<br>22.7　确保环境的安全　　215<br>22.8　将信息安全集成到生产环境遥测中　　216<br>22.9　在应用程序中建立安全遥测系统　　217<br>22.10　在环境中建立安全遥测系统　　217<br>22.11　保护部署流水线　　219<br>22.12　小结　　219<br>第23章　保护部署流水线　　220<br>23.1　将安全和合规性集成到变更批准流程中　　220<br>23.2　将大量低风险变更重新归类为标准变更　　221<br>23.3　如何处理常规变更　　222<br>23.4　减少对职责分离的依赖　　224<br>23.5　确保为审计人员和合规人员留存文档和证据　　226<br>23.6　小结　　228<br>23.7　第六部分总结　　228行动起来——本书总结　　229<br>附加材料<br>附　　录　　232<br>附录1　DevOps的大融合　　232<br>附录2　约束理论和核心的长期<br>冲突　　234<br>附录3　恶性循环列表　　235<br>附录4　交接和队列的危害　　235<br>附录5　工业安全神话　　236<br>附录6　丰田安灯绳　　237<br>附录7　软件包产品　　238<br>附录8　事后分析会议　　238<br>附录9　猿猴军团　　239<br>附录10　上线时间透明化　　240<br>参考资源　　241<br>致　　谢　　243<br>EXIN DevOps Professional认证备考<br>指南 &amp; 模拟题①　　245</p><h3 id="DevOps实践指南-PDF-下载"><a href="#DevOps实践指南-PDF-下载" class="headerlink" title="DevOps实践指南 PDF 下载"></a>DevOps实践指南 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1iKhy4For3F8XbWYZpUGU1Q?pwd=rcwc">https://pan.baidu.com/s/1iKhy4For3F8XbWYZpUGU1Q?pwd=rcwc</a> </p><p>提取码: rcwc </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> DevOps </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript开发实战》</title>
      <link href="/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/23/JavaScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/ece758c279279d142e46b17df4f21c5a.png" alt="《JavaScript开发实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>《JavaScript开发实战》是一本 JavaScript 开发入门指导书，主要介绍了变量、对象、函数、数组、构造函数、方括号运算符、作用域、条件语句、模块、模型、视图、控制器、构建网页、控件、模板、数据加载等内容。书中涉及的概念都附有简短示例。此外，还有一个贯穿全书的持续示例 — 冒险游戏 The Crypt。读者可以在一个交互式网站上直接运行书中的代码。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>作者约翰·拉尔森是一名有30多年经验的程序员，精通JavaScript，也是一位经验丰富的教师。因此他深知读者在学习新知识、新技能过程中的困难，知道如何调动读者的积极性，帮助他们克服困难，并且善于用简洁的语言解释计算机语言的难点。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 控制台上的核心概念<br>第 1 章 编程、JavaScript 和 JS Bin<br>1.1 编程<br>1.2 JavaScript<br>1.3 在实践和思考中学习<br>1.4 JS Bin<br>1.4.1 JS Bin 面板<br>1.4.2 在 JS Bin 上运行代码清单<br>1.4.3 输出到控制台<br>1.4.4 代码注释<br>1.4.5 Further Adventures——进阶练习<br>1.4.6 错误消息<br>1.4.7 行号<br>1.4.8 获取账户<br>1.5 游戏 The Crypt——本书的一个持续示例<br>1.5.1 运行 The Crypt<br>1.5.2 创建 The Crypt 的具体步骤<br>1.6 更多示例和练习<br>1.7 浏览器的兼容性<br>1.8 本章小结<br>第 2 章 变量：在程序中存储数据<br>2.1 什么是变量<br>2.2 变量的声明和赋值<br>2.2.1 变量声明<br>2.2.2 变量赋值<br>2.2.3 一步实现变量声明和赋值<br>2.2.4 先运算再赋值<br>2.3 选择合适的变量名<br>2.3.1 关键字和保留字<br>2.3.2 变量的命名规则<br>2.3.3 骆驼式命名法（camelCase）<br>2.3.4 使用描述性变量名<br>2.4 The Crypt——玩家变量<br>2.5 本章小结<br>第 3 章 对象：数据分组<br>3.1 变量需要分组<br>3.2 创建对象<br>3.2.1 创建一个空对象<br>3.2.2 属性“键?值对”<br>3.3 访问对象的属性<br>3.4 更新对象的属性<br>3.5 其他示例<br>3.5.1 撰写一条博客<br>3.5.2 创建一个日历<br>3.5.3 天气怎么样？<br>3.5.4 一个小测验<br>3.5.5 创建自己的程序<br>3.6 游戏 The Crypt——玩家对象<br>3.7 本章小结<br>第 4 章 函数：按需执行代码<br>4.1 重复问题<br>4.1.1 将对象的属性作为文本进行显示<br>4.1.2 加税算出总成本<br>4.2 定义函数和调用函数<br>4.2.1 定义新函数<br>4.2.2 函数表达式和函数声明<br>4.2.3 使用函数<br>4.2.4 使用函数的步骤<br>4.3 减少重复<br>4.3.1 函数可用于将对象的属性作为文本进行显示<br>4.3.2 加税并显示总成本的函数<br>4.4 使代码易于阅读和更新<br>4.4.1 更新 showMovieInfo 函数<br>4.5 游戏 The Crypt——显示玩家的信息<br>4.5.1 用函数显示玩家的信息<br>4.6 本章小结<br>第 5 章 参数：将数据传递给函数<br>5.1 函数重用<br>5.2 将信息传递给函数<br>5.2.1 将实参传递给函数<br>5.2.2 将多个实参传递给一个函数<br>5.3 The Crypt——显示玩家信息<br>5.3.1 显示玩家的姓名<br>5.3.2 显示玩家的健康值<br>5.3.3 显示玩家的位置<br>5.3.4 合并显示玩家的信息<br>5.4 本章小结<br>第 6 章 返回值：从函数获取数据<br>6.1 从函数返回数据<br>6.1.1 用返回值替代函数调用<br>6.1.2 关键字 return<br>6.1.3 使用参数来确定返回值<br>6.2 在控制台提示符下进行实验<br>6.2.1 调用函数<br>6.2.2 声明新的变量<br>6.3 The Crypt——构建玩家信息字符串<br>6.3.1 为玩家的姓名、健康值和位置构建字符串<br>6.3.2 用一个函数显示玩家的信息——把几个函数集合在一起<br>6.4 本章小结<br>第 7 章 对象参数：将对象传递给函数<br>7.1 使用对象作为参数<br>7.1.1 访问对象参数的属性<br>7.1.2 给对象参数添加属性<br>7.2 从函数返回对象<br>7.2.1 构建行星——对象创建函数<br>7.2.2 二维空间的点<br>7.3 方法——设置函数作为对象的属性<br>7.3.1 命名空间——将相关函数组织到一起<br>7.3.2 Math 方法<br>7.3.3 String 方法<br>7.3.4 spacer——将更多的方法收入命名空间<br>7.3.5 进一步探索命名空间<br>7.4 The Crypt——将玩家对象作为参数<br>7.5 本章小结<br>第 8 章 数组：将数据存入列表<br>8.1 创建数组并访问元素<br>8.1.1 创建数组<br>8.1.2 访问数组元素<br>8.2 数组方法<br>8.2.1 添加和删除元素<br>8.2.2 截取和拼接数组<br>8.2.3 使用 forEach 访问每一个元素<br>8.3 The Crypt——玩家的物品数组<br>8.4 本章小结<br>第 9 章 构造函数：构建带有函数的对象<br>9.1 使用函数构建对象<br>9.1.1 添加属性<br>9.1.2 添加方法<br>9.2 使用构造函数构建对象<br>9.2.1 构造函数<br>9.2.2 使用 Planet 构造函数创建一个新世界<br>9.2.3 使用 instanceof 运算符区分对象<br>9.3 建造大师——两个构造函数的示例<br>9.4 The Crypt——为玩家提供掠夺地<br>9.4.1 构建 Place 构造函数——名称标题和描述<br>9.4.2 构建 Place 构造函数——囤积物品<br>9.4.3 构建 Place 构造函数——探索出口<br>9.5 The Crypt——简化玩家创建代码<br>9.5.1 整理玩家属性<br>9.5.2 将函数转换为方法<br>9.5.3 为玩家分配位置<br>9.5.4 使用 null 作为对象的占位符<br>9.6 本章小结<br>第 10 章 方括号运算符：灵活的属性名称<br>10.1 用方括号运算符替代圆点运算符<br>10.1.1 使用方括号——人的姓名作为键<br>10.1.2 最大限度地利用方括号运算符——单词统计<br>10.2 The Crypt——使游戏出口更加刺激好玩<br>10.2.1 使用对象存放出口<br>10.2.2 创建一个添加并显示出口的函数<br>10.2.3 设置每个场所对象的出口集合<br>10.2.4 将 exits 对象添加到完整的 Place 构造函数<br>10.2.5 测试 Place 构造函数<br>10.3 The Crypt——开始游戏！<br>10.3.1 刷新显示——render<br>10.3.2 探索地图——go<br>10.3.3 收集物品——get<br>10.3.4 设计一个更大的冒险游戏——Jahver 的船<br>10.4 下一步目标<br>10.5 本章小结<br>第二部分 组 织 代 码<br>第 11 章 作用域：隐藏信息<br>11.1 全局变量的危险性<br>11.1.1 访问所有区域——偷窥和篡改<br>11.1.2 访问所有区域——借助于实现<br>11.1.3 命名冲突<br>11.1.4 难以查找的错误<br>11.2 局部变量的优势<br>11.3 接口——控制访问权限并提供可用功能<br>11.3.1 使用一个函数来隐藏变量<br>11.3.2 使用 getCount 创建多个独立计数器<br>11.3.3 用构造函数创建多个独立的计数器<br>11.4 创建一个简单的测验应用程序<br>11.4.1 将对象用作一个命名空间<br>11.4.2 隐藏问题数组<br>11.5 The Crypt——隐藏玩家信息<br>11.5.1 当前的 Player 构造函数——全部内容都公开<br>11.5.2 更新版的 Player 构造函数——某些变量被隐藏<br>11.6 The Crypt——隐藏地点信息<br>11.7 The Crypt——用户交互<br>11.7.1 接口——go 和 get<br>11.7.2 隐藏程序的实现<br>11.8 本章小结<br>第 12 章 条件：有选择地运行代码<br>12.1 有条件地执行代码<br>12.1.1 严格相等运算符<br>12.1.2 if 语句<br>12.1.3 else 子句<br>12.1.4 隐藏函数中的密码数字</p><h3 id="JavaScript开发实战-PDF-下载"><a href="#JavaScript开发实战-PDF-下载" class="headerlink" title="JavaScript开发实战 PDF 下载"></a>JavaScript开发实战 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1lw8bKX1GoatgI_IC3JC6og?pwd=g8s2">https://pan.baidu.com/s/1lw8bKX1GoatgI_IC3JC6og?pwd=g8s2</a> </p><p>提取码: g8s2 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript高级程序设计（第4版）》</title>
      <link href="/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/"/>
      <url>/2023/05/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E7%AC%AC4%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/151a8998ee2c6caeba42f688e52f9f95.png" alt="《JavaScript高级程序设计（第4版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。</p><p>本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Nicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是<a href="http://www.nczonline.net%EF%BC%8C%E4%BB%96%E7%9A%84Twitter%E5%88%AB%E5%90%8D%E6%98%AF@slicknet./">www.nczonline.net，他的Twitter别名是@slicknet。</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　JavaScript简介　　1<br>1.1　JavaScript简史　　1<br>1.2　JavaScript实现　　2<br>1.2.1　ECMAScript　　3<br>1.2.2　文档对象模型（DOM）　　5<br>1.2.3　浏览器对象模型（BOM）　　8<br>1.3　JavaScript版本　　8<br>1.4　小结　　9<br>第2章　在HTML中使用JavaScript　　10<br>2.1　<script>元素　　10<br>2.1.1　标签的位置　　12<br>2.1.2　延迟脚本　　13<br>2.1.3　异步脚本　　13<br>2.1.4　在XHTML中的用法　　14<br>2.1.5　不推荐使用的语法　　16<br>2.2　嵌入代码与外部文件　　16<br>2.3　文档模式　　16<br>2.4　<noscript>元素　　18<br>2.5　小结　　18<br>第3章　基本概念　　19<br>3.1　语法　　19<br>3.1.1　区分大小写　　19<br>3.1.2　标识符　　19<br>3.1.3　注释　　20<br>3.1.4　严格模式　　20<br>3.1.5　语句　　20<br>3.2　关键字和保留字　　21<br>3.3　变量　　22<br>3.4　数据类型　　23<br>3.4.1　typeof操作符　　23<br>3.4.2　Undefined类型　　24<br>3.4.3　Null类型　　25<br>3.4.4　Boolean类型　　26<br>3.4.5　Number类型　　27<br>3.4.6　String类型　　32<br>3.4.7　Object类型　　35<br>3.5　操作符　　36<br>3.5.1　一元操作符　　36<br>3.5.2　位操作符　　39<br>3.5.3　布尔操作符　　44<br>3.5.4　乘性操作符　　47<br>3.5.5　加性操作符　　48<br>3.5.6　关系操作符　　50<br>3.5.7　相等操作符　　51<br>3.5.8　条件操作符　　53<br>3.5.9　赋值操作符　　53<br>3.5.10　逗号操作符　　54<br>3.6　语句　　54<br>3.6.1　if语句　　54<br>3.6.2　do-while语句　　55<br>3.6.3　while语句　　55<br>3.6.4　for语句　　56<br>3.6.5　for-in语句　　57<br>3.6.6　label语句　　58<br>3.6.7　break和continue语句　　58<br>3.6.8　with语句　　60<br>3.6.9　switch语句　　60<br>3.7　函数　　62<br>3.7.1　理解参数　　64<br>3.7.2　没有重载　　66<br>3.8　小结　　67<br>第4章　变量、作用域和内存问题　　68<br>4.1　基本类型和引用类型的值　　68<br>4.1.1　动态的属性　　68<br>4.1.2　复制变量值　　69<br>4.1.3　传递参数　　70<br>4.1.4　检测类型　　72<br>4.2　执行环境及作用域　　73<br>4.2.1　延长作用域链　　75<br>4.2.2　没有块级作用域　　76<br>4.3　垃圾收集　　78<br>4.3.1　标记清除　　78<br>4.3.2　引用计数　　79<br>4.3.3　性能问题　　80<br>4.3.4　管理内存　　81<br>4.4　小结　　81<br>第5章　引用类型　　83<br>5.1　Object类型　　83<br>5.2　Array类型　　86<br>5.2.1　检测数组　　88<br>5.2.2　转换方法　　89<br>5.2.3　栈方法　　90<br>5.2.4　队列方法　　91<br>5.2.5　重排序方法　　92<br>5.2.6　操作方法　　94<br>5.2.7　位置方法　　95<br>5.2.8　迭代方法　　96<br>5.2.9　缩小方法　　97<br>5.3　Date类型　　98<br>5.3.1　继承的方法　　100<br>5.3.2　日期格式化方法　　101<br>5.3.3　日期/时间组件方法　　102<br>5.4　RegExp类型　　103<br>5.4.1　RegExp实例属性　　105<br>5.4.2　RegExp实例方法　　106<br>5.4.3　RegExp构造函数属性　　107<br>5.4.4　模式的局限性　　109<br>5.5　Function类型　　110<br>5.5.1　没有重载（深入理解）　　111<br>5.5.2　函数声明与函数表达式　　111<br>5.5.3　作为值的函数　　112<br>5.5.4　函数内部属性　　113<br>5.5.5　函数属性和方法　　116<br>5.6　基本包装类型　　118<br>5.6.1　Boolean类型　　120<br>5.6.2　Number类型　　120<br>5.6.3　String类型　　122<br>5.7　单体内置对象　　130<br>5.7.1　Global对象　　131<br>5.7.2　Math对象　　134<br>5.8　小结　　137<br>第6章　面向对象的程序设计　　138<br>6.1　理解对象　　138<br>6.1.1　属性类型　　139<br>6.1.2　定义多个属性　　142<br>6.1.3　读取属性的特性　　143<br>6.2　创建对象　　144<br>6.2.1　工厂模式　　144<br>6.2.2　构造函数模式　　144<br>6.2.3　原型模式　　147<br>6.2.4　组合使用构造函数模式和原型模式　　159<br>6.2.5　动态原型模式　　159<br>6.2.6　寄生构造函数模式　　160<br>6.2.7　稳妥构造函数模式　　161<br>6.3　继承　　162<br>6.3.1　原型链　　162<br>6.3.2　借用构造函数　　167<br>6.3.3　组合继承　　168<br>6.3.4　原型式继承　　169<br>6.3.5　寄生式继承　　171<br>6.3.6　寄生组合式继承　　172<br>6.4　小结　　174<br>第7章　函数表达式　　175<br>7.1　递归　　177<br>7.2　闭包　　178<br>7.2.1　闭包与变量　　181<br>7.2.2　关于this对象　　182<br>7.2.3　内存泄漏　　183<br>7.3　模仿块级作用域　　184<br>7.4　私有变量　　186<br>7.4.1　静态私有变量　　188<br>7.4.2　模块模式　　189<br>7.4.3　增强的模块模式　　191<br>7.5　小结　　192<br>第8章　BOM　　193<br>8.1　window对象　　193<br>8.1.1　全局作用域　　193<br>8.1.2　窗口关系及框架　　194<br>8.1.3　窗口位置　　197<br>8.1.4　窗口大小　　198<br>8.1.5　导航和打开窗口　　199<br>8.1.6　间歇调用和超时调用　　203<br>8.1.7　系统对话框　　205<br>8.2　location对象　　207<br>8.2.1　查询字符串参数　　207<br>8.2.2　位置操作　　208<br>8.3　navigator对象　　210<br>8.3.1　检测插件　　211<br>8.3.2　注册处理程序　　213<br>8.4　screen对象　　214<br>8.5　history对象　　215<br>8.6　小结　　216<br>第9章　客户端检测　　217<br>9.1　能力检测　　217<br>9.1.1　更可靠的能力检测　　218<br>9.1.2　能力检测，不是浏览器检测　　220<br>9.2　怪癖检测　　220<br>9.3　用户代理检测　　221<br>9.3.1　用户代理字符串的历史　　222<br>9.3.2　用户代理字符串检测技术　　228<br>9.3.3　完整的代码　　242<br>9.3.4　使用方法　　245<br>9.4　小结　　246<br>第10章　DOM　　247<br>10.1　节点层次　　247<br>10.1.1　Node类型　　248<br>10.1.2　Document类型　　253<br>10.1.3　Element类型　　261<br>10.1.4　Text类型　　270<br>10.1.5　Comment类型　　273<br>10.1.6　CDATASection类型　　274<br>10.1.7　DocumentType类型　　274<br>10.1.8　DocumentFragment类型　　275<br>10.1.9　Attr类型　　276<br>10.2　DOM操作技术　　277<br>10.2.1　动态脚本　　277<br>10.2.2　动态样式　　279<br>10.2.3　操作表格　　281<br>10.2.4　使用NodeList　　283<br>10.3　小结　　284<br>第11章　DOM扩展　　286<br>11.1　选择符API　　286<br>11.1.1　querySelector()方法　　286<br>11.1.2　querySelectorAll()<br>方法　　287<br>11.1.3　matchesSelector()<br>方法　　288<br>11.2　元素遍历　　288<br>11.3　HTML5　　289<br>11.3.1　与类相关的扩充　　289<br>11.3.2　焦点管理　　291<br>11.3.3　HTMLDocument的变化　　292<br>11.3.4　字符集属性　　293<br>11.3.5　自定义数据属性　　293<br>11.3.6　插入标记　　294<br>11.3.7　scrollIntoView()方法　　298<br>11.4　专有扩展　　298<br>11.4.1　文档模式　　298<br>11.4.2　children属性　　299<br>11.4.3　contains()方法　　300<br>11.4.4　插入文本　　301<br>11.4.5　滚动　　303<br>11.5　小结　　304<br>第12章　DOM2和DOM3　　305<br>12.1　DOM变化　　305<br>12.1.1　针对XML命名空间的变化　　306<br>12.1.2　其他方面的变化　　309<br>12.2　样式　　312<br>12.2.1　访问元素的样式　　313<br>12.2.2　操作样式表　　317<br>12.2.3　元素大小　　320<br>12.3　遍历　　326<br>12.3.1　NodeIterator　　328<br>12.3.2　TreeWalker　　330<br>12.4　范围　　332<br>12.4.1　DOM中的范围　　332<br>12.4.2　IE8及更早版本中的范围　　340<br>12.5　小结　　343<br>第13章　事件　　345<br>13.1　事件流　　345<br>13.1.1　事件冒泡　　346<br>13.1.2　事件捕获　　346<br>13.1.3　DOM事件流　　347<br>13.2　事件处理程序　　348<br>13.2.1　HTML事件处理程序　　348<br>13.2.2　DOM0级事件处理程序　　350<br>13.2.3　DOM2级事件处理程序　　351<br>13.2.4　IE事件处理程序　　352<br>13.2.5　跨浏览器的事件处理程序　　353<br>13.3　事件对象　　355<br>13.3.1　DOM中的事件对象　　355<br>13.3.2　IE中的事件对象　　358<br>13.3.3　跨浏览器的事件对象　　360<br>13.4　事件类型　　362<br>13.4.1　UI事件　　362<br>13.4.2　焦点事件　　367<br>13.4.3　鼠标与滚轮事件　　368<br>13.4.4　键盘与文本事件　　379<br>13.4.5　复合事件　　384<br>13.4.6　变动事件　　385<br>13.4.7　HTML5事件　　388<br>13.4.8　设备事件　　395<br>13.4.9　触摸与手势事件　　399<br>13.5　内存和性能　　402<br>13.5.1　事件委托　　402<br>13.5.2　移除事件处理程序　　404<br>13.6　模拟事件　　405<br>13.6.1　DOM中的事件模拟　　405<br>13.6.2　IE中的事件模拟　　410<br>13.7　小结　　411<br>第14章　表单脚本　　412<br>14.1　表单的基础知识　　412<br>14.1.1　提交表单　　413<br>14.1.2　重置表单　　414<br>14.1.3　表单字段　　414<br>14.2　文本框脚本　　419<br>14.2.1　选择文本　　420<br>14.2.2　过滤输入　　423<br>14.2.3　自动切换焦点　　426<br>14.2.4　HTML5约束验证API　　427<br>14.3　选择框脚本　　431<br>14.3.1　选择选项　　432<br>14.3.2　添加选项　　434<br>14.3.3　移除选项　　435<br>14.3.4　移动和重排选项　　435<br>14.4　表单序列化　　436<br>14.5　富文本编辑　　438<br>14.5.1　使用contenteditable<br>属性　　438<br>14.5.2　操作富文本　　439<br>14.5.3　富文本选区　　441<br>14.5.4　表单与富文本　　443<br>14.6　小结　　443<br>第15章　使用Canvas绘图　　445<br>15.1　基本用法　　445<br>15.2　2D上下文　　446<br>15.2.1　填充和描边　　446<br>15.2.2　绘制矩形　　447<br>15.2.3　绘制路径　　449<br>15.2.4　绘制文本　　451<br>15.2.5　变换　　453<br>15.2.6　绘制图像　　456<br>15.2.7　阴影　　457<br>15.2.8　渐变　　458<br>15.2.9　模式　　460<br>15.2.10　使用图像数据　　460<br>15.2.11　合成　　462<br>15.3　WebGL　　463<br>15.3.1　类型化数组　　463<br>15.3.2　WebGL上下文　　468<br>15.3.3　支持　　478<br>15.4　小结　　478<br>第16章　HTML5脚本编程　　480<br>16.1　跨文档消息传递　　480<br>16.2　原生拖放　　481<br>16.2.1　拖放事件　　482<br>16.2.2　自定义放置目标　　482<br>16.2.3　dataTransfer对象　　483<br>16.2.4　dropEffect与effectAllowed　　484<br>16.2.5　可拖动　　485<br>16.2.6　其他成员　　485<br>16.3　媒体元素　　486<br>16.3.1　属性　　487<br>16.3.2　事件　　488<br>16.3.3　自定义媒体播放器　　488<br>16.3.4　检测编解码器的支持情况　　489<br>16.3.5　Audio类型　　490<br>16.4　历史状态管理　　491<br>16.5　小结　　492<br>第17章　错误处理与调试　　493<br>17.1　浏览器报告的错误　　493<br>17.1.1　IE　　493<br>17.1.2　Firefox　　494<br>17.1.3　Safari　　496<br>17.1.4　Opera　　497<br>17.1.5　Chrome　　498<br>17.2　错误处理　　499<br>17.2.1　try-catch语句　　500<br>17.2.2　抛出错误　　503<br>17.2.3　错误（error）事件　　505<br>17.2.4　处理错误的策略　　506<br>17.2.5　常见的错误类型　　507<br>17.2.6　区分致命错误和非致命<br>错误　　510<br>17.2.7　把错误记录到服务器　　511<br>17.3　调试技术　　512<br>17.3.1　将消息记录到控制台　　512<br>17.3.2　将消息记录到当前页面　　515<br>17.3.3　抛出错误　　515<br>17.4　常见的IE错误　　516<br>17.4.1　操作终止　　516<br>17.4.2　无效字符　　518<br>17.4.3　未找到成员　　518<br>17.4.4　未知运行时错误　　519<br>17.4.5　语法错误　　519<br>17.4.6　系统无法找到指定资源　　519<br>17.5　小结　　520<br>第18章　JavaScript与XML　　521<br>18.1　浏览器对XML DOM的支持　　521<br>18.1.1　DOM2级核心　　521<br>18.1.2　DOMParser类型　　522<br>18.1.3　XMLSerializer类型　　523<br>18.1.4　IE8及之前版本中的XML　　523<br>18.1.5　跨浏览器处理XML　　527<br>18.2　浏览器对XPath的支持　　529<br>18.2.1　DOM3级XPath　　529<br>18.2.2　IE中的XPath　　534<br>18.2.3　跨浏览器使用XPath　　535<br>18.3　浏览器对XSLT的支持　　537<br>18.3.1　IE中的XSLT　　537<br>18.3.2　XSLTProcessor类型　　541<br>18.3.3　跨浏览器使用XSLT　　543<br>18.4　小结　　544<br>第19章　E4X　　546<br>19.1　E4X的类型　　546<br>19.1.1　XML类型　　546<br>19.1.2　XMLList类型　　547<br>19.1.3　Namespace类型　　548<br>19.1.4　QName类型　　549<br>19.2　一般用法　　550<br>19.2.1　访问特性　　551<br>19.2.2　其他节点类型　　552<br>19.2.3　查询　　553<br>19.2.4　构建和操作XML　　555<br>19.2.5　解析和序列化　　557<br>19.2.6　命名空间　　558<br>19.3　其他变化　　559<br>19.4　全面启用E4X　　560<br>19.5　小结　　561<br>第20章　JSON　　562<br>20.1　语法　　562<br>20.1.1　简单值　　562<br>20.1.2　对象　　563<br>20.1.3　数组　　564<br>20.2　解析与序列化　　565<br>20.2.1　JSON对象　　565<br>20.2.2　序列化选项　　566<br>20.2.3　解析选项　　569<br>20.3　小结　　570<br>第21章　Ajax与Comet　　571<br>21.1　XMLHttpRequest对象　　571<br>21.1.1　XHR的用法　　573<br>21.1.2　HTTP头部信息　　575<br>21.1.3　GET请求　　576<br>21.1.4　POST请求　　577<br>21.2　XMLHttpRequest 2级　　578<br>21.2.1　FormData　　578<br>21.2.2　超时设定　　579<br>21.2.3　overrideMimeType()<br>方法　　580<br>21.3　进度事件　　580<br>21.3.1　load事件　　580<br>21.3.2　progress事件　　581<br>21.4　跨源资源共享　　582<br>21.4.1　IE对CORS的实现　　582<br>21.4.2　其他浏览器对CORS的<br>实现　　584<br>21.4.3　Preflighted Reqeusts　　584<br>21.4.4　带凭据的请求　　585<br>21.4.5　跨浏览器的CORS　　585<br>21.5　其他跨域技术　　586<br>21.5.1　图像Ping　　586<br>21.5.2　JSONP　　587<br>21.5.3　Comet　　588<br>21.5.4　服务器发送事件　　590<br>21.5.5　Web Sockets　　591<br>21.5.6　SSE与Web Sockets　　593<br>21.6　安全　　593<br>21.7　小结　　594<br>第22章　高级技巧　　596<br>22.1　高级函数　　596<br>22.1.1　安全的类型检测　　596<br>22.1.2　作用域安全的构造函数　　597<br>22.1.3　惰性载入函数　　600<br>22.1.4　函数绑定　　602<br>22.1.5　函数柯里化　　604<br>22.2　防篡改对象　　606<br>22.2.1　不可扩展对象　　606<br>22.2.2　密封的对象　　607<br>22.2.3　冻结的对象　　608<br>22.3　高级定时器　　609<br>22.3.1　重复的定时器　　610<br>22.3.2　Yielding Processes　　612<br>22.3.3　函数节流　　614<br>22.4　自定义事件　　616<br>22.5　拖放　　618<br>22.5.1　修缮拖动功能　　620<br>22.5.2　添加自定义事件　　622<br>22.6　小结　　624<br>第23章　离线应用与客户端存储　　626<br>23.1　离线检测　　626<br>23.2　应用缓存　　627<br>23.3　数据存储　　628<br>23.3.1　Cookie　　629<br>23.3.2　IE用户数据　　637<br>23.3.3　Web存储机制　　638<br>23.3.4　IndexedDB　　643<br>23.4　小结　　654<br>第24章　最佳实践　　656<br>24.1　可维护性　　656<br>24.1.1　什么是可维护的代码　　656<br>24.1.2　代码约定　　657<br>24.1.3　松散耦合　　659<br>24.1.4　编程实践　　662<br>24.2　性能　　666<br>24.2.1　注意作用域　　666<br>24.2.2　选择正确方法　　667<br>24.2.3　最小化语句数　　672<br>24.2.4　优化DOM交互　　673<br>24.3　部署　　676<br>24.3.1　构建过程　　676<br>24.3.2　验证　　677<br>24.3.3　压缩　　679<br>24.4　小结　　681<br>第25章　新兴的API　　682<br>25.1　requestAnimationFrame()　　682<br>25.1.1　早期动画循环　　682<br>25.1.2　循环间隔的问题　　683<br>25.1.3　mozRequestAnimation-Frame　　683<br>25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685<br>25.2　Page Visibility API　　686<br>25.3　Geolocation API　　687<br>25.4　File API　　689<br>25.4.1　FileReader类型　　690<br>25.4.2　读取部分内容　　692<br>25.4.3　对象URL　　693<br>25.4.4　读取拖放的文件　　694<br>25.4.5　使用XHR上传文件　　695<br>25.5　Web计时　　696<br>25.6　Web Workers　　697<br>25.6.1　使用Worker　　697<br>25.6.2　Worker全局作用域　　698<br>25.6.3　包含其他脚本　　699<br>25.6.4　Web Workers的未来　　700<br>25.7　小结　　700<br>附录A　ECMAScript Harmony　　701<br>附录B　严格模式　　717<br>附录C　JavaScript库　　723<br>附录D　JavaScript工具　　727</p><h3 id="JavaScript高级程序设计（第4版）-PDF-下载"><a href="#JavaScript高级程序设计（第4版）-PDF-下载" class="headerlink" title="JavaScript高级程序设计（第4版） PDF 下载"></a>JavaScript高级程序设计（第4版） PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1Fqb6xidYDQb9Q-CRzeZh7Q?pwd=dr22">https://pan.baidu.com/s/1Fqb6xidYDQb9Q-CRzeZh7Q?pwd=dr22</a> </p><p>提取码: dr22 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《持续交付2.0：业务引领的DevOps精要》</title>
      <link href="/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/"/>
      <url>/2023/05/23/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%982.0%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%BC%95%E9%A2%86%E7%9A%84DevOps%E7%B2%BE%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/1a3aea4bb6854e7de11011ef09cecc2b.png" alt="《持续交付2.0：业务引领的DevOps精要》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</p><p>本书分三个部分。第一部分作者根据自己近十年的工作及咨询经历，不断总结、提炼和反思，对原有的持续交付进行了修正，重新定义持续交付为实现组织战略目标的能力，并引入持续交付的能力模型；</p><p>第二部分阐述组织打造持续交付能力所需遵守的原则，包括基础原则、组织原则和架构原则；</p><p>第三部分通过多个互联网公司案例的解读，阐述如何根据组织的当前状况，应用原则，并对最佳实践进行取舍，快速达到组织能力目标。</p><p>本书适合大型互联网公司的技术VP、技术负责人，中小型互联网公司的CTO、技术VP、研发&#x2F;测试&#x2F;运维负责人、主管及骨干，以及组织变革者阅读。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>乔梁</p><p>敏思特咨询公司联合创始人，持续交付领域专家，著名敏捷与精益转型导师，腾讯外聘高级管理顾问。拥有多年IT从业经验，曾就职于百度、Nokia等国内外知名软件公司，并先后担任多个互联网公司的高级管理顾问，帮助多个产品线取得业务上的成功突破。曾为华为、上汽等非互联网软件企业提供敏捷转型咨询服务，指导解决组织转型与研发管理方面的相关问题。</p><p>乔梁是国内最早致力于通过敏捷开发与精益理论改善软件价值交付效率的实践者之一，精研各种软件工程方法论，2010年翻译《持续交付》一书，并将其融会贯通，成为持续交付和DevOps理念在国内的首批实践者和布道者，经过八年的管理实践，总结提炼，提出持续交付双环模型，并将工作心得整理成册，取名《持续交付2.0》，将关注点前移至业务价值的持续探索与快速验证方法。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章　持续交付2.0 1<br>1.1　软件工程发展概述 1<br>1.1.1　瀑布软件开发方法 1<br>1.1.2　敏捷软件开发方法 2<br>1.1.3　DevOps运动 3<br>1.1.4　持续交付1.0 4<br>1.2　持续交付2.0 7<br>1.2.1　精益思想 8<br>1.2.2　双环模型 9<br>1.2.3　4个核心原则 11<br>1.2.4　持续交付七巧板 12<br>1.3　小结 13<br>第2章　价值探索环 14<br>2.1　探索环的意义 14<br>2.2　探索环的4个关键环节 15<br>2.2.1　提问 16<br>2.2.2　锚定 17<br>2.2.3　共创 19<br>2.2.4　精炼 22<br>2.3　工作原则 24<br>2.3.1　分解并快速试错 24<br>2.3.2　一次只验证一点 25<br>2.3.3　允许失败 26<br>2.4　共创与精炼的常用方法 27<br>2.4.1　装饰窗方法 27<br>2.4.2　最小可行特性法 29<br>2.4.3　特区法 30<br>2.4.4　定向探索法 30<br>2.4.5　稻草人法 31<br>2.4.6　最小可行产品法 32<br>2.5　实施注意事项 32<br>2.6　小结 35<br>第3章　快速验证环 36<br>3.1　验证环的目标 36<br>3.2　验证环的4个关键环节 37<br>3.2.1　构建 37<br>3.2.2　运行 38<br>3.2.3　监测 39<br>3.2.4　决策 39<br>3.3　工作原则 39<br>3.3.1　质量内建 39<br>3.3.2　消除等待 40<br>3.3.3　重复事务自动化 43<br>3.3.4　监测一切 43<br>3.4　小结 44<br>第4章　持续交付2.0的组织文化 45<br>4.1　安全、信任与持续改善 45<br>4.1.1　失败是安全的 45<br>4.1.2　相互信任 45<br>4.1.3　持续改善 46<br>4.2　文化塑造四步法 46<br>4.2.1　行为决定文化 46<br>4.2.2　谷歌的工程师质量文化 48<br>4.2.3　Etsy的持续试验文化 49<br>4.3　行动原则 50<br>4.3.1　价值导向 51<br>4.3.2　快速验证 51<br>4.3.3　持续学习 51<br>4.4　度量原则 55<br>4.4.1　度量指标的4类属性 56<br>4.4.2　度量的目标是改善 57<br>4.5　“改善套路”进行持续改进 57<br>4.6　小结 58<br>第5章　持续交付的软件系统架构 60<br>5.1　“大系统小做”原则 61<br>5.1.1　持续交付架构要求 61<br>5.1.2　系统拆分原则 61<br>5.2　常见架构模式 62<br>5.2.1　微核架构 62<br>5.2.2　微服务架构 63<br>5.2.3　巨石应用 64<br>5.3　架构改造实施模式 66<br>5.3.1　拆迁者模式 67<br>5.3.2　绞杀者模式 68<br>5.3.3　修缮者模式 68<br>5.3.4　数据库的拆分方法 70<br>5.4　小结 70<br>第6章　业务需求协作管理 72<br>6.1　产品版本周期概述 73<br>6.1.1　准备期 73<br>6.1.2　交付期 74<br>6.2　需求拆分的利与弊 75<br>6.2.1　需求拆分的收益 76<br>6.2.2　需求拆分的成本 78<br>6.3　需求拆分方法 79<br>6.3.1　需求的来源 80<br>6.3.2　技术债也是需求 80<br>6.3.3　参与需求拆分的角色 81<br>6.3.4　不平等的INVEST原则 82<br>6.3.5　五大拆分技法 82<br>6.3.6　七大组成部分 84<br>6.4　需求分析与管理工具集 85<br>6.4.1　用户故事地图 85<br>6.4.2　用户故事树 86<br>6.4.3　依赖关系图 87<br>6.4.4　需求管理数字化平台 87<br>6.5　团队协作管理工具 87<br>6.5.1　团队共享日历 88<br>6.5.2　团队回顾 89<br>6.5.3　可视化故事墙 90<br>6.5.4　明确“完成”的定义 90<br>6.5.5　持续集成 91<br>6.5.6　故事验证 91<br>6.6　小结 91<br>第7章　部署流水线原则与工具设计 92<br>7.1　简单的部署流水线 92<br>7.1.1　简单的产品研发流程 92<br>7.1.2　初始部署流水线 93<br>7.1.3　流水线执行状态解析 95<br>7.2　部署流水线的设计与使用 95<br>7.2.1　流水线的设计原则 95<br>7.2.2　团队的协作纪律 97<br>7.3　部署流水线平台的构成 97<br>7.3.1　工具链总体架构 97<br>7.3.2　平台应当具备的基本能力 99<br>7.3.3　工具链建设策略 100<br>7.4　基础支撑服务的云化 100<br>7.4.1　基础支撑服务的协作过程解析 101<br>7.4.2　编译构建管理服务 103<br>7.4.3　自动化测试管理服务 104<br>7.4.4　软件部署管理服务 105<br>7.4.5　基础环境管理服务 106<br>7.5　企业制品库的管理 107<br>7.5.1　制品库的分类 107<br>7.5.2　制品库的管理原则 108<br>7.6　多种多样的部署流水线 108<br>7.6.1　多组件的部署流水线 108<br>7.6.2　个人部署流水线 109<br>7.6.3　部署流水线的不断演进 110<br>7.7　为开发者构建自助式工具 111<br>7.8　小结 113<br>第8章　利于集成的分支策略 114<br>8.1　版本控制系统的使用目的 114<br>8.1.1　集中式版本控制系统 114<br>8.1.2　分布式版本控制系统 115<br>8.1.3　版本控制系统中的基本概念 117<br>8.2　常见分支开发模式 118<br>8.2.1　主干开发，主干发布 118<br>8.2.2　主干开发，分支发布 119<br>8.2.3　分支开发，主干发布 121<br>8.3　分支模式的演化 126<br>8.3.1　三驾马车分支模式 126<br>8.3.2　Gitflow分支模式 127<br>8.3.3　GitHubFlow分支模式 128<br>8.4　分支策略的选择 128<br>8.4.1　版本发布模式 128<br>8.4.2　分支策略与发布周期的关系 132<br>8.5　小结 133<br>第9章　持续集成 134<br>9.1　起源与定义 134<br>9.1.1　原始定义 135<br>9.1.2　一次集成过程 135<br>9.2　六步提交法 136<br>9.2.1　4个关键点 138<br>9.2.2　同步与异步模式 139<br>9.2.3　自查表 140<br>9.3　速度与质量的权衡 141<br>9.3.1　分级构建 142<br>9.3.2　多人同时提交的构建 142<br>9.3.3　云平台的威力 143<br>9.4　在团队中实施持续集成实践 145<br>9.4.1　快速建立团队的持续集成实践 146<br>9.4.2　分支策略与部署流水线 148<br>9.5　常见的实施问题 150<br>9.5.1　工程师的开发习惯 151<br>9.5.2　视而不见的扫描问题 151<br>9.5.3　自动化测试用例的缺乏 151<br>9.6　小结 152<br>第10章　自动化测试策略与方法 153<br>10.1　自动化测试的自身定位 153<br>10.1.1　自动化测试的优势 154<br>10.1.2　自动化测试所需的投入 155<br>10.2　突破传统自动化测试的困境 156<br>10.2.1　传统自动化测试的特点 157<br>10.2.2　自动化测试的分层 157<br>10.2.3　不同类型的测试金字塔 160<br>10.3　自动化测试的实施策略 163<br>10.3.1　增加自动化测试用例的着手点 163<br>10.3.2　提高自动化测试的执行次数 164<br>10.3.3　良好自动化测试的特征 165<br>10.3.4　共享自动化测试的维护职责 166<br>10.3.5　代码测试覆盖率 167<br>10.4　用户验收自动化测试要点 168<br>10.4.1　先搭建分层框架 168<br>10.4.2　测试用例数应保持低位 171<br>10.4.3　为自动化测试用例预留API 171<br>10.4.4　为调试做好准备 171<br>10.4.5　测试数据的准备 171<br>10.5　其他质量检查方法 173<br>10.5.1　差异批注测试方法 173<br>10.5.2　代码规范检查与代码动静态检测 174<br>10.5.3　AI在测试领域的应用 174<br>10.6　小结 175<br>第11章　软件配置管理 176<br>11.1　将一切纳入配置管理 176<br>11.1.1　配置管理目标 176<br>11.1.2　配置管理的范围 177<br>11.1.3　软件配置管理原则 177<br>11.2　软件包的版本管理 181<br>11.2.1　包管理的反模式 181<br>11.2.2　集中式包管理服务 182<br>11.2.3　软件包的元信息 183<br>11.3　包依赖管理 185<br>11.3.1　显式声明依赖 185<br>11.3.2　自动管理依赖 187<br>11.3.3　减少复杂依赖 188<br>11.4　环境基础设施管理 191<br>11.4.1　环境准备的4种状态 191<br>11.4.2　领域专属语言的应用 197<br>11.4.3　环境基础设施即代码 198<br>11.5　软件配置项的管理 199<br>11.5.1　二进制与配置项的分离 199<br>11.5.2　配置信息的版本管理 200<br>11.5.3　配置项的存储组织方式 201<br>11.5.4　配置漂移与治理 202<br>11.6　不可变基础设施与云应用 203<br>11.6.1　实现不可变基础设施 203<br>11.6.2　云原生应用 206<br>11.6.3　优势与挑战 206<br>11.7　数据的版本管理 208<br>11.7.1　数据库结构变更 208<br>11.7.2　数据文件 208<br>11.8　需求与源代码的版本关联 209<br>11.9　小结 209<br>第12章　低风险发布 211<br>12.1　高频发布是一种趋势 211<br>12.1.1　互联网企业的高频发布 212<br>12.1.2　收益与成本共存 214<br>12.2　降低发布风险的方法 215<br>12.2.1　蓝绿部署 215<br>12.2.2　滚动部署 216<br>12.2.3　金丝雀发布与灰度发布 217<br>12.2.4　暗部署 218<br>12.3　高频发布支撑技术 219<br>12.3.1　功能开关技术 220<br>12.3.2　数据迁移技术 222<br>12.3.3　抽象分支方法 225<br>12.3.4　升级替代回滚 226<br>12.4　影响发布频率的因素 227<br>12.5　小结 228<br>第13章　监测与决策 229<br>13.1　生产监测范围 230<br>13.1.1　后台服务的监测 230<br>13.1.2　分发软件的监测 230<br>13.2　数据监测体系 231<br>13.2.1　收集与处理 231<br>13.2.2　数据的标准化 232<br>13.2.3　监测数据体系及其能力衡量 233<br>13.3　问题处理体系 235<br>13.3.1　告警海洋与智能化管理 235<br>13.3.2　问题处理是一个学习过程 236<br>13.4　生产环境测试 237<br>13.4.1　测试活动扁平化趋势 237<br>13.4.2　生产环境中的测试 239<br>13.4.3　混沌工程 239<br>13.5　向东，还是向西 240<br>13.6　小结 241<br>第14章　大型互联网团队的FT化 242<br>14.1　简介 242<br>14.1.1　改进前状态 243<br>14.1.2　改进后状态 244<br>14.2　改进方法论 245<br>14.2.1　指导思想 245<br>14.2.2　改进步骤 245<br>14.3　改进的历程 246<br>14.3.1　架构解耦 246<br>14.3.2　组织解耦 248<br>14.3.3　研发流程再造 250<br>14.3.4　自动化一切 259<br>14.4　小结 260<br>第15章　小团队逆袭之旅 262<br>15.1　背景简介 262<br>15.1.1　改进前的“死亡行军”之旅 264<br>15.1.2　改进后的无缺陷交付 264<br>15.2　改进方法论 265<br>15.2.1　指导思想 265<br>15.2.2　试点团队的选择 265<br>15.3　第一阶段：研发准备期 266<br>15.3.1　功能简介与需求拆分 266<br>15.3.2　架构设计与需求依赖识别 267<br>15.3.3　工作量估算与排期 268<br>15.4　第二阶段：软件交付期 270<br>15.4.1　通过可视化看板改进工作流程 270<br>15.4.2　无缺陷交付 277<br>15.4.3　主干开发与持续集成 278<br>15.4.4　测试活动左移 279<br>15.4.5　代码评审 279<br>15.4.6　关注结果，更要关注过程 280<br>15.5　小结 281<br>第16章　研发推动的DevOps 283<br>16.1　改进的关键点 285<br>16.1.1　改进方法论 285<br>16.1.2　定义改进目标 285<br>16.2　第一阶段：敏捷101 287<br>16.2.1　做个靠谱的计划 287<br>16.2.2　开发阶段启航 291<br>16.2.3　对过程质量的约束 294<br>16.2.4　阶段性改进点 301<br>16.3　第二阶段：DevOps转型 302<br>16.3.1　与运维人员的“冲突” 303<br>16.3.2　高频部署发布中的具体障碍 304<br>16.3.3　整体解决方案的设计 304<br>16.3.4　DevOps阶段的团队改变 308<br>16.4　小结 308<br>附录A　软件工程的三次进化 310<br>附录B　排序法做相对估算 323</p><h3 id="持续交付2-0：业务引领的DevOps精要-PDF-下载"><a href="#持续交付2-0：业务引领的DevOps精要-PDF-下载" class="headerlink" title="持续交付2.0：业务引领的DevOps精要 PDF 下载"></a>持续交付2.0：业务引领的DevOps精要 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1f5rwnteuOfkNyRhEyR0iSw?pwd=h384">https://pan.baidu.com/s/1f5rwnteuOfkNyRhEyR0iSw?pwd=h384</a></p><p>提取码: h384 </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> 持续交付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解Java虚拟机（第3版）》</title>
      <link href="/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/"/>
      <url>/2023/05/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5(%E7%AC%AC3%E7%89%88)/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/e0e32b23ce83f43911565b8216a4c7e7.png" alt="《深入理解Java虚拟机（第3版）》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典，繁体版在台湾也颇受欢迎。</p><p>自2011年上市以来，前两个版本累计印刷36次，销量超过30万册，两家主要网络书店的评论近90000条，内容上近乎零差评，是原创计算机图书领域不可逾越的丰碑。</p><p>第3版在第2版的基础上做了重大修订，内容更丰富、实战性更强：根据新版JDK对内容进行了全方位的修订和升级，围绕新技术和生产实践新增逾10万字，包含近50%的全新内容，并对第2版中含糊、瑕疵和错误内容进行了修正。</p><p>全书一共13章，分为五大部分：</p><p>第一部分（第1章）走近Java</p><p>系统介绍了Java的技术体系、发展历程、虚拟机家族，以及动手编译JDK，了解这部分内容能对学习JVM提供良好的指引。</p><p>第二部分（第2~5章）自动内存管理</p><p>详细讲解了Java的内存区域与内存溢出、垃圾收集器与内存分配策略、虚拟机性能监控与故障排除等与自动内存管理相关的内容，以及10余个经典的性能优化案例和优化方法；</p><p>第三部分（第6~9章）虚拟机执行子系统</p><p>深入分析了虚拟机执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎，以及多个类加载及其执行子系统的实战案例；</p><p>第四部分（第10~11章）程序编译与代码优化</p><p>详细讲解了程序的前、后端编译与优化，包括前端的易用性优化措施，如泛型、主动装箱拆箱、条件编译等的内容的深入分析；以及后端的性能优化措施，如虚拟机的热点探测方法、HotSpot 的即时编译器、提前编译器，以及各种常见的编译期优化技术；</p><p>第五部分（第12~13章）高效并发</p><p>主要讲解了Java实现高并发的原理，包括Java的内存模型、线程与协程，以及线程安全和锁优化。</p><p>全书以实战为导向，通过大量与实际生产环境相结合的案例分析和展示了解决各种Java技术难题的方案和技巧。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>资深Java技术、机器学习和企业级开发技术专家，现任远光软件研究院院长，人工智能博士在读，著有知名畅销书《深入理解Java虚拟机：JVM高级特性与最佳实践》。</p><p>开源技术的积极倡导者和推动者，对计算机科学和相关的多个领域都有深刻的见解，尤其是人工智能、Java开发和敏捷开发等领域。曾受邀在InfoQ和IBM DeveloperWorks等网站撰写技术专栏。</p><p>著作颇丰，著有《深入理解Java虚拟机》《深入理解OSGi》，翻译了《Java虚拟机规范》等著作。其中《深入理解Java虚拟机》第1版出版于2011年，已经出至第2版，不仅销量好，而且口碑更好，累计印刷超过30次，仍长销不衰，是中文计算机图书领域公认的、难得一见的佳作。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分　走近Java<br>第1章　走近Java 2<br>1.1　概述 2<br>1.2　Java技术体系 3<br>1.3　Java发展史 4<br>1.4　Java虚拟机家族 12<br>1.4.1　虚拟机始祖：Sun Classic&#x2F;Exact VM 12<br>1.4.2　武林盟主：HotSpot VM 13<br>1.4.3　小家碧玉：Mobile&#x2F;Embedded VM 14<br>1.4.4　天下第二：BEA JRockit&#x2F;IBM J9 VM 15<br>1.4.5　软硬合璧：BEA Liquid VM&#x2F;Azul VM 16<br>1.4.6　挑战者：Apache Harmony&#x2F;Google Android Dalvik VM 17<br>1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18<br>1.4.8　百家争鸣 19<br>1.5　展望Java技术的未来 21<br>1.5.1　无语言倾向 21<br>1.5.2　新一代即时编译器 23<br>1.5.3　向Native迈进 24<br>1.5.4　灵活的胖子 26<br>1.5.5　语言语法持续增强 27<br>1.6　实战：自己编译JDK 29<br>1.6.1　获取源码 29<br>1.6.2　系统需求 31<br>1.6.3　构建编译环境 33<br>1.6.4　进行编译 34<br>1.6.5　在IDE工具中进行源码调试 36<br>1.7　本章小结 39<br>第二部分　自动内存管理<br>第2章　Java内存区域与内存溢出异常 42<br>2.1　概述 42<br>2.2　运行时数据区域 42<br>2.2.1　程序计数器 43<br>2.2.2　Java虚拟机栈 43<br>2.2.3　本地方法栈 44<br>2.2.4　Java堆 44<br>2.2.5　方法区 46<br>2.2.6　运行时常量池 47<br>2.2.7　直接内存 47<br>2.3　HotSpot虚拟机对象探秘 48<br>2.3.1　对象的创建 48<br>2.3.2　对象的内存布局 51<br>2.3.3　对象的访问定位 52<br>2.4　实战：OutOfMemoryError异常 53<br>2.4.1　Java堆溢出 54<br>2.4.2　虚拟机栈和本地方法栈溢出 56<br>2.4.3　方法区和运行时常量池溢出 61<br>2.4.4　本机直接内存溢出 65<br>2.5　本章小结 66<br>第3章　垃圾收集器与内存分配策略 67<br>3.1　概述 67<br>3.2　对象已死？ 68<br>3.2.1　引用计数算法 68<br>3.2.2　可达性分析算法 70<br>3.2.3　再谈引用 71<br>3.2.4　生存还是死亡？ 72<br>3.2.5　回收方法区 74<br>3.3　垃圾收集算法 75<br>3.3.1　分代收集理论 75<br>3.3.2　标记-清除算法 77<br>3.3.3　标记-复制算法 78<br>3.3.4　标记-整理算法 79<br>3.4　HotSpot的算法细节实现 81<br>3.4.1　根节点枚举 81<br>3.4.2　安全点 82<br>3.4.3　安全区域 83<br>3.4.4　记忆集与卡表 84<br>3.4.5　写屏障 85<br>3.4.6　并发的可达性分析 87<br>3.5　经典垃圾收集器 89<br>3.5.1　Serial收集器 90<br>3.5.2　ParNew收集器 92<br>3.5.3　Parallel Scavenge收集器 93<br>3.5.4　Serial Old收集器 94<br>3.5.5　Parallel Old收集器 95<br>3.5.6　CMS收集器 96<br>3.5.7　Garbage First收集器 98<br>3.6　低延迟垃圾收集器 104<br>3.6.1　Shenandoah收集器 105<br>3.6.2　ZGC收集器 112<br>3.7　选择合适的垃圾收集器 121<br>3.7.1　Epsilon收集器 121<br>3.7.2　收集器的权衡 121<br>3.7.3　虚拟机及垃圾收集器日志 122<br>3.7.4　垃圾收集器参数总结 127<br>3.8　实战：内存分配与回收策略 129<br>3.8.1　对象优先在Eden分配 130<br>3.8.2　大对象直接进入老年代 131<br>3.8.3　长期存活的对象将进入老年代 132<br>3.8.4　动态对象年龄判定 134<br>3.8.5　空间分配担保 135<br>3.9　本章小结 137<br>第4章　虚拟机性能监控、故障处理工具 138<br>4.1　概述 138<br>4.2　基础故障处理工具 138<br>4.2.1　jps：虚拟机进程状况工具 141<br>4.2.2　jstat：虚拟机统计信息监视工具 142<br>4.2.3　jinfo：Java配置信息工具 143<br>4.2.4　jmap：Java内存映像工具 144<br>4.2.5　jhat：虚拟机堆转储快照分析工具 145<br>4.2.6　jstack：Java堆栈跟踪工具 146<br>4.2.7　基础工具总结 148<br>4.3　可视化故障处理工具 151<br>4.3.1　JHSDB：基于服务性代理的调试工具 152<br>4.3.2　JConsole：Java监视与管理控制台 157<br>4.3.3　VisualVM：多合-故障处理工具 164<br>4.3.4　Java Mission Control：可持续在线的监控工具 171<br>4.4　HotSpot虚拟机插件及工具 175<br>4.5　本章小结 180<br>第5章　调优案例分析与实战 181<br>5.1　概述 181<br>5.2　案例分析 181<br>5.2.1　大内存硬件上的程序部署策略 182<br>5.2.2　集群间同步导致的内存溢出 184<br>5.2.3　堆外内存导致的溢出错误 185<br>5.2.4　外部命令导致系统缓慢 187<br>5.2.5　服务器虚拟机进程崩溃 187<br>5.2.6　不恰当数据结构导致内存占用过大 188<br>5.2.7　由Windows虚拟内存导致的长时间停顿 189<br>5.2.8　由安全点导致长时间停顿 190<br>5.3　实战：Eclipse运行速度调优 192<br>5.3.1　调优前的程序运行状态 193<br>5.3.2　升级JDK版本的性能变化及兼容问题 196<br>5.3.3　编译时间和类加载时间的优化 200<br>5.3.4　调整内存设置控制垃圾收集频率 203<br>5.3.5　选择收集器降低延迟 206<br>5.4　本章小结 209<br>第三部分　虚拟机执行子系统<br>第6章　类文件结构 212<br>6.1　概述 212<br>6.2　无关性的基石 212<br>6.3　Class类文件的结构 214<br>6.3.1　魔数与Class文件的版本 215<br>6.3.2　常量池 218<br>6.3.3　访问标志 224<br>6.3.4　类索引、父类索引与接口索引集合 225<br>6.3.5　字段表集合 226<br>6.3.6　方法表集合 229<br>6.3.7　属性表集合 230<br>6.4　字节码指令简介 251<br>6.4.1　字节码与数据类型 251<br>6.4.2　加载和存储指令 253<br>6.4.3　运算指令 254<br>6.4.4　类型转换指令 255<br>6.4.5　对象创建与访问指令 256<br>6.4.6　操作数栈管理指令 256<br>6.4.7　控制转移指令 257<br>6.4.8　方法调用和返回指令 257<br>6.4.9　异常处理指令 258<br>6.4.10　同步指令 258<br>6.5　公有设计，私有实现 259<br>6.6　Class文件结构的发展 260<br>6.7　本章小结 261<br>第7章　虚拟机类加载机制 262<br>7.1　概述 262<br>7.2　类加载的时机 263<br>7.3　类加载的过程 267<br>7.3.1　加载 267<br>7.3.2　验证 268<br>7.3.3　准备 271<br>7.3.4　解析 272<br>7.3.5　初始化 277<br>7.4　类加载器 279<br>7.4.1　类与类加载器 280<br>7.4.2　双亲委派模型 281<br>7.4.3　破坏双亲委派模型 285<br>7.5　Java模块化系统 287<br>7.5.1　模块的兼容性 288<br>7.5.2　模块化下的类加载器 290<br>7.6　本章小结 292<br>第8章　虚拟机字节码执行引擎 293<br>8.1　概述 293<br>8.2　运行时栈帧结构 294<br>8.2.1　局部变量表 294<br>8.2.2　操作数栈 299<br>8.2.3　动态连接 300<br>8.2.4　方法返回地址 300<br>8.2.5　附加信息 301<br>8.3　方法调用 301<br>8.3.1　解析 301<br>8.3.2　分派 303<br>8.4　动态类型语言支持 315<br>8.4.1　动态类型语言 316<br>8.4.2　Java与动态类型 317<br>8.4.3　java.lang.invoke包 318<br>8.4.4　invokedynamic指令 321<br>8.4.5　实战：掌控方法分派规则 324<br>8.5　基于栈的字节码解释执行引擎 326<br>8.5.1　解释执行 327<br>8.5.2　基于栈的指令集与基于寄存器的指令集 328<br>8.5.3　基于栈的解释器执行过程 329<br>8.6　本章小结 334<br>第9章　类加载及执行子系统的案例与实战 335<br>9.1　概述 335<br>9.2　案例分析 335<br>9.2.1　Tomcat：正统的类加载器架构 335<br>9.2.2　OSGi：灵活的类加载器架构 338<br>9.2.3　字节码生成技术与动态代理的实现 341<br>9.2.4　Backport工具：Java的时光机器 345<br>9.3　实战：自己动手实现远程执行功能 348<br>9.3.1　目标 348<br>9.3.2　思路 349<br>9.3.3　实现 350<br>9.3.4　验证 355<br>9.4　本章小结 356<br>第四部分　程序编译与代码优化<br>第10章　前端编译与优化 358<br>10.1　概述 358<br>10.2　Javac编译器 359<br>10.2.1　Javac的源码与调试 359<br>10.2.2　解析与填充符号表 362<br>10.2.3　注解处理器 363<br>10.2.4　语义分析与字节码生成 364<br>10.3　Java语法糖的味道 367<br>10.3.1　泛型 367<br>10.3.2　自动装箱、拆箱与遍历循环 375<br>10.3.3　条件编译 377<br>10.4　实战：插入式注解处理器 378<br>10.4.1　实战目标 379<br>10.4.2　代码实现 379<br>10.4.3　运行与测试 385<br>10.4.4　其他应用案例 386<br>10.5　本章小结 386<br>第11章　后端编译与优化 388<br>11.1　概述 388<br>11.2　即时编译器 389<br>11.2.1　解释器与编译器 389<br>11.2.2　编译对象与触发条件 392<br>11.2.3　编译过程 397<br>11.2.4　实战：查看及分析即时编译结果 398<br>11.3　提前编译器 404<br>11.3.1　提前编译的优劣得失 405<br>11.3.2　实战：Jaotc的提前编译 408<br>11.4　编译器优化技术 411<br>11.4.1　优化技术概览 411<br>11.4.2　方法内联 415<br>11.4.3　逃逸分析 417<br>11.4.4　公共子表达式消除 420<br>11.4.5　数组边界检查消除 421<br>11.5　实战：深入理解Graal编译器 423<br>11.5.1　历史背景 423<br>11.5.2　构建编译调试环境 424<br>11.5.3　JVMCI编译器接口 426<br>11.5.4　代码中间表示 429<br>11.5.5　代码优化与生成 432<br>11.6　本章小结 436<br>第五部分　高效并发<br>第12章　Java内存模型与线程 438<br>12.1　概述 438<br>12.2　硬件的效率与一致性 439<br>12.3　Java内存模型 440<br>12.3.1　主内存与工作内存 441<br>12.3.2　内存间交互操作 442<br>12.3.3　对于volatile型变量的特殊规则 444<br>12.3.4　针对long和double型变量的特殊规则 450<br>12.3.5　原子性、可见性与有序性 450<br>12.3.6　先行发生原则 452<br>12.4　Java与线程 455<br>12.4.1　线程的实现 455<br>12.4.2　Java线程调度 458<br>12.4.3　状态转换 460<br>12.5　Java与协程 461<br>12.5.1　内核线程的局限 461<br>12.5.2　协程的复苏 462<br>12.5.3　Java的解决方案 464<br>12.6　本章小结 465<br>第13章　线程安全与锁优化 466<br>13.1　概述 466<br>13.2　线程安全 466<br>13.2.1　Java语言中的线程安全 467<br>13.2.2　线程安全的实现方法 471<br>13.3　锁优化 479<br>13.3.1　自旋锁与自适应自旋 479<br>13.3.2　锁消除 480<br>13.3.3　锁粗化 481<br>13.3.4　轻量级锁 481<br>13.3.5　偏向锁 483<br>13.4　本章小结 485<br>附录A　在Windows系统下编译OpenJDK 6 486<br>附录B　展望Java技术的未来（2013年版） 493<br>附录C　虚拟机字节码指令表 499<br>附录D　对象查询语言（OQL）简介 506<br>附录E　JDK历史版本轨迹 512</p><h3 id="深入理解Java虚拟机（第3版）-PDF-下载"><a href="#深入理解Java虚拟机（第3版）-PDF-下载" class="headerlink" title="深入理解Java虚拟机（第3版） PDF 下载"></a>深入理解Java虚拟机（第3版） PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1iPdf94c3eUPIvNS2jny98g?pwd=7ips">https://pan.baidu.com/s/1iPdf94c3eUPIvNS2jny98g?pwd=7ips</a> </p><p>提取码: 7ips </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Jenkins 2权威指南》</title>
      <link href="/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2023/05/19/Jenkins%202%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/DCC8A35F0B25E6C033260746B89DAF45.png" alt="《Jenkins 2权威指南》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>设计、实现并且执行具有一定灵活性、可控性以及易于维护性的持续交付流水线，对于以前版本的Jenkins来说是不可能实现的。通过这本实用的书籍，构建管理人员、开发人员、测试人员以及其他专业人员将会学到如何利用Jenkins 2的新特性来定义流水线即代码、集成其他关键技术，以及创建自动化的、可靠的流水线，以便简化和加速DevOps环境的建设。</p><p>作者Brent Laster向你展示了Jenkins 2与这个流行的开源自动化平台基于Web的传统版本有着很大的不同。如果你熟悉Jenkins并且想利用这些新技术来改造老旧流水线或者构建现代的自动化持续交付环境，那么这本书适合你。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>郝树伟</p><p>《Jenkins权威指南》第一译者，阿里云高级研发工程师，主要负责开源集成和DevOps相关产品的研发，在CI&#x2F;CD领域有丰富经验，在Jenkins开源社区与相关书籍翻译、汉化方面有较多贡献和经验。</p><p>石雪峰</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、Jenkins中文社区核心成员、Jenkins的狂热爱好者。目前就职于京东商城前台工程效率团队，负责公司级持续交付和DevOps平台体系建设。</p><p>雷涛</p><p>Jenkins全球推广大使、Certified Jenkins Engineer、DevOps标准核心编写专家。目前就职于百度工程效率部，曾先后就职于新浪网、摩托罗拉、诺基亚、爱立信、乐视致新等国内外知名企业，专注于互联网、电信、金融、无人驾驶汽车等行业的软件工程效率提升，DevOps解决方案，持续交付，ASPICE&#x2F;ISO 26262研发过程落地等领域。</p><p>李华强</p><p>乐融致新高级配置经理，软件配置管理（SCM）领域的一名老兵，先后就职于北电网络、爱立信、飞维美地、乐视、乐融等多家企业，从事与SCM、DevOps相关的工作。Jenkins的忠实粉丝、最佳实践的推广者，Jenkins官方Certified Jenkins Engineer（CJE）和Certified CloudBees Jenkins Platform Engineer（CCJE）认证者。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第1章 Jenkins 2简介 1<br>Jenkins 2是什么 2<br>Jenkinsfile 3<br>声明式流水线 5<br>Blue Ocean界面 6<br>Jenkins 2的全新任务类型 7<br>做出转变的原因 10<br>DevOps理念的转变 10<br>装配流水线 11<br>可恢复性 11<br>可配置性 11<br>共享工作空间 11<br>专业知识 12<br>访问逻辑 12<br>流水线源管理 12<br>竞争 12<br>迎接挑战 13<br>兼容性 13<br>流水线兼容性 13<br>插件兼容性 15<br>检查兼容性 20<br>总结 21<br>第2章 基础知识 23<br>语法：脚本式流水线和声明式流水线 24<br>如何选择脚本式语法和声明式语法 25<br>系统（system）：主节点（master）、节点（node）、代理节点（agent）和执行器（executor）26<br>主节点 27<br>节点 27<br>代理节点 27<br>执行器 28<br>创建节点 29<br>结构：使用Jenkins DSL 31<br>节点 32<br>阶段 34<br>步骤 34<br>支持环境：开发一个流水线脚本 36<br>创建一个流水线项目 36<br>编辑器 38<br>使用代码片段生成器 39<br>运行一条流水线 43<br>回放 49<br>总结 52<br>第3章 流水线执行流程 53<br>触发任务 53<br>在其他项目构建后构建 54<br>周期性构建 54<br>使用GitHub钩子触发器进行GitSCM轮询 57<br>SCM轮询 57<br>静默期 58<br>远程触发构建 58<br>用户输入 58<br>输入 59<br>参数 62<br>多个输入参数的返回值 68<br>参数与声明式流水线 69<br>流程控制选项 74<br>超时（timeout） 74<br>重试（retry） 76<br>睡眠（sleep） 76<br>等待直到（waitUntil） 76<br>处理并发 78<br>使用lock步骤对资源加锁 78<br>使用milestone来控制并发构建 80<br>在多分支流水线中限制并发 82<br>并行地运行任务 82<br>有条件的执行功能 92<br>构建后处理 94<br>脚本式流水线构建后处理 94<br>声明式流水线与构建后处理 96<br>总结 97<br>第4章 通知与报告 99<br>通知 99<br>电子邮件 100<br>协作服务 110<br>报告 120<br>发布HTML报告 120<br>总结 123<br>第5章 访问与安全 125<br>安全加固Jenkins 125<br>启用安全性 126<br>其他全局安全配置 129<br>Jenkins中的凭证 133<br>凭证范围 134<br>凭证域 135<br>凭证提供者 135<br>凭证存储 136<br>管理凭证 136<br>选择凭证提供者 136<br>选择凭证类型 137<br>通过提供者指定凭证类型 138<br>创建和管理凭证 139<br>上下文链接 141<br>添加一个新域或者凭证 141<br>使用新域和凭证 144<br>高级凭证：基于角色的访问权限 145<br>基本用途 146<br>管理角色 147<br>分配角色 152<br>角色策略宏 155<br>在流水线中使用凭证 157<br>用户名和密码 157<br>SSH密钥 158<br>令牌凭证 159<br>控制脚本安全性 160<br>脚本检查 160<br>脚本批准 161<br>Groovy沙箱 162<br>Jenkins凭证与Vault配合使用 164<br>方法 164<br>安装 165<br>创建一个策略 165<br>身份验证 166<br>在Jenkins中使用Vault 168<br>总结 171<br>第6章 扩展你的流水线 173<br>可信库和不可信库 173<br>内部库与外部库 174<br>内部库 174<br>外部库 176<br>从代码仓库获取库 178<br>Modern SCM 178<br>Legacy SCM 178<br>在流水线脚本中使用库 179<br>从源码版本控制中自动下载库 180<br>加载库到脚本中 180<br>Jenkins项目中的库范围 182<br>库结构 183<br>样本库例程 183<br>共享库代码的结构 184<br>使用第三方库 195<br>直接加载代码 196<br>从外部SCM加载代码 196<br>回放外部代码和库 198<br>深入研究可信与不可信代码 200<br>总结 203<br>第7章 声明式流水线 205<br>动机 206<br>不直观 206<br>掌握Groovy 206<br>其他必需的装配 206<br>结构 207<br>代码块 208<br>部分 208<br>指令 209<br>步骤 209<br>条件 210<br>构建代码块 210<br>Pipeline 211<br>Agent 212<br>Environment 215<br>Tools 216<br>Options 219<br>Triggers 222<br>Parameters 224<br>Libraries 227<br>Stages 228<br>Post 231<br>处理非声明式的代码 232<br>检查你的插件 233<br>创建一个共享库 233<br>在pipeline代码块之外放置代码 233<br>script语句 234<br>在一个阶段中使用 parallel234<br>脚本检查与错误报告 235<br>声明式流水线与Blue Ocean接口 238<br>总结 238<br>第8章 理解项目类型 241<br>通用项目选项 241<br>基础设置 241<br>源码管理 247<br>构建触发器 249<br>构建环境 256<br>构建 266<br>构建后操作 266<br>项目类型 266<br>自由风格类型项目 267<br>Maven项目类型 267<br>流水线项目类型 270<br>外部任务项目类型 272<br>多配置项目类型 275<br>Ivy项目 280<br>文件夹 282<br>多分支流水线项目 287<br>GitHub组织项目 292<br>Bitbucket团队&#x2F;项目 296<br>总结 299<br>第9章 Blue Ocean用户界面 301<br>第一部分：管理已有的流水线 302<br>主界面 302<br>项目详情页面 305<br>运行页面 316<br>第二部分：使用Blue Ocean编辑器 325<br>不依赖现有Jenkinsfile创建一个全新的流水线 326<br>使用编辑器 330<br>编辑已有的流水线 340<br>导入和编辑已有的流水线 344<br>使用非GitHub仓库支持流水线 354<br>总结 356<br>第10章 转换 357<br>通用的准备 358<br>逻辑和准确性 358<br>项目类型 358<br>系统 358<br>访问 358<br>全局配置 359<br>插件 359<br>共享库 359<br>将自由风格类型的流水线转换为脚本式流水线 360<br>源码 364<br>编译 369<br>单元测试 373<br>集成测试 377<br>迁移流水线接下来的部分 380<br>从Jenkins流水线项目转换为Jenkinsfile 385<br>方法 388<br>最后的步骤 395<br>从脚本式流水线转换为声明式流水线 397<br>样本流水线 397<br>转换 399<br>完成转换 402<br>可用于转换的通用指南 403<br>总结 405<br>第11章 操作系统环境集成（shell、工作空间、环境和文件） 407<br>使用shell的步骤 407<br>sh步骤 408<br>bat步骤 413<br>powershell步骤 414<br>使用环境变量 415<br>withEnv步骤 416<br>使用工作空间 418<br>创建自定义工作空间 418<br>清理工作空间 420<br>文件和目录步骤 422<br>使用文件 422<br>使用目录 423<br>使用文件和目录的更多操作 424<br>总结 425<br>第12章 集成分析工具 427<br>SonarQube调查 427<br>使用个人规则 428<br>质量门和配置文件 432<br>扫描程序 434<br>将SonarQube与Jenkins一起使用 434<br>全局配置 434<br>在自由风格类型项目中使用SonarQube 436<br>在流水线项目中使用SonarQube 436<br>利用SonarQube分析的结果 437<br>在Jenkins中集成SonarQube的输出 441<br>代码覆盖率：与JaCoCo集成 442<br>关于JaCoCo 442<br>JaCoCo与流水线集成 443<br>在Jenkins中集成JaCoCo的输出 445<br>总结 446<br>第13章 集成制品管理 447<br>发布和获取制品 447<br>安装和全局配置 448<br>在脚本式流水线中使用Artifactory 449<br>执行其他任务 454<br>下载指定文件到指定目录 454<br>上传指定文件到指定路径 454<br>设置构建保留策略 455<br>构建提升 455<br>声明式流水线集成 455<br>Artifactory与Jenkins输出集成 456<br>制品归档和指纹 457<br>总结 462<br>第14章 集成容器 465<br>配置成一个云 465<br>全局配置 466<br>使用Docker镜像作为代理节点 469<br>在流水线中使用云镜像 473<br>在声明式流水线中动态创建的代理节点 477<br>Docker流水线全局变量 480<br>全局变量 480<br>Docker应用全局变量方法 481<br>Docker镜像全局变量方法 487<br>Docker容器全局变量方法 491<br>通过shell运行Docker 492<br>总结 493<br>第15章 其他接口 495<br>使用命令行接口 496<br>直接使用SSH接口 496<br>使用CLI客户端 499<br>使用Jenkins REST API 501<br>过滤结果 502<br>启动构建 504<br>使用脚本控制台 506<br>总结 508<br>第16章 故障处理 509<br>深入流水线步骤 509<br>处理序列化错误 512<br>连续传递风格 513<br>序列化流水线 513<br>NotSerializableException 513<br>处理非序列化错误 514<br>识别引发错误的脚本行 517<br>处理流水线异常 518<br>在声明式流水线中使用非声明式代码 518<br>未授权代码（脚本和方法授权） 522<br>不支持的操作 523<br>系统日志 523<br>时间戳 525<br>流水线耐用性设置 526<br>总结 527<br>关于作者 529<br>封面介绍 529<br>关于译者 530</p><h3 id="Jenkins-2权威指南-PDF-下载"><a href="#Jenkins-2权威指南-PDF-下载" class="headerlink" title="Jenkins 2权威指南 PDF 下载"></a>Jenkins 2权威指南 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1-k3Nil_DSq9TjNooWQytzg?pwd=qh9u">https://pan.baidu.com/s/1-k3Nil_DSq9TjNooWQytzg?pwd=qh9u</a> </p><p>提取码: qh9u </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 运维 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Kong网关：入门、实战与进阶》</title>
      <link href="/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/19/Kong%E7%BD%91%E5%85%B3%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%81%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/9873662DB6DD82154A4484E46FD188A3.png" alt="《Kong网关：入门、实战与进阶》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>这是一本关于Kong网关开发和运维的集大成之作。作者基于自己在该领域的丰富实践经验，从零开始，不仅循序渐进地讲解了Kong网关的核心概念、使用方法、工作原理、工程实践和源码，而且还将微服务设计、分布式架构、DevOps等相关技术融入其中，帮助读者打通Kong网关的整个技术体系，轻松跨越从理论到项目实战的鸿沟。</p><p>全书共16章，分为4篇，具体内容如下。</p><p>入门篇（第1~4章）</p><p>首先对网关层和Kong网关做了整体性介绍，然后有针对性地讲解了Nginx、OpenResty和Lua语言等必备知识，为之后深入学习打下基础。</p><p>基础篇（第5~8章）</p><p>这部分围绕Kong网关的日常配置和操作展开，具体包括Kong网关配置文件、部署方案、命令行向导、代理、鉴权、负载均衡策略和健康检查机制等内容。</p><p>进阶篇（第9~12章）</p><p>主要介绍了Kong网关区别于其他传统网关的插件机制，以及Kong网关在整个架构体系中与其他系统之间的交互和联动。</p><p>应用篇（第13~16章）</p><p>主要结合当前日益成熟的云原生环境，给出Kong网关在不同场景下的整体解决方案，如与微服务、Service Mesh、Kubernetes、Serverless的结合等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>孔庆雍</p><p>毕业于同济大学，曾就职于华为、中国移动、数禾科技等多家公司，任职期间参与了多个大型系统设计、研发工作。现任上海珞瑾数据信息有限公司CTO、首席架构师，在现公司主导了内部自研DevOps平台的搭建及底层架构设计与规划。敏捷开发思想践行者，擅长利用技术推进项目管理与产品交付。</p><p>在企业级SaaS服务、大规模分布式架构、微服务治理、网关层设计研发等领域积累了丰富的经验，在现公司主导研发的酒店管理系统已累计覆盖10万家门店，日均请求量超1亿。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>入门篇<br>第1章 全面了解Kong网关 2<br>1.1 网关简介 2<br>1.1.1 网关的由来 3<br>1.1.2 网关的作用 3<br>1.2 Kong网关简介 6<br>1.2.1 Kong网关的发展历程 6<br>1.2.2 Kong网关与传统网关对比 6<br>1.2.3 其他主流网关 7<br>1.3 Kong网关基础组件 12<br>1.3.1 Kong服务器 12<br>1.3.2 数据库 13<br>1.3.3 Kong管理GUI 14<br>1.4 Kong网关安装指南 14<br>1.4.1 在Mac环境中安装Kong网关 15<br>1.4.2 在Linux环境中安装Kong网关 15<br>1.4.3 在Docker环境中安装Kong网关 15<br>1.5 使用Kong网关搭建Web应用 16<br>1.5.1 示例项目介绍 16<br>1.5.2 后端服务路由 18<br>1.5.3 静态页面代理 20<br>1.6 本章小结 24<br>第2章 Nginx必备知识 25<br>2.1 Nginx安装 25<br>2.1.1 在Mac环境中安装Nginx 25<br>2.1.2 在Linux环境中安装Nginx 26<br>2.1.3 在Docker环境中安装Nginx 26<br>2.2 Nginx详解 26<br>2.2.1 Nginx文件的目录结构 26<br>2.2.2 命令行参数 28<br>2.2.3 配置文件 29<br>2.2.4 依赖库 32<br>2.2.5 Nginx的工作原理 33<br>2.2.6 Nginx优化指南 35<br>2.3 项目实践 37<br>2.3.1 从Kong切换到Nginx 37<br>2.3.2 添加黑白名单 39<br>2.3.3 添加限流 39<br>2.3.4 从Nginx切换到Kong 41<br>2.3.5 小结 41<br>2.4 本章小结 42<br>第3章 Lua必备知识 43<br>3.1 Lua入门与规范 43<br>3.1.1 基础知识 43<br>3.1.2 安装指南 44<br>3.1.3 解释器 45<br>3.1.4 语法规范 46<br>3.2 数据类型 47<br>3.3 操作符 52<br>3.4 表达式语句 54<br>3.4.1 赋值语句 54<br>3.4.2 控制语句 55<br>3.5 Lua库 58<br>3.6 本章小结 62<br>第4章 OpenResty必备知识 63<br>4.1 OpenResty入门安装 63<br>4.1.1 在Mac环境中安装OpenResty 63<br>4.1.2 在Linux环境中安装OpenResty 64<br>4.1.3 在Docker环境中安装OpenResty 64<br>4.2 OpenResty详解 64<br>4.2.1 OpenResty服务器的目录结构 64<br>4.2.2 Resty CLI 65<br>4.2.3 OpenResty包管理工具 67<br>4.3 OpenResty工作原理 69<br>4.4 OpenResty性能优化 71<br>4.4.1 避免使用阻塞函数 72<br>4.4.2 巧用table组件 72<br>4.4.3 使用缓存 73<br>4.4.4 火焰图 73<br>4.5 项目实践 75<br>4.6 本章小结 82<br>基础篇<br>第5章 Kong网关配置与部署 84<br>5.1 Kong启动项配置 84<br>5.1.1 配置项加载流程 85<br>5.1.2 配置项详解 86<br>5.1.3 环境变量 89<br>5.1.4 配置文件示例 89<br>5.2 注入Nginx指令 90<br>5.2.1 注入单个Nginx指令 91<br>5.2.2 通过文件方式注入Nginx指令 92<br>5.3 个性化使用场景 92<br>5.3.1 自定义Nginx模板文件 93<br>5.3.2 在OpenResty实例中嵌入Kong 93<br>5.4 Kong网关部署 94<br>5.4.1 无数据库部署模式 94<br>5.4.2 数据库部署模式 97<br>5.4.3 混合部署模式 100<br>5.5 本章小结 102<br>第6章 Kong网关命令行 103<br>6.1 通用标志参数 104<br>6.2 Kong网关命令行详解 104<br>6.2.1 kong check 104<br>6.2.2 kong config 106<br>6.2.3 kong health 109<br>6.2.4 kong hybrid 109<br>6.2.5 kong migrations 110<br>6.2.6 kong prepare 112<br>6.2.7 kong quit 113<br>6.2.8 kong reload 113<br>6.2.9 kong restart 114<br>6.2.10 kong start 114<br>6.2.11 kong stop 115<br>6.2.12 kong version 116<br>6.3 本章小结 116<br>第7章 Kong网关代理及鉴权 117<br>7.1 Kong网关代理基础知识 117<br>7.1.1 Kong网关术语简介 117<br>7.1.2 Kong网关代理环境配置 118<br>7.2 Kong网关代理示例 118<br>7.3 路由匹配规则 121<br>7.3.1 通用匹配规则 121<br>7.3.2 paths属性 123<br>7.3.3 hosts属性 126<br>7.3.4 methods属性 128<br>7.3.5 headers属性（hosts除外） 129<br>7.3.6 sources &amp; destinations属性 129<br>7.3.7 snis属性 129<br>7.4 路由匹配优先级 130<br>7.4.1 优先级策略 130<br>7.4.2 后备路由策略 131<br>7.5 Kong网关代理行为 132<br>7.5.1 超时机制 132<br>7.5.2 错误重试机制 133<br>7.5.3 插件执行策略 133<br>7.5.4 响应内容 133<br>7.6 配置SSL协议 134<br>7.7 代理WebSocket流量 135<br>7.8 代理gRPC流量 138<br>7.9 Kong网关鉴权 140<br>7.9.1 通用鉴权流程 140<br>7.9.2 匿名接入流程 142<br>7.9.3 多重认证策略 143<br>7.10 本章小结 144<br>第8章 Kong网关负载均衡策略与健康检查 145<br>8.1 负载均衡 145<br>8.1.1 负载均衡简介 145<br>8.1.2 负载均衡解决方案 146<br>8.1.3 Kong网关中的负载均衡 146<br>8.2 基于DNS的负载均衡 146<br>8.2.1 A记录（包含AAAA记录） 147<br>8.2.2 SRV记录 147<br>8.2.3 DNS 记录优先级 147<br>8.2.4 其他注意事项 148<br>8.3 环状负载均衡器 148<br>8.3.1 基础概念 148<br>8.3.2 负载均衡策略 150<br>8.3.3 其他注意事项 151<br>8.4 负载均衡特性使用场景 151<br>8.4.1 蓝绿发布 151<br>8.4.2 金丝雀发布 155<br>8.5 健康检查 157<br>8.5.1 健康检查标准 157<br>8.5.2 健康检查类型 159<br>8.5.3 健康检查配置 160<br>8.6 本章小结 162<br>进阶篇<br>第9章 Kong网关插件 164<br>9.1 Kong网关插件简介 164<br>9.1.1 Kong网关插件概念 164<br>9.1.2 Kong网关插件原理 165<br>9.2 Kong官方插件 166<br>9.2.1 鉴权类插件 166<br>9.2.2 安全类插件 177<br>9.2.3 流量类插件 179<br>9.2.4 分析监控类插件 195<br>9.2.5 内容转换类插件 197<br>9.2.6 日志类插件 204<br>9.2.7 其他插件 210<br>9.3 自定义Kong网关插件 210<br>9.3.1 自定义插件开发流程和插件生命周期管理详解 210<br>9.3.2 插件开发套件 240<br>9.3.3 Go插件开发向导 241<br>9.3.4 自定义插件实例 243<br>9.4 本章小结 245<br>第10章 Kong网关日志 246<br>10.1 Kong网关日志简介 246<br>10.1.1 Kong网关日志分类 246<br>10.1.2 Kong网关日志级别 248<br>10.2 Kong网关结合日志平台 249<br>10.2.1 ELK方案简介 249<br>10.2.2 Kong网关结合ELK 253<br>10.2.3 日志系统使用场景 256<br>10.3 自定义日志 261<br>10.3.1 Kong网关定制日志 262<br>10.3.2 ELK定制日志 264<br>10.3.3 小结 265<br>10.4 本章小结 266<br>第11章 Kong网关运维 267<br>11.1 资源选型 267<br>11.1.1 服务器资源 267<br>11.1.2 数据库资源 268<br>11.1.3 弹性伸缩 269<br>11.1.4 性能参数 269<br>11.2 Kong网关监控 270<br>11.2.1 监控平台选型 270<br>11.2.2 搭建监控平台 271<br>11.2.3 Kong网关监控平台配置 272<br>11.2.4 Kong网关监控平台指标详解 278<br>11.2.5 Kong监控平台指标测试 279<br>11.2.6 Kong监控平台的预警功能 281<br>11.3 Kong网关运维 284<br>11.3.1 数据备份 284<br>11.3.2 软&#x2F;硬件维护 286<br>11.3.3 突发事件处理 288<br>11.4 本章小结 288<br>第12章 Kong网关安全与集群高可用 289<br>12.1 Kong网关安全配置 289<br>12.1.1 网络层访问限制 289<br>12.1.2 Kong API 回路 290<br>12.1.3 自定义Nginx配置 291<br>12.2 Kong集群 292<br>12.2.1 Kong集群简介 292<br>12.2.2 Kong集群缓存 293<br>12.3 Kong网关高可用 298<br>12.3.1 架构设计 298<br>12.3.2 引入HAProxy层 300<br>12.3.3 高可用方案测试 301<br>12.4 本章小结 308<br>应用篇<br>第13章 Kong网关结合微服务架构 310<br>13.1 微服务简介 310<br>13.1.1 微服务的优点 311<br>13.1.2 单体应用和微服务 311<br>13.1.3 微服务12要素 313<br>13.2 单体应用向微服务迁移 313<br>13.2.1 采用微服务的注意事项 314<br>13.2.2 迁移细节 314<br>13.3 使用CI&#x2F;CD流程促进微服务开发 316<br>13.3.1 CI&#x2F;CD流程基础组件 316<br>13.3.2 构建CI&#x2F;CD流程 318<br>13.4 基于Kong打造DevOps平台 320<br>13.4.1 场景描述 320<br>13.4.2 设计思路 321<br>13.4.3 DevOps平台使用指南 325<br>13.4.4 DevOps平台源码解析 329<br>13.4.5 DevOps平台扩展 335<br>13.5 本章小结 336<br>第14章 Kong网关结合Kubernetes架构方案 337<br>14.1 Kubernetes详解 337<br>14.1.1 Kubernetes简介 337<br>14.1.2 Kubernetes发展史 338<br>14.1.3 Kubernetes基本概念和术语 340<br>14.1.4 Kubernetes的HelloWorld示例 342<br>14.2 Kubernetes与Kong网关结合 350<br>14.2.1 概念描述 350<br>14.2.2 使用Kubernetes安装Kong 358<br>14.3 Kubernetes实战 359<br>14.3.1 安装Kong网关 359<br>14.3.2 使用Kong网关 360<br>14.3.3 配置Kong网关插件 361<br>14.4 本章小结 363<br>第15章 Service Mesh实践之Kuma 364<br>15.1 Service Mesh简介 364<br>15.2 Kuma简介 366<br>15.2.1 为什么使用Kuma 366<br>15.2.2 Kuma与其他Service Mesh方案的比较 366<br>15.2.3 Kuma系统组件 367<br>15.2.4 Kuma部署示例 368<br>15.3 Kuma策略概述 369<br>15.3.1 策略配置项描述 369<br>15.3.2 使用策略 370<br>15.3.3 策略匹配规则 371<br>15.4 Kuma内置策略详解 372<br>15.4.1 安全类策略 372<br>15.4.2 流量控制类策略 376<br>15.4.3 观测类策略 382<br>15.5 Kuma实战 388<br>15.5.1 适配Kuma架构 388<br>15.5.2 启动mTSL和TrafficPermission 390<br>15.6 本章小结 391<br>第16章 Serverless架构 392<br>16.1 Serverless简介 392<br>16.1.1 系统架构演化 392<br>16.1.2 部署方式演化 393<br>16.1.3 Serverless内核 395<br>16.2 Serverless实践 396<br>16.2.1 搭建开发环境 396<br>16.2.2 Web应用服务 402<br>16.3 本章小结 407<br>附录A Docker安装指南 408<br>附录B KONGA安装指南 412<br>附录C 数据库明细 417<br>附录D Admin API 422</p><h3 id="Kong网关：入门、实战与进阶-PDF-下载"><a href="#Kong网关：入门、实战与进阶-PDF-下载" class="headerlink" title="Kong网关：入门、实战与进阶 PDF 下载"></a>Kong网关：入门、实战与进阶 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1TcS75sumxYvI50ac-1oQNA?pwd=jsxq">https://pan.baidu.com/s/1TcS75sumxYvI50ac-1oQNA?pwd=jsxq</a> </p><p>提取码: jsxq </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> Kong </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Python编程：从入门到实践》</title>
      <link href="/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/05/19/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/031C7413E5CDC918603FDAB290074F33.png" alt="《Python编程：从入门到实践》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>本书是针对所有层次Python读者而作的Python入门书。全书分两部分：第一部分介绍用Python编程所必须了解的基本概念，包括Matplotlib等强大的Python库和工具，以及列表、字典、if语句、类、文件与异常、代码测试等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的2D游戏、利用数据生成交互式的信息图以及创建和定制简单的Web应用，并帮助读者解决常见编程问题和困惑。第2版进行了全面修订，简化了Python安装流程，新增了f字符串、get()方法等内容，并且在项目中使用了Plotly库以及新版本的Django和Bootstrap，等等。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>埃里克·马瑟斯（Eric Matthes）</p><p>高中科学和数学老师，现居住在阿拉斯加，在当地讲授Python入门课程。他从5岁开始就一直在编写程序。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>第一部分 基础知识<br>第1章 起步　　2<br>1.1 搭建编程环境　　2<br>1.1.1 Python版本　　2<br>1.1.2 运行Python代码片段　　2<br>1.1.3 Sublime Text简介　　3<br>1.2 在不同操作系统中搭建Python编程环境　　3<br>1.2.1 在Windows系统中搭建Python编程环境　　4<br>1.2.2 在macOS系统中搭建Python编程环境　　5<br>1.2.3 在Linux 系统中搭建Python编程环境　　7<br>1.3 运行Hello World 程序　　8<br>1.3.1 配置Sublime Text以使用正确的Python版本　　8<br>1.3.2 运行程序hello_world.py　　8<br>1.4 解决安装问题　　9<br>1.5 从终端运行Python程序　　9<br>1.5.1 在Windows系统中从终端运行Python 程序　　10<br>1.5.2 在Linux和macOS系统中从终端运行Python程序　　10<br>1.6 小结　　11<br>第2章 变量和简单数据类型　　12<br>2.1 运行hello_world.py时发生的情况　　12<br>2.2 变量　　13<br>2.2.1 变量的命名和使用　　13<br>2.2.2 使用变量时避免命名错误　　14<br>2.2.3 变量是标签　　15<br>2.3 字符串　　16<br>2.3.1 使用方法修改字符串的大小写　　17<br>2.3.3 使用制表符或换行符来添加空白　　18<br>2.3.4 删除空白　　19<br>2.3.5 使用字符串时避免语法错误　　20<br>2.4 数　　21<br>2.4.1 整数　　22<br>2.4.2 浮点数　　22<br>2.4.3 整数和浮点数　　23<br>2.4.4 数中的下划线　　23<br>2.4.5 同时给多个变量赋值　　24<br>2.4.6 常量　　24<br>2.5 注释　　25<br>2.5.1 如何编写注释　　25<br>2.5.2 该编写什么样的注释　　25<br>2.6 Python之禅　　26<br>2.7 小结　　27<br>第3章 列表简介　　28<br>3.1 列表是什么　　28<br>3.1.1 访问列表元素　　29<br>3.1.2 索引从0而不是1开始　　29<br>3.1.3 使用列表中的各个值　　30<br>3.2 修改、添加和删除元素　　31<br>3.2.1 修改列表元素　　31<br>3.2.2 在列表中添加元素　　31<br>3.2.3 从列表中删除元素　　32<br>3.3 组织列表　　36<br>3.3.1 使用方法sort()对列表永久排序　　37<br>3.3.2 使用函数sorted()对列表临时排序　　37<br>3.3.3 倒着打印列表　　38<br>3.3.4 确定列表的长度　　38<br>3.4 使用列表时避免索引错误　　39<br>3.5 小结　　41<br>第4章 操作列表　　42<br>4.1 遍历整个列表　　42<br>4.1.1 深入研究循环　　43<br>4.1.2 在for 循环中执行更多操作　　44<br>4.1.3 在for 循环结束后执行一些操作　　45<br>4.2 避免缩进错误　　45<br>4.2.1 忘记缩进　　46<br>4.2.2 忘记缩进额外的代码行　　46<br>4.2.3 不必要的缩进　　47<br>4.2.4 循环后不必要的缩进　　47<br>4.2.5 遗漏了冒号　　48<br>4.3 创建数值列表　　49<br>4.3.1 使用函数range()　　49<br>4.3.2 使用range()创建数字列表　　50<br>4.3.3 对数字列表执行简单的统计计算　　51<br>4.3.4 列表解析　　52<br>4.4 使用列表的一部分　　53<br>4.4.1 切片　　53<br>4.4.2 遍历切片　　54<br>4.4.3 复制列表　　55<br>4.5 元组　　57<br>4.5.1 定义元组　　57<br>4.5.2 遍历元组中的所有值　　58<br>4.5.3 修改元组变量　　59<br>4.6 设置代码格式　　60<br>4.6.1 格式设置指南　　60<br>4.6.2 缩进　　60<br>4.6.3 行长　　60<br>4.6.4 空行　　61<br>4.6.5 其他格式设置指南　　61<br>4.7 小结　　62<br>第5章 if语句　　63<br>5.1 一个简单示例　　63<br>5.2 条件测试　　64<br>5.2.1 检查是否相等　　64<br>5.2.2 检查是否相等时忽略大小写　　64<br>5.2.3 检查是否不相等　　65<br>5.2.4 数值比较　　66<br>5.2.5 检查多个条件　　66<br>5.2.6 检查特定值是否包含在列表中　　68<br>5.2.8 布尔表达式　　68<br>5.3 if语句　　69<br>5.3.1 简单的if语句　　69<br>5.3.2 if-else语句　　70<br>5.3.3 if-elif-else结构　　71<br>5.3.4 使用多个elif代码块　　72<br>5.3.5 省略else代码块　　73<br>5.3.6 测试多个条件　　73<br>5.4 使用if语句处理列表　　76<br>5.4.1 检查特殊元素　　76<br>5.4.2 确定列表不是空的　　77<br>5.4.3 使用多个列表　　77<br>5.5 设置if语句的格式　　79<br>5.6 小结　　80<br>第6章 字典　　81<br>6.1 一个简单的字典　　81<br>6.2 使用字典　　82<br>6.2.1 访问字典中的值　　82<br>6.2.2 添加键值对　　83<br>6.2.3 先创建一个空字典　　83<br>6.2.4 修改字典中的值　　84<br>6.2.5 删除键值对　　85<br>6.2.6 由类似对象组成的字典　　86<br>6.2.7 使用get()来访问值　　87<br>6.3 遍历字典　　88<br>6.3.1 遍历所有键值对　　88<br>6.3.2 遍历字典中的所有键　　90<br>6.3.3 按特定顺序遍历字典中的所有键　　92<br>6.3.4 遍历字典中的所有值　　92<br>6.4 嵌套　　94<br>6.4.1 字典列表　　94<br>6.4.2 在字典中存储列表　　97<br>6.4.3 在字典中存储字典　　98<br>6.5 小结　　100<br>第7章 用户输入和while循环　　101<br>7.1 函数input()的工作原理　　101<br>7.1.1 编写清晰的程序　　102<br>7.1.2 使用int()来获取数值输入　　102<br>7.1.3 求模运算符　　104<br>7.2 while循环简介　　105<br>7.2.1 使用while循环　　105<br>7.2.2 让用户选择何时退出　　105<br>7.2.3 使用标志　　107<br>7.2.4 使用break退出循环　　108<br>7.2.5 在循环中使用continue　　109<br>7.2.6 避免无限循环　　109<br>7.3 使用while循环处理列表和字典　　111<br>7.3.1 在列表之间移动元素　　111<br>7.3.2 删除为特定值的所有列表元素　　112<br>7.3.3 使用用户输入来填充字典　　112<br>7.4 小结　　114<br>第8章 函数　　115<br>8.1 定义函数　　115<br>8.1.1 向函数传递信息　　116<br>8.1.2 实参和形参　　116<br>8.2 传递实参　　117<br>8.2.1 位置实参　　117<br>8.2.2 关键字实参　　119<br>8.2.3 默认值　　119<br>8.2.4 等效的函数调用　　120<br>8.2.5 避免实参错误　　121<br>8.3 返回值　　122<br>8.3.1 返回简单值　　122<br>8.3.2 让实参变成可选的　　123<br>8.3.3 返回字典　　124<br>8.3.4 结合使用函数和while循环　　125<br>8.4 传递列表　　127<br>8.4.1 在函数中修改列表　　128<br>8.4.2 禁止函数修改列表　　130<br>8.5 传递任意数量的实参　　131<br>8.5.1 结合使用位置实参和任意数量实参　　132<br>8.5.2 使用任意数量的关键字实参　　134<br>8.6.1 导入整个模块　　134<br>8.6.2 导入特定的函数　　135<br>8.6.3 使用as给函数指定别名　　136<br>8.6.4 使用as给模块指定别名　　136<br>8.6.5 导入模块中的所有函数　　137<br>8.7 函数编写指南　　137<br>8.8 小结　　138<br>第9章 类　　140<br>9.1 创建和使用类　　140<br>9.1.1 创建Dog类　　141<br>9.1.2 根据类创建实例　　142<br>9.2 使用类和实例　　144<br>9.2.1 Car类　　145<br>9.2.2 给属性指定默认值　　145<br>9.2.3 修改属性的值　　146<br>9.3 继承　　149<br>9.3.1 子类的方法__init__()　　149<br>9.3.2 给子类定义属性和方法　　151<br>9.3.3 重写父类的方法　　152<br>9.3.4 将实例用作属性　　152<br>9.3.5 模拟实物　　154<br>9.4 导入类　　155<br>9.4.1 导入单个类　　155<br>9.4.2 在一个模块中存储多个类　　157<br>9.4.3 从一个模块中导入多个类　　158<br>9.4.4 导入整个模块　　158<br>9.4.5 导入模块中的所有类　　159<br>9.4.6 在一个模块中导入另一个模块　　159<br>9.4.7 使用别名　　160<br>9.4.8 自定义工作流程　　160<br>9.5 Python标准库　　161<br>9.6 类编码风格　　162<br>9.7 小结　　163<br>第10章 文件和异常　　164<br>10.1 从文件中读取数据　　164<br>10.1.1 读取整个文件　　164<br>10.1.2 文件路径　　166<br>10.1.3 逐行读取　　167<br>10.1.4 创建一个包含文件各行内容的列表　　168<br>10.1.5 使用文件的内容　　168<br>10.1.6 包含一百万位的大型文件　　170<br>10.2 写入文件　　171<br>10.2.1 写入空文件　　171<br>10.2.2 写入多行　　172<br>10.2.3 附加到文件　　173<br>10.3 异常　　174<br>10.3.1 处理ZeroDivisionError异常　　174<br>10.3.2 使用try-except 代码块　　174<br>10.3.3 使用异常避免崩溃　　175<br>10.3.4 else代码块　　176<br>10.3.5 处理FileNotFoundError异常　　177<br>10.3.6 分析文本　　178<br>10.3.7 使用多个文件　　179<br>10.3.8 静默失败　　180<br>10.3.9 决定报告哪些错误　　181<br>10.4 存储数据　　182<br>10.4.1 使用json.dump()和json.load()　　182<br>10.4.2 保存和读取用户生成的数据　　183<br>10.4.3 重构　　185<br>10.5 小结　　187<br>第11章 测试代码　　188<br>11.1 测试函数　　188<br>11.1.1 单元测试和测试用例　　189<br>11.1.2 可通过的测试　　189<br>11.1.3 未通过的测试　　191<br>11.1.4 测试未通过时怎么办　　192<br>11.1.5 添加新测试　　193<br>11.2 测试类　　194<br>11.2.1 各种断言方法　　194<br>11.2.2 一个要测试的类　　195<br>11.2.3 测试AnonymousSurvey类　　197<br>11.2.4 方法setUp()　　198<br>11.3 小结　　200<br>第二部分 项 目<br>项目1 外星人入侵　　202<br>第12章 武装飞船　　203<br>12.1 规划项目　　203<br>12.2 安装Pygame　　204<br>12.3 开始游戏项目　　204<br>12.3.1 创建Pygame窗口及响应用户输入　　204<br>12.3.2 设置背景色　　206<br>12.3.3 创建设置类　　207<br>12.4 添加飞船图像　　208<br>12.4.1 创建Ship类　　209<br>12.4.2 在屏幕上绘制飞船　　210<br>12.5 重构：方法_check_events()和__update_screen()　　211<br>12.5.1 方法_check_events()　　211<br>12.5.2 方法_update_screen()　　212<br>12.6 驾驶飞船　　213<br>12.6.1 响应按键　　213<br>12.6.2 允许持续移动　　214<br>12.6.3 左右移动　　215<br>12.6.4 调整飞船的速度　　216<br>12.6.5 限制飞船的活动范围　　218<br>12.6.6 重构_check_events()　　218<br>12.6.7 按Q键退出　　219<br>12.6.8 在全屏模式下运行游戏　　219<br>12.7 简单回顾　　220<br>12.7.1 alien_invasion.py　　220<br>12.7.2 settings.py　　220<br>12.7.3 ship.py　　220<br>12.8 射击　　221<br>12.8.1 添加子弹设置　　221<br>12.8.2 创建Bullet类　　221<br>12.8.3 将子弹存储到编组中　　223<br>12.8.4 开火　　223<br>12.8.5 删除消失的子弹　　225<br>12.8.6 限制子弹数量　　225<br>12.8.7 创建方法_update_bullets()　　227<br>第13章 外星人来了　　228<br>13.1 项目回顾　　228<br>13.2 创建第一个外星人　　229<br>13.2.1 创建Alien类　　229<br>13.2.2 创建Alien实例　　230<br>13.3 创建一群外星人　　232<br>13.3.1 确定一行可容纳多少个外星人　　232<br>13.3.2 创建一行外星人　　232<br>13.3.3 重构_create_fleet()　　234<br>13.3.4 添加行　　234<br>13.4 让外星人群移动　　237<br>13.4.1 向右移动外星人群　　237<br>13.4.2 创建表示外星人移动方向的设置　　238<br>13.4.3 检查外星人是否撞到了屏幕边缘　　238<br>13.4.4 向下移动外星人群并改变移动方向　　239<br>13.5 射杀外星人　　240<br>13.5.1 检测子弹与外星人的碰撞　　241<br>13.5.3 生成新的外星人群　　242<br>13.5.4 提高子弹的速度　　243<br>13.5.5 重构_update_bullets()　　243<br>13.6 结束游戏　　244<br>13.6.1 检测外星人和飞船碰撞　　244<br>13.6.2 响应外星人和飞船碰撞　　245<br>13.6.3 有外星人到达屏幕底端　　247<br>13.6.4 游戏结束　　248<br>13.7 确定应运行游戏的哪些部分　　248<br>13.8 小结　　249<br>第14章 记分　　250<br>14.1 添加Play按钮　　250<br>14.1.1 创建Button类　　250<br>14.1.2 在屏幕上绘制按钮　　252<br>14.1.3 开始游戏　　253<br>14.1.4 重置游戏　　254<br>14.1.5 将Play按钮切换到非活动状态　　254<br>14.1.6 隐藏鼠标光标　　255<br>14.2 提高等级　　256<br>14.2.1 修改速度设置　　256<br>14.2.2 重置速度　　258<br>14.3 记分　　258<br>14.3.1 显示得分　　259<br>14.3.2 创建记分牌　　260<br>14.3.3 在外星人被消灭时更新得分　　261<br>14.3.4 重置得分　　262<br>14.3.5 将消灭的每个外星人都计入得分　　262<br>14.3.6 提高分数　　263<br>14.3.7 舍入得分　　264<br>14.3.8 最高得分　　265<br>14.3.9 显示等级　　267<br>14.3.10 显示余下的飞船数　　269<br>14.4 小结　　272<br>项目2 数据可视化　　273<br>第15章 生成数据　　274<br>15.1 安装Matplotlib　　274<br>15.2 绘制简单的折线图　　275<br>15.2.1 修改标签文字和线条粗细　　277<br>15.2.3 使用内置样式　　278<br>15.2.4 使用scatter()绘制散点图并设置样式　　279<br>15.2.5 使用scatter()绘制一系列点　　280<br>15.2.6 自动计算数据　　281<br>15.2.7 自定义颜色　　282<br>15.2.8 使用颜色映射　　283<br>15.2.9 自动保存图表　　284<br>15.3 随机漫步　　284<br>15.3.1 创建RandomWalk类　　284<br>15.3.2 选择方向　　285<br>15.3.3 绘制随机漫步图　　286<br>15.3.4 模拟多次随机漫步　　287<br>15.3.5 设置随机漫步图的样式　　288<br>15.4 使用Plotly模拟掷骰子　　292<br>15.4.1 安装Plotly　　292<br>15.4.2 创建Die类　　293<br>15.4.3 掷骰子　　293<br>15.4.4 分析结果　　294<br>15.4.5 绘制直方图　　294<br>15.4.6 同时掷两个骰子　　296<br>15.4.7 同时掷两个面数不同的骰子　　298<br>15.5 小结　　300<br>第16章 下载数据　　301<br>16.1 CSV文件格式　　301<br>16.1.1 分析CSV文件头　　302<br>16.1.2 打印文件头及其位置　　302<br>16.1.3 提取并读取数据　　303<br>16.1.4 绘制温度图表　　304<br>16.1.5 模块datetime　　305<br>16.1.6 在图表中添加日期　　306<br>16.1.7 涵盖更长的时间　　307<br>16.1.8 再绘制一个数据系列　　308<br>16.1.9 给图表区域着色　　309<br>16.1.10 错误检查　　310<br>16.1.11 自己动手下载数据　　313<br>16.2 制作全球地震散点图：JSON格式　　315<br>16.2.2 查看JSON数据　　315<br>16.2.3 创建地震列表　　317<br>16.2.4 提取震级　　317<br>16.2.5 提取位置数据　　318<br>16.2.6 绘制震级散点图　　319<br>16.2.7 另一种指定图表数据的方式　　320<br>16.2.8 定制标记的尺寸　　321<br>16.2.9 定制标记的颜色　　322<br>16.2.10 其他渐变　　323<br>16.2.11 添加鼠标指向时显示的文本　　324<br>16.3 小结　　325<br>第17章 使用API　　326<br>17.1 使用Web API　　326<br>17.1.1 Git 和GitHub　　326<br>17.1.2 使用API调用请求数据　　327<br>17.1.3 安装Requests　　327<br>17.1.4 处理API响应　　328<br>17.1.5 处理响应字典　　329<br>17.1.6 概述最受欢迎的仓库　　331<br>17.1.7 监视API的速率限制　　332<br>17.2 使用Plotly可视化仓库　　332<br>17.2.1 改进Plotly图表　　334<br>17.2.2 添加自定义工具提示　　336<br>17.2.3 在图表中添加可单击的链接　　337<br>17.2.4 深入了解Plotly和GitHub API　　338<br>17.3 Hacker News API　　338<br>17.4 小结　　341<br>项目3 Web 应用程序　　342<br>第18章 从Django 入手　　343<br>18.1 建立项目　　343<br>18.1.1 制定规范　　343<br>18.1.2 建立虚拟环境　　344<br>18.1.3 激活虚拟环境　　344<br>18.1.4 安装Django　　345<br>18.1.5 在Django中创建项目　　345<br>18.1.6 创建数据库　　346<br>18.1.7 查看项目　　346<br>18.2 创建应用程序　　348<br>18.2.1 定义模型　　348<br>18.2.2 激活模型　　349<br>18.2.3 Django管理网站　　351<br>18.2.4 定义模型Entry　　353<br>18.2.5 迁移模型Entry　　354<br>18.2.6 向管理网站注册Entry　　354<br>18.2.7 Django shell　　355<br>18.3 创建页面：学习笔记主页　　357<br>18.3.1 映射URL　　358<br>18.3.2 编写视图　　359<br>18.3.3 编写模板　　360<br>18.4 创建其他页面　　361<br>18.4.1 模板继承　　361<br>18.4.2 显示所有主题的页面　　363<br>18.4.3 显示特定主题的页面　　366<br>18.5 小结　　369<br>第19章 用户账户　　370<br>19.1 让用户输入数据　　370<br>19.1.1 添加新主题　　370<br>19.1.2 添加新条目　　374<br>19.1.3 编辑条目　　378<br>19.2 创建用户账户　　381<br>19.2.1 应用程序users　　381<br>19.2.2 将users添加到settings.py 中　　381<br>19.2.3 包含users的URL　　382<br>19.2.4 登录页面　　382<br>19.2.5 注销　　384<br>19.2.6 注册页面　　386<br>19.3 让用户拥有自己的数据　　388<br>19.3.1 使用@login_required限制访问　　388<br>19.3.2 将数据关联到用户　　390<br>19.3.3 只允许用户访问自己的主题　　393<br>19.3.4 保护用户的主题　　393<br>19.3.5 保护页面edit_entry　　394<br>19.3.6 将新主题关联到当前用户　　396<br>第20章 设置应用程序的样式并部署　　397<br>20.1.1 应用程序django-bootstrap4　　398<br>20.1.3 修改base.html　　399<br>20.1.4 使用jumbotron设置主页的样式　　403<br>20.1.5 设置登录页面的样式　　404<br>20.1.6 设置显示所有主题的页面的样式　　405<br>20.1.7 设置显示单个主题的页面中的条目样式　　406<br>20.2 部署“学习笔记”　　407<br>20.2.1 建立Heroku账户　　408<br>20.2.2 安装Heroku CLI　　408<br>20.2.3 安装必要的包　　408<br>20.2.4 创建文件requirements.txt　　409<br>20.2.6 为部署到Heroku而修改settings.py　　410<br>20.2.7 创建启动进程的Procfile　　410<br>20.2.8 使用Git 跟踪项目文件　　410<br>20.2.9 推送到Heroku　　412<br>20.2.10 在Heroku上建立数据库　　414<br>20.2.12 确保项目的安全　　416<br>20.2.13 提交并推送修改　　416<br>20.2.14 在Heroku 上设置环境变量　　417<br>20.2.15 创建自定义错误页面　　418<br>20.2.16 继续开发　　420<br>20.2.17 设置SECRET_KEY　　421<br>20.2.18 将项目从Heroku删除　　421<br>20.3 小结　　422<br>附录A 安装与故障排除　　423<br>附录B 文本编辑器与IDE　　428<br>附录C 寻求帮助　　432<br>附录D 使用Git 进行版本控制　　436<br>后记　　445</p><h3 id="Python编程：从入门到实践-PDF-下载地址"><a href="#Python编程：从入门到实践-PDF-下载地址" class="headerlink" title="Python编程：从入门到实践 PDF 下载地址:"></a>Python编程：从入门到实践 PDF 下载地址:</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1ualVYeJwdRtP_JFD1Tt1rg?pwd=kgxm">https://pan.baidu.com/s/1ualVYeJwdRtP_JFD1Tt1rg?pwd=kgxm</a> </p><p>提取码: kgxm </p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站所有文档密码</title>
      <link href="//mima/"/>
      <url>//mima/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">  <script id="hbeData" type="hbeData" data-hmacdigest="5c082efc780d84af1dccd0e5d896a11a7c43283b7639b4e398c9a7c5db170634">1b693c4938223286468132b2f7068bf6dfee07f365da88e0f20fb98ce9ee8b53d2b2b3d27fe00611ae01aab9502c74251a028d46727701746eb6ab24f4a6bde0bb413a4181288cc184d1a5b56ea616815ed410e54d06738826d84350289d51b1ad1d1ebd149673c98971c830a8ae9ac7603436acc5bf3f434dc9906fa03a83506227b33188752de09daa22ca60b4055b83ae829311c73f56744cd35f0ea194ae6bc909e56cee47d858e3672029697b67eb8bcba1b115780e43d52157418dbe8becb4a1a3c96157e6c43a86158d32e0429345c61921f2f87f18a04ae06f43af3378a168bf91db0510d02da389d68dd5f101a6207756c5d6279d4fd906fc6132105daf5f11d4fb01f2d67cfcb899e63267fc22871def8788487d21b982ecab19a26792c3017fe7858a0a8f459c870d2e8a22ad9bbf1d82799f5fb336ec8d23f86fc3516d6f563c77dda4db48b4b460ea9cb51dc81c778e5f40fbba65f11aa3ddfd8f962974b0862a0bb54d3ac5fa6fa772cb7c7e1d49b3e1bd4e4d25811a00987a5da9f4508a11bda22aba5b6df28a8c791c883b988784d874439fcebd7f1cb675132af28e2d4f57f05368ed840b3dc5d8689e486b941c258473b243f823039f2655b9cb0f4616987f31078b783b605f758c1ad819c1b79090958518c78b0828722165a9324b6a9ab3a9c58f881841ef10dc51401d19ee7f4fce137b8ddbce23c25b4d4b8913677b5cc82b7688f7ebcb4756886a852cd45c9ab8f7fbebf24159a7a7293953f7aef2da7dfbbf06fb10b14caa7e55c61f5069ca3f103d6b818e5507bb29b2e9691bf7adec2031d3a05215fbb93cb85f7ad68b628627bd2d75a7f36d8df03e4640e273346659990c34302d8b206e557e54960086d8ef0e10cd355901d75349aed6385578c90c6599b213c056b57dd86e45dc9458b93d05816a65d9cbb2ff9cb0a85661bb72a92128c171c9a16bba54ecf8d70069498a9881509852858b6d13b028569969caf7a9de4558499417935a12f80e37cb698dd1d277849b13f5e7bd62418ab0136fcf205b54904275abd526dbe8feb7171638ced480d05ea6ad87281daf92e07255e25f104dd9143e50ced126f6901df83df5de101231beae8735e58ea2bc92f1152ce46df138df1c519926e9872b176a73f70546691f40d2637b09303811588e8e241c7287c761a7083b06b1b0ed57147e7f3e8b41b7759ccc776ec86611420786b45a7c16b353027d8cabe1d04ac4b8272c2183e1416ba7a4b89dc5190a97347292462001cb0f8f7037cc332602e8c4ff21c0290df0df9746c2c5f9f55118fefe8d4ec2dc75115a5a7eedc211238ace69025029bb4e0e4fa6816010cfd388f2d63a6793668415f1754c6f0b3af839b3cc280aca2c8e486f044275abdd4652c2425edea4b0b3f4de374665fb280fc3b4acc12962770debdf303496aa3f7226dcd6a851afe898c1bbf3ae60695250ddcecc97be7dce889383ec482297a2adc63d6bc26c2fc25c96b37958824718d0ab00eef419307deedad0c240437597c97f59a450706eb0541ab63068d2e266924f438fd026c52caea81cccef80ec7002a60b0f213b2257d1f15010bd6b9cd09b5b95b217fd1ffe0722926743a40724c856847c23a93e2f15c52c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="您好, 此文章需要要密码才可以查看.">您好, 此文章需要要密码才可以查看.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> PDF密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《pytest测试实战》</title>
      <link href="/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/19/pytest%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/6E7FFAC4BE6AA9069DB81181D116D110.png" alt="《pytest测试实战》"></p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><hr><p>pytest是动态编程语言Python专用的测试框架，它具有易于上手、功能强大、第三方插件丰富、效率高、可扩展性好、兼容性强等特点。《pytest测试实战》深入浅出地讲解了pytest的使用方法，尤其是具有特色的fixture的用法。作者通过丰富的测试实例，手把手教读者编写简洁、易于维护的测试代码和插件，让你轻松掌握这个业界最受欢迎的Python测试工具。</p><p>第1章介绍pytest的安装，同时会介绍Tasks项目的数据结构部分（名为Task的namedtuple），并用它作为测试示例。我们会学习如何指定测试文件运行，以及pytest常用的命令行命令，包括重新运行失败测试、遇到失败即停止所有测试、控制堆栈跟踪、控制日志输出，等等。</p><p>第2章将使用pip在本地安装Tasks项目，学习在Python项目中如何组织测试目录，这样才能针对实际项目编写测试用例。这一章的所有示例都依赖外部程序，包括数据库写入。</p><p>第2章的重点是测试函数，你将学习在pytest中高效使用断言语句。这一章还会讲解marker标记功能的用法，marker标记可以将测试进行归类或分组，方便一起运行，也可以将某些测试标记为skip（跳过不执行），marker标记还可以告诉pytest我们知道某些测试是一定会失败的。如果希望运行指定的测试子集，除了使用marker，还可以将测试代码组织成测试目录、测试模块、测试类，然后运行。</p><p>并非所有的测试代码都要放到测试函数中。第3章介绍如何将测试数据、启动逻辑、销毁逻辑放入fixture（pytest定义的一种测试脚手架）。设置系统（或子系统、系统单元）是软件测试的重要环节，第3章将介绍用一个简单的fixture完成这方面的工作（包括对数据库进行初始化，写入数据以备测试之用）。Fixture模块的功能非常强大，你可以利用它简化测试代码，从而提高代码的可读性和可维护性。Fixture像测试函数一样，也有参数。利用参数，你只需要编写一份代码，就可以针对TinyDB和MongoDB（或其他Tasks项目支持的数据库）开展测试。</p><p>第4章介绍pytest内置的fixture以满足测试中常见的一些需求，包括生成和销毁临时目录、截取输出流（通过日志判定结果）、使用monkey patch、检查是否发出警告，等等。</p><p>第5章讲解如何在pytest中添加命令行选项，如何改进打印输出，如何打包分发自己编写的插件，如何共享定制化的pytest（包括fixture）。这一章开发的插件可以改善Tasks项目测试失败时的输出呈现方式。你还将学习测试自己的测试插件（元测试）。读完这一章，想必你已经等不及编写自己的插件了。附录C收集了一些热门的社区插件，可供参考。</p><p>第6章讲解通过pytest.ini文件修改默认配置，自定义pytest的运行方式。pytest.ini文件可以存放某些命令选项，从而减少你重复输入命令的次数；利用它还可以指定pytest忽略某些测试目录，或者指定pytest的最低版本，等等。使用tox.ini和setup.cfg文件也可以实现同样的功能。</p><p>第7章（最后一章）介绍pytest与其他工具的结合使用。我们将借助tox让Tasks项目在多个Python版本上运行；学习如何测试Tasks项目的CLI部分，而不必mock系统的其余部分；借助coverage.py检查Tasks项目代码块的测试覆盖情况；通过Jenkins发起测试并实时显示结果。最后，还会学习如何让pytest运行基于unittest的测试用例，以及把pytest的fixture共享给unittest的测试用例使用。</p><h3 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h3><hr><p>Brian Okken是一位有二十多年工作经验的软件测试工程师，他业余时间录制了Test &amp; Code和Python Bytes两个播客。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p>前言<br>第1章 pytest入门 1<br>1.1 资源获取 4<br>1.2 运行Pytest 5<br>1.3 运行单个测试用例 10<br>1.4 使用命令行选项 10<br>–collect-only选项 11<br>-k选项 11<br>-m选项 12<br>-x选项 13<br>–maxfail&#x3D;num 15<br>-s与–capture&#x3D;method 16<br>–lf（–last-failed）选项 16<br>–ff（–failed-first）选项 17<br>-v（–verbose）选项 17<br>-q（–quiet）选项 18<br>-l（–showlocals）选项 19<br>–tb&#x3D;style选项 20<br>–duration&#x3D;N选项 21<br>–version选项 22<br>-h（–help）选项 23<br>1.5 练习 24<br>1.6 预告 25<br>第2章 编写测试函数 27<br>2.1 测试示例程序 27<br>本地安装Tasks项目程序包 30<br>2.2 使用assert声明 32<br>2.3 预期异常 35<br>2.4 测试函数的标记 36<br>完善冒烟测试 38<br>2.5 跳过测试 40<br>2.6 标记预期会失败的测试 43<br>2.7 运行测试子集 45<br>单个目录 45<br>单个测试文件&#x2F;模块 46<br>单个测试函数 47<br>单个测试类 47<br>单个测试类中的测试方法 48<br>用测试名划分测试集合 48<br>2.8 参数化测试 49<br>2.9 练习 56<br>2.10 预告 57<br>第3章 pytest Fixture 59<br>3.1 通过conftest.py共享fixture 60<br>3.2 使用fixture执行配置及销毁逻辑 61<br>3.3 使用–setup-show回溯fixture的执行过程 63<br>3.4 使用fixture传递测试数据 64<br>3.5 使用多个fixture 66<br>3.6 指定fixture作用范围 68<br>修改Tasks项目的fixture作用范围 70<br>3.7 使用usefixtures指定fixture 73<br>3.8 为常用fixture添加autouse选项 74<br>3.9 为fixture重命名 75<br>3.10 Fixture的参数化 77<br>3.11 参数化Tasks项目中的fixture 80<br>3.12 练习 83<br>3.13 预告 83<br>第4章 内置Fixture 85<br>4.1 使用tmpdir和tmpdir_factory 86<br>在其他作用范围内使用临时目录 88<br>4.2 使用pytestconfig 90<br>4.3 使用cache 92<br>4.4 使用capsys 100<br>4.5 使用monkeypatch 102<br>4.6 使用doctest_namespace 106<br>4.7 使用recwarn 109<br>4.8 练习 110<br>4.9 预告 111<br>第5章 插件 113<br>5.1 寻找插件 114<br>5.2 安装插件 114<br>从PyPI安装 114<br>从PyPI安装指定版本 115<br>从.tar.gz或.whl文件安装 115<br>从本地目录安装 115<br>从Git存储仓库安装 116<br>5.3 编写自己的插件 116<br>5.4 创建可安装插件 121<br>5.5 测试插件 125<br>5.6 创建发布包 129<br>通过共享目录分发插件 130<br>通过PyPI发布插件 130<br>5.7 练习 131<br>5.8 预告 131<br>第6章 配置 133<br>6.1 理解pytest的配置文件 133<br>用pytest –help查看ini文件选项 135<br>插件可以添加ini文件选项 135<br>6.2 更改默认命令行选项 136<br>6.3 注册标记来防范拼写错误 136<br>6.4 指定pytest的最低版本号 138<br>6.5 指定pytest忽略某些目录 138<br>6.6 指定测试目录 139<br>6.7 更改测试搜索的规则 141<br>6.8 禁用XPASS 142<br>6.9 避免文件名冲突 143<br>6.10 练习 145<br>6.11 预告 145<br>第7章 pytest与其他工具的搭配使用 147<br>7.1 pdb：调试失败的测试用例 147<br>7.2 coverage.py：判断测试覆盖了多少代码 151<br>7.3 mock：替换部分系统 155<br>7.4 tox：测试多种配置 162<br>7.5 Jenkins CI：让测试自动化 166<br>7.6 unittest：用pytest运行历史遗留测试用例 173<br>7.7 练习 179<br>7.8 预告 180<br>附录A 虚拟环境 181<br>附录B Pip 183<br>附录C 常用插件 187<br>C.1 改变测试流程的插件 187<br>pytest-repeat：重复运行测试 187<br>pytest-xdist：并行运行测试 189<br>pytest-timeout：为测试设置时间限制 190<br>C.2 改善输出效果的插件 191<br>pytest-instafail：查看错误的详细信息 191<br>pytest-sugar：显示色彩和进度条 192<br>pytest-emoji：为测试增添一些乐趣 193<br>pytest-html：为测试生成HTML报告 195<br>C.3 静态分析用的插件 197<br>pytest-pycodestyle和pytest-pep8：Python代码风格检查 197<br>pytest-flake8：更多的风格检查 197<br>C.4 Web开发用的插件 198<br>pytest-selenium：借助浏览器完成自动化测试 198<br>pytest-django：测试Django应用 198<br>pytest-flask：测试Flask应用 199<br>附录D 打包和发布Python项目 201<br>D.1 创建可安装的模块 201<br>D.2 创建可安装的包 203<br>D.3 创建源码发布包和Wheel文件 205<br>D.4 创建可以从PyPI安装的包 209<br>附录E xUnit Fixture 211<br>E.1 xUnit Fixture的语法 211<br>E.2 混合使用pytest Fixture和xUnit Fixture 214<br>E.3 xUnit Fixture的限制 215<br>索引 216</p><h3 id="pytest测试实战-PDF-下载"><a href="#pytest测试实战-PDF-下载" class="headerlink" title="pytest测试实战 PDF 下载"></a>pytest测试实战 PDF 下载</h3><hr><p>链接: <a href="https://pan.baidu.com/s/1W_AsE70fmJI2aQDfmcEyJg?pwd=jxe5">https://pan.baidu.com/s/1W_AsE70fmJI2aQDfmcEyJg?pwd=jxe5</a> </p><p>提取码: jxe5</p><p>复制这段内容后打开百度网盘手机App，操作更方便哦</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 书籍推荐 </category>
          
          <category> 百度网盘PDF下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF下载 </tag>
            
            <tag> 编程 </tag>
            
            <tag> PyTest </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
